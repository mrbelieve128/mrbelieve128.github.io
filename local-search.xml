<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python中下划线的5种含义</title>
    <link href="undefined2019/11/22/Python%E4%B8%AD%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%845%E7%A7%8D%E5%90%AB%E4%B9%89/"/>
    <url>2019/11/22/Python%E4%B8%AD%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%845%E7%A7%8D%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>在用python重写算法，学习学习算法时，一时好奇（打基础）来学习了python的下划线</p><ul><li><p>单前导下划线：_var            小小警示，提示只在内部使用，非public和private那种</p></li><li><p>单末尾下划线：var_            解决命名冲突的问题</p></li><li><p>双前导下划线：__var          防止变量在子类中被重写，只能在类内访问</p></li><li><p>单下划线：_                        使用“_”来表示它只是一个临时值</p></li><li><p>双前导和末尾下划线：</p><pre><code>__var__</code></pre><p>这个感觉有点奇怪，一个是常见的类内init，另一个则是下面这种len的写法</p><p></p><pre><code class="python">class Linkedlist(object):    def __init__(self):        self.head = Node()        self.length = 0    def __len__(self):        return self.length</code></pre><p>当我在main里</p><pre><code class="python">def main():    L = Linkedlist()    L.append(3)    L.append(5)    print(&quot;链表长度&quot;,len(L))if __name__ == &#39;__main__&#39;:    main()</code></pre><p>这样也可以输出len来= =</p></li></ul><p>  学习的网站：</p><ul><li><a href="https://blog.csdn.net/tcx1992/article/details/80105645" target="_blank" rel="noopener">https://blog.csdn.net/tcx1992/article/details/80105645</a></li><li><a href="https://blog.csdn.net/zhangvalue/article/details/93606688" target="_blank" rel="noopener">https://blog.csdn.net/zhangvalue/article/details/93606688</a></li></ul><p>  感觉跟着一步步测试下来更会用，但想完全知道怎么来的估计得去翻文档www</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>What a day</title>
    <link href="undefined2019/11/19/What%20a%20day/"/>
    <url>2019/11/19/What%20a%20day/</url>
    
    <content type="html"><![CDATA[<p>明明说要调整作息的，结果头疼晚上睡了会，现在一点都不困了。。。。</p><h2 id="想学逆向"><a href="#想学逆向" class="headerlink" title="想学逆向"></a>想学逆向</h2><p>发现了mac上的一些软件之类的，<a href="https://www.jianshu.com/p/c04ac36c6641?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">link</a></p><p>入门<a href="https://blog.csdn.net/qq_21508727/article/details/80559270" target="_blank" rel="noopener">link</a></p><p>pwn学习流程<br>– [ ] 小甲鱼视频<br>– [ ] liveoverflow那一套视频入门<br>– [ ] Ctfwiki，每种类型例题跟着做一遍，realworld就漏洞战争，google project zero博客之类的<br>– [ ] 栈简单汇编就行，堆要去看linux源码,Malloc和free部分,常见的dlmalloc和ptmalloc,还有fastbins，glibc2.26之后是trachebins，所以还要看不同版本的源码</p><h2 id="在线ctf平台"><a href="#在线ctf平台" class="headerlink" title="在线ctf平台"></a>在线ctf平台</h2><p><a href="https://i.loli.net/2019/08/06/Jht7r9DY4xadcQZ.png" target="_blank" rel="noopener">![ctf平台](What a day.assets/Jht7r9DY4xadcQZ.png)</a></p><p>下那么多游戏就为了一起玩嘛。。。这样吧，等战雷会员过期了就删了吧。嗯</p><h1 id="GOGOGO！"><a href="#GOGOGO！" class="headerlink" title="GOGOGO！"></a>GOGOGO！</h1><h1 id="过几天重新开始一大早起床跑步吧"><a href="#过几天重新开始一大早起床跑步吧" class="headerlink" title="过几天重新开始一大早起床跑步吧!"></a>过几天重新开始一大早起床跑步吧!</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git同步到github和gitee</title>
    <link href="undefined2019/11/19/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E5%92%8Cgitee/"/>
    <url>2019/11/19/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E5%92%8Cgitee/</url>
    
    <content type="html"><![CDATA[<p>==按照此说明做下来保证可用，但我也还没完全研究透彻所以有诸多不足请多原谅==</p><h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><h2 id="1、建立一个仓库"><a href="#1、建立一个仓库" class="headerlink" title="1、建立一个仓库"></a>1、建立一个仓库</h2><p><a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com/</a><br><img src="/2019/11/19/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E5%92%8Cgitee/20190802193737452.png" srcset="undefined" alt="在这里插入图片描述"></p><h2 id="2、下载git"><a href="#2、下载git" class="headerlink" title="2、下载git"></a>2、下载git</h2><p><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a><br>可以跟随这个 <a href="https://blog.csdn.net/sishen47k/article/details/80211002" target="_blank" rel="noopener">https://blog.csdn.net/sishen47k/article/details/80211002</a> 安装</p><h1 id="二、开始操作"><a href="#二、开始操作" class="headerlink" title="二、开始操作"></a>二、开始操作</h1><h2 id="1、创建SSHkey"><a href="#1、创建SSHkey" class="headerlink" title="1、创建SSHkey"></a>1、创建SSHkey</h2><p>打开Git Bash，输入<code>ssh-keygen -t rsa</code><br>会分别提示你文件名，密码（可不设置），确认密码。一般三次回车就可以<br>在 C:\Users\“你的用户名”.ssh 目录下就会有.pub结尾的文件，用记事本打开，复制里面的东西，这就是你的SSH key</p><h2 id="2、添加key到Gitee"><a href="#2、添加key到Gitee" class="headerlink" title="2、添加key到Gitee"></a>2、添加key到Gitee</h2><p>gitee-&gt;设置-&gt;SSH公钥<br>把key粘贴进去，标题默认是本机的名字</p><h2 id="3、git连接到gitee"><a href="#3、git连接到gitee" class="headerlink" title="3、git连接到gitee"></a>3、git连接到gitee</h2><h3 id="https连接"><a href="#https连接" class="headerlink" title="https连接"></a>https连接</h3><p>拷贝下来你仓库的链接，如 <a href="https://gitee.com/xxxxx" target="_blank" rel="noopener">https://gitee.com/xxxxx</a><br>然后在你想同步的文件夹上右键<img src="/2019/11/19/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E5%92%8Cgitee/20190802195801320.png" srcset="undefined" alt="在这里插入图片描述"><br>点击GIt Bash Here，输入</p><pre><code>git remote add origin https://gitee.com/xxxxx</code></pre><p>add origin的origin是给他的一个命名<br>然后设置config，分别设置名字和邮箱</p><pre><code>git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;you@example.com&quot;</code></pre><h3 id="ssh链接-推荐"><a href="#ssh链接-推荐" class="headerlink" title="ssh链接 ==推荐=="></a>ssh链接 ==推荐==</h3><pre><code>$ssh -T git@gitee.comHi XXX! You&#39;ve successfully authenticated, but GITEE.COM does not provide shell access.</code></pre><p>则代表ssh链接成功</p><pre><code>git remote add gitee git@gitee.com:YourUserName/YourProjectName.git</code></pre><p>YourUserName和YourProjectName都是要具体看你自己的实际用户名和仓库名字<br>即可，可以通过<code>git remote -v</code>查看</p><p>添加你的文件<code>git add .</code></p><pre><code>git commit -m &quot;备注&quot;</code></pre><p>推送 <code>git push origin/gitee master</code><br>拉取 <code>git pull origin/gitee master</code> ==使用origin或者gitee取决于你给他的命名==</p><p>==这里的master应该也可以换成develop分支上传==</p><p>深入理解github模式请戳 <a href="https://blog.csdn.net/weixin_33547926/article/details/78545042" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33547926/article/details/78545042</a></p><h1 id="3、再次更新之后如何同步"><a href="#3、再次更新之后如何同步" class="headerlink" title="3、再次更新之后如何同步"></a>3、再次更新之后如何同步</h1><pre><code>git statusgit add -Agit commit -a -m &quot;备注&quot;git push origin/gitee master -f</code></pre><h1 id="使用VScode更新"><a href="#使用VScode更新" class="headerlink" title="使用VScode更新"></a>使用VScode更新</h1><p>==先保存文件，再暂存更改，随后拉取（pull），即可提交。提交完后再推送到（push）==</p><p><img src="/2019/11/19/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E5%92%8Cgitee/20190803083016935.png" srcset="undefined" alt="在这里插入图片描述"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>转载-编写shellcode测试工具</title>
    <link href="undefined2019/11/19/%E7%BC%96%E5%86%99shellcode%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <url>2019/11/19/%E7%BC%96%E5%86%99shellcode%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>不知不觉，shellcode已成功攻击过程中必不可少的步骤，后面的文章会继续介绍如何编写其它类型的shellcode。直到目前为止，每次完shellcode汇编代码，都需要找到之前（或者重新编写）带缓冲区溢出漏洞的代码进行测试，同时要不停地对准EIP以及esp地址。这对于测试shellcode的正确性来说，很不方便，也难以调试。为此，我们先编写shellcode测试工具，方便后面测试shellcode，所谓磨刀不误砍柴功。</p><p>shellcode测试工具sctest<br>我们将工具取名为sctest，是shell code test的缩写。<br>命令用法：sctest  &lt;shellcode二进制文件&gt;</p><p>该程序的实现很简单：</p><p>1） 读shellcode 二进制读到内存<br>2）将装载shellcode内存的属性变成可执行<br>3）跳到该shellcode执行</p><p>代码如下：</p><pre><code class="c">#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;char code[4096] __attribute__((aligned(4096)));int main(int argc, const char *argv[]){    int fd;    int ret;    void (*func)(void);    if (argc != 2) {    fprintf(stderr, &quot;\n\tUsage: sctest &lt;shellcode&gt;\n\n&quot;);    return 1;    }    fd = open(argv[1], O_RDONLY);    if (!fd) {    fprintf(stderr, &quot;Unable open file %s, err = %d(%m)\n&quot;, argv[1], errno);    return 2;    }    ret = read(fd, code, sizeof(code));    if (ret &lt; 0) {        fprintf(stderr, &quot;Unable read file %s, err = %d(%m)\n&quot;, argv[1], errno);        return 3;    }    ret = mprotect(code, sizeof(code), PROT_EXEC);    if (ret &lt; 0) {        fprintf(stderr, &quot;Unable mprotect, err = %d(%m)\n&quot;, errno);        return 4;    }    /* execute shell code */    func = (void (*)(void))code;    func();    abort();  }</code></pre><p>编译<br>到目前为止，shellcode的运行环境都是32位应用程序，以后涉及64位应用程序；由于同一程序不能混搭32和64位指令，因此需要编译两个工具（32位和64位）</p><p>$ gcc -Wall -g -o sctest32 sctest.c -m32<br>$ gcc -Wall -g -o sctest sctest.c</p><p>测试以前的shellcode</p><p>上篇文章中，介绍如何编写本地shellcode，使用sctest32工具对它进行测试：</p><p>当前 bash的pid</p><p>$ echo $$<br>2180</p><p>测试shellcode<br>ivan@ivan:~/exploit/tools$ ./sctest32 ../shell2</p><p>运行shellcode后sh的pid<br>$ echo $$<br>3178</p><p>两个pid不一样，说明 shell2成功启动了一个新sh</p><p>在后面的shellcode介绍中，我们会使用sctest32/sctest工具进行独立测试，不依赖于漏洞代码。</p><hr><p>版权声明：本文为CSDN博主「海枫」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/linyt/article/details/43538837" target="_blank" rel="noopener">https://blog.csdn.net/linyt/article/details/43538837</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>解密系列</title>
    <link href="undefined2019/11/19/%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97/"/>
    <url>2019/11/19/%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<hr><p>title:解密系列笔记</p><hr><h1 id="解密系列"><a href="#解密系列" class="headerlink" title="解密系列"></a>解密系列</h1><p>ASCII编码是Unicode字符编码的一部分</p><p>系统dll属于level3，内核运行在level0. </p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>在保护模式下：</p><ul><li>应用程序是不会直接访问物理地址的</li><li>虚拟内存管理器通过虚拟地址的访问请求，控制所有物理地址访问</li><li>每个程序都有独立的4GB寻址空间，不同程序的地址空间是被相互隔离的。</li><li>DLL程序没有自己的“私有”空间，它们称之为动态链接库文件，它们总是被映射到其他应用程序的地址空间中的，作为其他应用程序的一部分运行。</li></ul><p>==简化了内存的管理，并可弥补物理内存的不足，另外可以防止多任务环境下各个应用程序之间的冲突==</p><p>与实地址模式下的“段地址：偏移地址”索引方式类似，虚拟地址也写成“段：偏移量”，但为段选择子。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>手动脱壳</title>
    <link href="undefined2019/11/19/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/"/>
    <url>2019/11/19/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="手动脱壳"><a href="#手动脱壳" class="headerlink" title="手动脱壳"></a>手动脱壳</h2><p>可分为压缩壳（常见的有UPX、北斗、ASDPack、Npack、PECompact等）和保护壳（如强壳Safengine、VMprotect、winlicense、Themida等），压缩壳作用是把程序进行体积缩小化处理，保护壳主要作用是混淆或加密代码防止他人进行逆向程序、破解程序。</p><p>注意右面寄存器FPU的显示，当有且只有ESP和EIP为红色时，我们可以用ESP定律了</p><p><a href="https://baike.baidu.com/item/esp%E5%AE%9A%E5%BE%8B/840881?fr=aladdin#1" target="_blank" rel="noopener">ESP定律</a></p><p><a href="https://www.cnblogs.com/ichunqiu/p/6213852.html" target="_blank" rel="noopener">参考</a></p><h3 id="nsPack"><a href="#nsPack" class="headerlink" title="nsPack"></a>nsPack</h3><p>还要找到OEP，所谓的OEP，意即程序的入口点，可以用OD载入，不分析代码。</p><p>首先已知是nSPack壳，直接用OD打开，发现pushfd和pushad两句关键句：==win下的吾爱破解版od可==<img src="/2019/11/19/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/image-20190820143025540.png" srcset="undefined" alt="image-20190820143025540"></p><p>ESP定律的落脚点，可以看到落脚点下面一行就是一个大跳转，继续F8</p><p><img src="/2019/11/19/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/image-20190820143113466.png" srcset="undefined" alt="image-20190820143113466"></p><p><img src="/2019/11/19/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/image-20190820143126509.png" srcset="undefined" alt="image-20190820143126509"></p><p><img src="/2019/11/19/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/image-20190820143150130.png" srcset="undefined" alt="image-20190820143150130"></p><p><img src="/2019/11/19/%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/image-20190820143211831.png" srcset="undefined" alt="image-20190820143211831"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>19/9/20笔记</title>
    <link href="undefined2019/11/19/19920%E7%AC%94%E8%AE%B0/"/>
    <url>2019/11/19/19920%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="逆向笔记"><a href="#逆向笔记" class="headerlink" title="逆向笔记"></a>逆向笔记</h1><p>PE是windows下的文件，ELF是linux/unix下的文件</p><p>packer壳</p><p>28537194573619560LL LL-&gt;长长整型</p><p>可在汇编语言中寻找到mov rax ，指针 沿着指针 再按R看转换后的内容（由于低尾端，栈地址向低地址扩展，所以要将字符串反过来）</p><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><p>b 函数名</p><blockquote><p>下断点breakpoint</p><pre><code>b __libc_start_main #在主函数设置断点</code></pre></blockquote><p>set</p><pre><code>set $eip=地址 #跳转到某函数地址set $eip=0x0804849b</code></pre><p>r</p><blockquote><p>run 运行到我们下断点的地方，停止</p></blockquote><p>n</p><blockquote><p>运行一步</p></blockquote><p>x/200wx $寄存器</p><blockquote><p>x:就是用来查看内存中数值的，后面的200代表查看多少个，wx代表是以word字节查看看，$eax代表的eax寄存器中的值</p></blockquote><h2 id="反编译pyc"><a href="#反编译pyc" class="headerlink" title="反编译pyc"></a>反编译pyc</h2><blockquote><p>uncompyle2 -h</p></blockquote><p>==md5(md5($pass)) ：第一次加密后，结果转换成小写，对结果再加密一次.解密为：解密一次后，再解密一次==</p><p><img src="/2019/11/19/19920%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0.assets%5Cimage-20190820013756861.png" srcset="undefined" alt="image-20190820013756861"></p><blockquote><p>Re2-cpp-is-awesome</p></blockquote><pre><code class="cpp">if ( a1 != 2 )  {    v3 = *a2;    v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Usage: &quot;, a3);    v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v4, v3, v5);    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v6, &quot; flag\n&quot;, v7);    exit(0);  }                                             // 检测输入  std::allocator&lt;char&gt;::allocator(&amp;v13, a2, a3);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v12, a2[1], &amp;v13);  std::allocator&lt;char&gt;::~allocator(&amp;v13);  v15 = 0;  for ( i = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::begin(&amp;v12); ; iplusplus(&amp;i) )  {    v14 = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::end(&amp;v12);    if ( !iNotEqualV14((__int64)&amp;i, (__int64)&amp;v14) )      break;    v9 = *(unsigned __int8 *)thesame((__int64)&amp;i);    if ( (_BYTE)v9 != originalKey[Number[v15]] )//key      betterLuckNextTime((__int64)&amp;i, (__int64)&amp;v14, v9);    ++v15;  }  coutShouldHaveFlagNow((__int64)&amp;i, (__int64)&amp;v14, v8);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v12);  return 0LL;</code></pre><pre><code class="python">key = &#39;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t&#39;dump = [0x24,0x00,0x05,0x36,0x65,0x07,0x27,0x26,0x2D,0x01,0x03,0x00,0x0D,0x56,0x01,0x03,0x65,0x03,0x2D,0x16,0x02,0x15,0x03,0x65,0x00,0x29,0x44,0x44,0x01,0x44,0x2B]flag = &#39;&#39;for i in dump:    flag +=key[i]print(flag)</code></pre><p><img src="/2019/11/19/19920%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0.assets%5Cimage-20190820143248918.png" srcset="undefined" alt="image-20190820143248918"></p><p>记得全都要写下来，包括0</p><hr><p><img src="/2019/11/19/19920%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0.assets%5Cimage-20190821163335042.png" srcset="undefined" alt="image-20190821163335042"></p><p>不止可能是保存，还有可能读取文本中的字符串与程序里的对比</p><hr><p>IDA </p><p>快捷键Y 输入 char a[0x大小] 就可以自动转成字符串</p><p>汇编的条件跳转指令:</p><p>​      jmp :无条件跳转 (jump)</p><p>​      je/jz :结果为0跳转 (jump zero)</p><p>​      jnz/jne: 结果不为0跳转 (jump not zero)</p><p>​      js:结果为负跳转 (Jump if sign)</p><p>​      jns:结果为正跳转(Jump if not sign)</p><p>​      jb:小于则跳转（Jump below）</p><p>​     jnb:大于或等于则跳转(Jump not below)</p><p><a href="https://www.jianshu.com/p/dc3f6437c108" target="_blank" rel="noopener">运用Z来使得程序按照自己想法执行</a></p><p><img src="/2019/11/19/19920%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0.assets%5Cimage-20190830134741936.png" srcset="undefined" alt="image-20190830134741936"></p><hr><h3 id="大小端！！！！！！"><a href="#大小端！！！！！！" class="headerlink" title="大小端！！！！！！"></a>大小端！！！！！！</h3><p><img src="/2019/11/19/19920%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0.assets%5Cimage-20190822204713754.png" srcset="undefined" alt="image-20190822204713754"></p><p>mercedes!!!!</p><hr><p><img src="/2019/11/19/19920%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0.assets%5Cimage-20190826101318562.png" srcset="undefined" alt="image-20190826101318562"></p><p>搜索字符串</p><p><img src="/2019/11/19/19920%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0.assets%5Cimage-20190826101343642.png" srcset="undefined" alt="image-20190826101343642"></p><p>双击flag可找到使用地址</p><p>继续双击DATA XREF后面的信息可跳转到命令起始地址</p><hr><p>链表<a href="https://www.jianshu.com/p/7779f3e83384" target="_blank" rel="noopener">https://www.jianshu.com/p/7779f3e83384</a></p><p><a href="https://www.cnblogs.com/ha2ha2/p/7943339.html" target="_blank" rel="noopener">https://www.cnblogs.com/ha2ha2/p/7943339.html</a></p><hr><p>ext3</p><pre><code>mount filename /mnt/cd /mnt/find | grep &#39;flag&#39;</code></pre><hr><p>kali</p><pre><code>pdftotext filename.pdf 1.txt</code></pre><hr><h2 id="隐写"><a href="#隐写" class="headerlink" title="隐写"></a>隐写</h2><p>用chrome打开pdf 复制所有字符 A.B-</p><p>逐帧查看，或者使用stegslove</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>汇编基础</title>
    <link href="undefined2019/11/19/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
    <url>2019/11/19/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="X86汇编基础"><a href="#X86汇编基础" class="headerlink" title="X86汇编基础"></a>X86汇编基础</h2><p>==Intel和AT&amp;T语法区别：==</p><ul><li>Intel<strong>操作数</strong>在<strong>前面</strong>，AT&amp;T的在后面</li></ul><blockquote><p>在Intel语法中：<instruction> <destination operand> <source operand><br>在AT&amp;T语法中：<instruction> <source operand> <destination operand><br>有一个简单的记住它们的方法: 当你面对intel语法的时候，你可以想象把等号(=)放到2个操作数中间，当面对AT&amp;T语法的时候，你可以放一个右箭头(→）到两个操作数之间。</destination></instruction></destination></instruction></p></blockquote><ul><li>AT&amp;T: 寄存器名之前需要写一个百分号(%)并且在数字前面需要加上美元符($)。并用圆括号替代方括号</li><li>AT&amp;T: 以下是一些添加到操作符后，用来表示数据形式的后缀：<br>– q — quad (64 bits)<br>– l — long (32 bits)<br>– w — word (16 bits)<br>– b — byte (8 bits)</li></ul><hr><p><strong>重要：<code>MOV</code>指令在64位模式下，对低32位进行写入操作的时候，会清空高32位的内容[Int13]。比如 <code>MOV EAX，011223344h</code>将会把值写到RAX里，并且清空RAX的高32位区域。</strong></p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><blockquote><ol><li>EAX： 累加器</li><li>EBX： 基址寄存器</li><li>ECX： 计数器</li><li>EDX： 数据寄存器</li><li>ESI： 源变址寄存器</li><li>EDI： 目的变址寄存器</li><li>EBP： 扩展基址指针寄存器</li><li>ESP： 栈指针寄存器</li><li>EIP： 指令指针寄存器</li></ol><p>大多数寄存器失去了特殊用途，但<strong>ESP</strong>和<strong>EBP</strong>还是有特殊用途</p></blockquote><p><img src="/2019/11/19/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/image-20190821052642311.png" srcset="undefined" alt="image-20190821052642311"></p><h3 id="内存和寻址模式"><a href="#内存和寻址模式" class="headerlink" title="内存和寻址模式"></a>内存和寻址模式</h3><blockquote><p>.data</p><p>Var :</p><p>​        .byte 64 ;  声明一个字节型变量var，对应值为64</p><p>​        .byte 10 ；声明一个数据10，这个数据没有所谓的“标签”，它的内存地址就是 var + 1.</p></blockquote><pre><code>.byte        声明1个字节的数据.short    声明2个字节的数据.long        声明4个字节的数据</code></pre><h4 id="操作后缀"><a href="#操作后缀" class="headerlink" title="操作后缀"></a>操作后缀</h4><pre><code>movb $2,(%ebx);    将2移入到ebx中的值所表示的地址单元中movw $2,(%ebx); 将16位整数2移动到    ebx中的值所表示的地址单元    开始的两个字节中movl $2,(%ebx); 将32位整数2移动到 ebx中的值所表示的地址单元 开始的四个字节中</code></pre><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="mov-lt-reg-lt-reg"><a href="#mov-lt-reg-lt-reg" class="headerlink" title="mov &lt;reg, &lt;reg"></a>mov &lt;reg, &lt;reg</h3><blockquote><p>mov默认对寄存器值或变量值进行操作，可以从寄存器到寄存器，从立即数到寄存器，从存储单元到寄存器，从立即数到存储单元，从寄存器到存储单元</p></blockquote><p>将数据从第一个参数（即寄存器中的内容，内存单元中的内容，或者一个参数值）复制到第二个参数（即寄存器或者内存单元）。</p><p>但寄存器复制到寄存器可行时，直接地从内存单元中将数据移动到另一内存单元中是不可以的，必须把内存单元中的数据加载到一个寄存器中，然后才可以通过寄存器把<strong>数据</strong>移动到目标内存单元中。</p><h3 id="push-入栈"><a href="#push-入栈" class="headerlink" title="push 入栈"></a>push 入栈</h3><p>push先将ESP中的值减少4，然后将push 的参数移动到一个32位的地址单元（%esp）.esp地址从高地址到低地址逐渐减少，就像1000到0，先占1000，再999……空间有限</p><h3 id="pop-出栈"><a href="#pop-出栈" class="headerlink" title="pop 出栈"></a>pop 出栈</h3><p>先将内存（%esp）中4个字节的数据放到指定寄存器或者内存单元中，然后让esp+4</p><h3 id="lea-加载有效地址"><a href="#lea-加载有效地址" class="headerlink" title="lea 加载有效地址"></a>lea 加载有效地址</h3><p>将其第一个参数指定的内存单元 放入到 第二个参数指定的寄存器中。只计算有效地址并将其放入寄存器中。</p><h3 id="lea和mov的区别"><a href="#lea和mov的区别" class="headerlink" title="lea和mov的区别"></a>lea和mov的区别</h3><p>mov:</p><ul><li>对于变量，有无[ ] 都是取值</li><li>对于寄存器，无[ ] 表示取值，有[ ] 表示取地址</li></ul><p>Lea:</p><ul><li>对于变量，有无 都是取地址</li><li>对于寄存器，无[ ]表示取地址，有[ ] 表示取值</li></ul><h3 id="imul-整数相乘"><a href="#imul-整数相乘" class="headerlink" title="imul 整数相乘"></a>imul 整数相乘</h3><ul><li>两个参数的：先将两个参数相乘，然后把结果存在第二个参数（必须是一个寄存器）中</li><li>三个参数的：第一个（必须是常数）和第二个参数相乘，存在第三个参数（寄存器中）</li></ul><h3 id="idiv-整数相除"><a href="#idiv-整数相除" class="headerlink" title="idiv 整数相除"></a>idiv 整数相除</h3><p>只有一个操作数，为除数，被除数为EDX：EAX中的内容，商存在EAX中，余数存在EDX</p><h3 id="shl，shr-按位左移或者右移"><a href="#shl，shr-按位左移或者右移" class="headerlink" title="shl，shr 按位左移或者右移"></a>shl，shr 按位左移或者右移</h3><p>对第一个参数进行位运算，移动位数由第二个参数决定</p><hr><h2 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h2><p><code>STMFD SP!, {R4, LR}</code>，这条指令类似x86平台的<code>PUSH</code>指令，它会把2个寄存器（R4和LR）的值写到栈里。不过为了简化，在<code>armcc</code>编译器输出的汇编代码里会写成`PUSH {R4, LR}</p><p>这指令首先会减少<code>SP</code>的值，这样它在栈中指向的空间就被释放，以留给新条目使用，然后将R4和LR的值存入被修改后的<code>SP</code>的储存区域中。</p><p>值得注意的是：<code>STMFD</code>指令是广义的<code>PUSH</code>指令(扩展了它的功能)，因为他能操作任何寄存器，不只是<code>SP</code>。换句话说，<code>STMFD</code>可以用于将一组寄存器储存在特定的内存地址上。</p><p><code>MOV R0， #0</code>这条语句，这条语句就是把0写入R0寄存器。这是因为C函数返回了0，返回值会放在R0里。</p><p>最后一条指令是<code>LDMFD SP!, R4,PC</code>，这是STMFD的逆指令。为了将初始值存入<code>R4</code>和<code>PC</code>寄存器里，这条指令会从栈上(或任何其他的内存区域)读取保存的值，并且增加堆栈指针<code>SP</code>的值。这非常类似x86平台里的<code>POP</code>指令。</p><p>最前面那条<code>STMFD</code>指令，将<code>R4</code>，和<code>LR</code>寄存器成对保存到栈中。在<code>LDMFD</code>执行的时候，<code>R4</code>和<code>PC</code>会被复原。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>汇编、逆向工程基础</title>
    <link href="undefined2019/11/19/%E6%B1%87%E7%BC%96%E3%80%81%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>2019/11/19/%E6%B1%87%E7%BC%96%E3%80%81%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://blog.csdn.net/qq_21508727/article/details/80559270" target="_blank" rel="noopener">https://blog.csdn.net/qq_21508727/article/details/80559270</a></p><h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><blockquote><ol><li>·WORD（字） - 一个字由两个字节组成，共有16位。一个字的最大值是0FFFFh (或者是 65535d) (h代表16进制，d代表10进制)。</li><li>·DOUBLE WORD（双字DWORD） - 一个双字包含两个字，共有32位。最大值为0FFFFFFFF (或者是 4294967295d)。</li></ol><blockquote><p>一个16进制占4bit</p></blockquote></blockquote><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>Win+Intel CPU组成的计算机通常有9个32位寄存器 (w/o 标志寄存器)。它们是：</p><blockquote><ol><li>EAX： 累加器</li><li>EBX： 基址寄存器</li><li>ECX： 计数器</li><li>EDX： 数据寄存器</li><li>ESI： 源变址寄存器</li><li>EDI： 目的变址寄存器</li><li>EBP： 扩展基址指针寄存器</li><li>ESP： 栈指针寄存器</li><li>EIP： 指令指针寄存器</li></ol><blockquote><p>==大小都是4个字节==</p><blockquote><ol><li><p>EBP： EBP在栈中运用最广，刚开始没有什么需要特别注意的 ;) </p></li><li><p>ESP： ESP指向栈区域的栈顶位置。栈是一个存放即将会被用到的数据的地方，你可以去搜索一下push/pop 指令了解更多栈知识。 </p></li><li><p>EIP： EIP指向下一个将会被执行的指令。</p></li></ol><hr><p><strong>栈（stack）：后进先出的数据结构</strong>     </p><p><strong>堆（heap）：经过排列的树形数据结构，通常指二叉堆，存取是随意的</strong></p></blockquote></blockquote></blockquote><p>有一些寄存器是16位甚至8位的，是不能直接寻址的。</p><blockquote><p><img src="/2019/11/19/%E6%B1%87%E7%BC%96%E3%80%81%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/1565342053303.png" srcset="undefined" alt="1565342053303"></p></blockquote><p>一个寄存器可以这样看：</p><p><img src="/2019/11/19/%E6%B1%87%E7%BC%96%E3%80%81%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/1565342088084.png" srcset="undefined" alt="1565342088084"></p><p>EAX是名字，AX是低16位部分，又分为低8位AL，高8位AH</p><p><strong>了解：</strong></p><p>i.单字节（8位）寄存器：</p><blockquote><ol><li>AL and AH</li><li>BL and BH</li><li>CL and CH</li><li>DL and DH</li></ol></blockquote><p>ii.单字（16位）寄存器：这些寄存器大小为一个字（=2字节=16位）。一个单字寄存器包含两个单字节寄存器。通常根据功能区分</p><p>1.通用寄存器:</p><blockquote><ol><li>AX (单字=16位) = AH + AL -&gt; 其中‘+’号并不代表把它们代数相加。AH和AL寄存器是相互独立的，只不过都是AX寄存器的一部分，所以你改变AH或AL (或者都改变) ，AX寄存器也会被改变。 </li><li>-&gt; ‘accumulator’(累加器)：用于进行数学运算</li><li>BX -&gt; ‘base’(基址寄存器)：用来连接栈(之后会说明)</li><li>CX -&gt; ‘counter’(计数器)：</li><li>DX -&gt; ‘data’(数据寄存器)：大多数情况下用来存放数据</li><li>DI -&gt; ‘destination index’(目的变址寄存器): 例如将一个字符串拷贝到DI</li><li>SI -&gt; ‘source index’(源变址寄存器): 例如将一个字符串从SI拷贝</li></ol></blockquote><p>2.索引寄存器（指针寄存器）:</p><blockquote><ol><li>BP -&gt; ‘base pointer’(基址指针寄存器)：表示栈区域的基地址</li><li>SP -&gt; ‘stack pointer’(栈指针寄存器)：表示栈区域的栈顶地址</li></ol></blockquote><p>3.段寄存器：</p><blockquote><ol><li>CS -&gt; ‘code segment’(代码段寄存器)：用于存放应用程序代码所在段的段基址(之后会说明)</li><li>DS -&gt; ‘data segment’(数据段寄存器)：用于存放数据段的段基址(以后会说明)</li><li>ES -&gt; ‘extra segment’(附加段寄存器)：用于存放程序使用的附加数据段的基地址</li><li>SS -&gt; ‘stack segment’(栈段寄存器)：用于存放栈段的段基址(以后会说明)</li></ol></blockquote><p>4.指令指针寄存器：</p><blockquote><p>IP -&gt; ‘instruction pointer’(指令指针寄存器)：指向下一个指令 ;)</p></blockquote><p>iii. 双字(32位)寄存器：</p><p>2 字= 4 字节= 32 位， EAX、EBX、ECX、EDX、EDI…… </p><p>如果16位寄存器前面加了‘E’，就代表它们是32位寄存器。例如，AX=16位，EAX=32位。</p><h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>32位的CPU中有32个不同的标志寄存器，只关心期中三个：ZF、OF、CF。标志寄存器是一个标志，==只能是0或者1，决定了是否要执行某个指令==，可以知道程序在这一步是否会跳转。</p><h3 id="Z-Flag（零标志）"><a href="#Z-Flag（零标志）" class="headerlink" title="Z-Flag（零标志）"></a>Z-Flag（零标志）</h3><p>ZF是破解中用的最多的寄存器（通常90%）。若上一个运算结果为0，则值为1，否则为0。</p><h3 id="The-O-Flag（溢出标志）"><a href="#The-O-Flag（溢出标志）" class="headerlink" title="The O-Flag（溢出标志）"></a>The O-Flag（溢出标志）</h3><p>OF占约4%，若上一步改变了某寄存器的最高有效位，则会被设置为1。操作产生溢出时也会被设置为1。</p><h3 id="The-C-Flag（进位标志）"><a href="#The-C-Flag（进位标志）" class="headerlink" title="The C-Flag（进位标志）"></a>The C-Flag（进位标志）</h3><p>CF占1%，产生溢出，就会被设置为1。</p><h2 id="段偏移"><a href="#段偏移" class="headerlink" title="段偏移"></a>段偏移</h2><p>内存中的一个段储存了指令（CS）、数据（DS）、堆栈（SS）或者其他段（ES）。每一个段都有一个偏移量，在32位应用程序下，这些偏移量由00000000到FFFFFFFF。段和偏移量的标准形式如下：</p><blockquote><p>段：偏移量 = 把它们放在一起就是内存中一个具体的地址。</p><p>比喻：一个段是一本书的某一页；偏移量是一页的某一行。</p></blockquote><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><p><strong>内存中的栈区处于相对较高的地址以地址的增长方向为上的话，栈地址是向下增长的。</strong></p><p>栈中分配局部变量空间，堆区是向上增长的用于分配程序员申请的内存空间。另外还有静态区是分配静态变量，全局变量空间的；只读区是分配常量和程序代码空间的；以及其他一些分区。</p><blockquote><p>PUSH 命令是向栈中压入数据，POP命令就是从栈中取出最后放入的数据并且把它存进具体的寄存器中。</p></blockquote><h3 id="1、堆和栈申请和回收方式不同"><a href="#1、堆和栈申请和回收方式不同" class="headerlink" title="1、堆和栈申请和回收方式不同"></a>1、堆和栈申请和回收方式不同</h3><ul><li>栈：由系统自动分配空间，自动回收</li><li>堆：由程序员自己申请空间，不释放就可以一直访问</li></ul><h3 id="2、申请后系统响应"><a href="#2、申请后系统响应" class="headerlink" title="2、申请后系统响应"></a>2、申请后系统响应</h3><ul><li>栈：只要栈剩余空间,就自动分配空间，否则提示栈溢出</li><li>堆：==操作系统有一个记录空闲内存地址的链表==，系统收到空间申请会遍历该链表，寻找第一个大于申请空间的结点。并将结点从空闲结点链表删除，将空间分配给程序。==在这块内存空间的首地址会记录分配空间的大小，所以delete才能正确释放空间。==多余空间会放回空闲链表。 </li></ul><h3 id="3、堆申请效率比栈低"><a href="#3、堆申请效率比栈低" class="headerlink" title="3、堆申请效率比栈低"></a>3、堆申请效率比栈低</h3><h3 id="4、申请大小的限制"><a href="#4、申请大小的限制" class="headerlink" title="4、申请大小的限制"></a>4、申请大小的限制</h3><ul><li>栈：Win下，栈是==连续的内存区域==，==向低地址扩展的数据结构。栈顶地址和栈的最大容量是系统预先规定好的。==Win下栈大小为1M，申请空间超出剩余会提示overflow。</li><li>堆：向高地址拓展的数据结构，不连续的内存区域。（因为用链表储存）<strong>链表遍历从低地址到高地址。</strong>堆的大小受限于计算机系统中有效的虚拟内存。</li></ul><h3 id="5、堆和栈中的存储内容"><a href="#5、堆和栈中的存储内容" class="headerlink" title="5、堆和栈中的存储内容"></a>5、堆和栈中的存储内容</h3><ul><li>栈大小有限，用子函数有物理意义（？？？）</li><li>栈：调用函数时，第一个进栈的是主函数中函数调用后的下一条指令（下一条可执行语句）==的地址==，然后是函数的各个参数，在大多数C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。==静态变量不入栈。==</li></ul><p>==调用结束后，局部变量先出栈，然后是参数，最后栈顶指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行==</p><ul><li>堆:一般是在堆的头部用一个字节存放堆的大小。堆中具体内容由程序员安排。</li></ul><h3 id="6、存取效率的比较"><a href="#6、存取效率的比较" class="headerlink" title="6、存取效率的比较"></a>6、存取效率的比较</h3><pre><code class="cpp">char s1[] = &quot;aaaaaaaaaaaaaaa&quot;; char *s2 = &quot;bbbbbbbbbbbbbbbbb&quot;; </code></pre><p>aaaaaaaaaaa是在运行时刻赋值的；（字符数组有连续空间存放值）放在栈中。<br>而bbbbbbbbbbb是在编译时就确定的；（只有4字节的空间用于存放地址）放在堆中。<br>==在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快==</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>==所有值通常以16进制形式储存的。==</p><p>大部分指令有两个操作符（例如add EAX,EBX）,有些是一个（例如not EAX），还有一些是三个操作符（例如IMUL EAX，EDX，64）。如果使用“DWORD PTR [XXX]”就表示使用了内存中偏移量为XXX的数据。<strong>Win+Intel的电脑大多采用“低尾端法”，所以字节在内存中储存方式是倒过来的。</strong></p><blockquote><p>大部分有两个操作符的指令都是以下这种格式（以add举例）</p><pre><code>add eax,ebx                           寄存器, 寄存器add eax,123                           寄存器, 数值add eax,dword ptr [404000]            寄存器, Dword  指针 [数值]add eax,dword ptr [eax]               寄存器, Dword  指针 [寄存器值]add eax,dword ptr [eax+00404000]      寄存器, Dword  指针 [寄存器值+数值]add dword ptr [404000],eax            Dword 指针[数值], 寄存器add dword ptr [404000],123            Dword 指针[数值], 数值add dword ptr [eax],eax               Dword 指针[寄存器值], 寄存器add dword ptr [eax],123               Dword 指针[寄存器值], 数值add dword ptr [eax+404000],eax        Dword 指针[寄存器值+数值], 寄存器add dword ptr [eax+404000],123        Dword 指针[寄存器值+数值], 数值</code></pre></blockquote><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD 被加数，加数</p><p>将一个数值加在一个寄存器上或者一个内存地址上。</p><p>add eax,123 == eax = eax +123</p><p>加法指令对ZF，OF，CF都有影响</p><h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><p>AND 目标数，原数</p><p>AND运算对两个数进行逻辑与运算。</p><p>会清空OF,CF标记，设置ZF标记。</p><h3 id="CALL"><a href="#CALL" class="headerlink" title="CALL"></a>CALL</h3><blockquote><p>CALL 404000                 最常见: CALL 地址<br>CALL EAX                    CALL 寄存器 - 如果寄存器存的值为404000，那就等同于第一种情况<br>CALL DWORD PTR [EAX]        CALL [EAX]偏移量所指向的地址<br>CALL DWORD PTR [EAX+5]      CALL [EAX+5]偏移量所指向的地址</p></blockquote><h3 id="CDQ"><a href="#CDQ" class="headerlink" title="==CDQ=="></a>==CDQ==</h3><p>通常出现在除法前面，将EDX的所有位变成EAX最高位的值</p><p>比如当EAX&gt;=80000000h时，其二进制最高位为1，则EDX被32位全赋值为1，即FFFFFFFF</p><p>若EAX&lt;80000000，则其二进制最高位为0，EDX为00000000。</p><p>然后将EDX：EAX组成新数(64位)：FFFFFFFF 80000000</p><h3 id="CMP（compare）"><a href="#CMP（compare）" class="headerlink" title="CMP（compare）"></a>CMP（compare）</h3><p>CMP 目标数，原数</p><p>比较两个值并且标记CF、OF、ZF:</p><blockquote><p>CMP     EAX, EBX               比较eax和ebx是否相等，如果相等就设置ZF为1<br>CMP     EAX,[404000]           比较eax和偏移量为[404000]的值是否相等<br>CMP     [404000],EAX           比较[404000]是否与eax相等</p></blockquote><h3 id="DEC-decrease"><a href="#DEC-decrease" class="headerlink" title="DEC(decrease)"></a>DEC(decrease)</h3><p>DEC something</p><p>自减</p><blockquote><p>dec eax                              eax自减1<br>dec [eax]                            偏移量为eax的值自减1<br>dec [401000]                         偏移量为401000的值自减1<br>dec [eax+401000]                     偏移量为eax+401000的值自减1</p></blockquote><p>可以标记ZF、OF</p><h3 id="DIV（division除）"><a href="#DIV（division除）" class="headerlink" title="DIV（division除）"></a>DIV（division除）</h3><p>DIV 除数</p><p>无符号除法</p><p>DIV指令用来将EAX除以除数（无符号除法），被除数通常是EAX，结果也储存在EAX中，而被除数对除数取的模存在除数中。</p><blockquote><p>mov eax,64                       EAX = 64h = 100<br>mov ecx,9                        ECX = 9<br>div ecx                          EAX除以ECX</p></blockquote><p>EAX = 100/9 = 0B(11)并且ECX = 100 MOD 9 = 1</p><p>可以标记CF、OF、ZF</p><h3 id="IDIV（整除）"><a href="#IDIV（整除）" class="headerlink" title="IDIV（整除）"></a>IDIV（整除）</h3><p>IDIV 除数</p><p>有符号除法</p><p>执行方法同div一样</p><h3 id="INC（increase）"><a href="#INC（increase）" class="headerlink" title="INC（increase）"></a>INC（increase）</h3><p>自加</p><p>可以标记ZF、OF</p><p><strong>INT</strong></p><p>语法: int 目标数</p><p>INT 的目标数必须是产生一个整数(例如：int 21h)，类似于call调用函数，INT指令是调用程序对硬件控制，不同的值对应着不同的功能。</p><p>具体参照硬件说明书。</p><p><strong>JUMPS</strong></p><p>这些都是最重要的跳转指令和触发条件(重要用<em>标记，最重要用*</em>标记)：</p><pre><code>指令                条件                    条件JA*          -    如果大于就跳转(无符号)      - CF=0 and ZF=0JAE          -    如果大于或等于就跳转(无符号)- CF=0JB*          -    如果小于就跳转(无符号)   - CF=1JBE          -    如果小于或等于就跳转(无符号)- CF=1 or ZF=1JC           -    如果CF被标记就了跳转       - CF=1JCXZ         -    如果CX等于0就跳转      - CX=0JE**         -    如果相等就跳转        - ZF=1JECXZ        -    如果ECX等于0就跳转       - ECX=0JG*          -    如果大于就跳转(有符号)   - ZF=0 and SF=OF (SF = Sign Flag)JGE*         -    如果大于或等于就跳转(有符号) - SF=OFJL*          -    如果小于就跳转(有符号)    - SF != OF (!= is not)JLE*         -    如果小于或等于就跳转(有符号 - ZF=1 and OF != OFJMP**        -    跳转             - 强制跳转JNA          -    如果不大于就跳转(无符号)   - CF=1 or ZF=1JNAE         -    如果不大于等于就跳转(无符号) - CF=1JNB          -    如果不小于就跳转(无符号)   - CF=0JNBE         -    如果不小于等于就跳转(无符号) - CF=0 and ZF=0JNC          -    如果CF未被标记就跳转     - CF=0JNE**        -    如果不等于就跳转       - ZF=0JNG          -    如果不大于就跳转(有符号)   - ZF=1 or SF!=OFJNGE         -    如果不大于等于就跳转(有符号) - SF!=OFJNL          -    如果不小于就跳转(有符号)   - SF=OFJNLE         -    如果不小于等于就跳转(有符号) - ZF=0 and SF=OFJNO          -    如果OF未被标记就跳转     - OF=0JNP          -    如果PF未被标记就跳转     - PF=0JNS          -    如果SF未被标记就跳转      - SF=0JNZ          -    如果不等于0就跳转      - ZF=0JO           -    如果OF被标记就跳转     - OF=1JP           -    如果PF被标记就跳转     - PF=1JPE          -    如果是偶数就跳转       - PF=1JPO          -    如果是奇数就跳转       - PF=0JS           -    如果SF被标记就跳转     - SF=1JZ           -    如果等于0就跳转      - ZF=1</code></pre><p><strong>LEA (有效地址传送)</strong></p><p>语法：LEA 目的数、源数</p><p>LEA可以看成和MOV差不多的指令LEA ，它本身的功能并没有被太广泛的使用，反而广泛运用在快速乘法中：</p><p>lea eax，dword ptr [4*ecx+ebx]</p><p>将eax赋值为 4*ecx+ebx</p><p><strong>MOV (传送)</strong></p><p>语法: MOV 目的数,源数</p><p>这是一个很简单的指令，MOV指令将源数赋值给目的数，并且源数值保持不变</p><p>这里有一些MOV的变形：</p><p>MOVS/MOVSB/MOVSW/MOVSD EDI, ESI：这些变形能将ESI指向的内容传送到EDI指向的内容中去</p><p>MOVSX：MOVSX指令将单字或者单字节扩展为双字或者双字节传送，原符号不变</p><p>MOVZX：MOVZX扩展单字节或单字为双字节或双字并且用0填充剩余部分(通俗来说就是将源数取出置于目的数，其他位用0填充)</p><p><strong>MUL (multiply乘法)</strong></p><p>语法：MUL 数值</p><p>这个指令同IMUL一样，不过MUL可以乘无符号数。</p><p><strong>NOP (无操作)</strong></p><p>语法：NOP</p><p>这个指令说明不做任何事</p><p>所以它在逆向中运用范围最广</p><p><strong>OR (逻辑或)</strong></p><p>语法：OR 目的数,源数</p><p>OR指令对两个值进行逻辑或运算</p><p>这个指令会清空OF、CF标记，设置ZF标记</p><p>为了更好的理解OR，思考下面二进制串:</p><pre><code>10010101100101001101</code></pre><p>如果对它们进行逻辑与运算，结果将是1101011111。</p><p>只有当两边同为0时其结果为0，否则就为1。你可以用计算器尝试计算。希望你能理解为什么，最好自己动手算一算</p><p><strong>POP</strong></p><p>语法：POP 目的地址</p><p>POP指令将栈顶第一个字传送到目的地址。 每次POP后，ESP(栈指针寄存器)都会增加以指向新栈顶</p><p><strong>PUSH</strong></p><p>语法：PUSH 值</p><p>PUSH是POP的相反操作，它将一个值压入栈并且减小栈顶指针值以指向新栈顶。</p><p><strong>REP/REPE/REPZ/REPNE/REPNZ</strong></p><p>语法: REP/REPE/REPZ/REPNE/REPNZ ins</p><p>重复上面的指令：直到CX=0。ins必须是一个操作符，比如CMPS、INS、LODS、MOVS、OUTS、SCAS 或 STOS</p><p><strong>RET (return返回)</strong></p><p>语法：RET</p><p>RET digit</p><p>RET指令的功能是从一个代码区域中退出到调用CALL的指令处。</p><p>RET digit在返回前会清理栈</p><p><strong>SUB (减)</strong></p><p>语法：SUB 目的数,源数</p><p>SUB与ADD相反，它将源数减去目的数，并将结果储存在目的数中</p><p>SUB可以标记ZF、OF、CF</p><p><strong>TEST</strong></p><p>语法：TEST 操作符、操作符</p><p>这个指令99%都是用于”TEST EAX, EAX”，它执行与AND相同的功能，但是并不储存数据。如果EAX=0就会标记ZF，如果EAX不是0，就会清空ZF</p><p><strong>XOR</strong></p><p>语法：XOR 目的数,源数</p><p>XOR指令对两个数进行异或操作</p><p>这个指令清空OF、CF，但会标记ZF</p><p>为了更好的理解，思考下面的二进制串：</p><pre><code>10010101100101001101</code></pre><p>如果异或它们，结果将是1100011011</p><p>如果两个值相等，则结果为0，否则为1。</p><p>很多情况下我们会使用”XOR EAX, EAX”，这个操作是将EAX赋值为0，因为当一个值异或其自身，就过都是0。你最好自己动手尝试下，这样可以帮助你理解得更好</p><h3 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h3><p>==MOV AX , 2000H 将2000H传给AX==</p><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p><img src="/2019/11/19/%E6%B1%87%E7%BC%96%E3%80%81%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/Snipaste_2019-08-12_22-36-43.jpg" srcset="undefined" alt="Snipaste_2019-08-12_22-36-43"></p><h2 id="MIPS汇编"><a href="#MIPS汇编" class="headerlink" title="MIPS汇编"></a>MIPS汇编</h2><p><a href="https://www.cnblogs.com/thoupin/p/4018455.html" target="_blank" rel="noopener">link</a></p><p>xori 异或</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>博弈论</title>
    <link href="undefined2019/11/19/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    <url>2019/11/19/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/av41333177?p=2" target="_blank" rel="noopener"><br>LINK</a><br>《博弈圣经》博弈论的定义：我们把动物利用大自然移动的瘾魂，在决策人期待的空间里，形成三维均衡的学术理论，称为博弈论。<br>基本概念中包括局中人、行动、信息、策略、收益、均衡和结果等。其中局中人、策略和收益是最基本要素。局中人、行动和结果被统称为博弈规则。</p><h2 id="Class1"><a href="#Class1" class="headerlink" title="Class1"></a>Class1</h2><p><strong><em>定义：如果一个选项得到的结果严格优于另一个选项，那么称这个选项为严格优势策略。\</em></strong></p><p><strong>结论1：不要选择严格劣势策略</strong></p><p><strong>结论2：理性的选择，使得总结果变得更坏</strong></p><p>改变收益，就会改变目的。</p><p><strong><em>结论3：予欲得之，必先知之\</em></strong></p><p>结论4：分析他们（对手）的收益，站在别人的立场上去分析他们会怎么做</p><blockquote><p>2019/8/6</p></blockquote><hr><h2 id="Class2"><a href="#Class2" class="headerlink" title="Class2"></a>Class2</h2><p>博弈的要素：参与人（i,j）、策略（si,Si策略集合，s某一次博弈）、收益（U，Ui(s)）</p><p>s-i:除了i以外其他参与人每人的策略</p><table><thead><tr><th align="left">1/2</th><th align="left">L</th><th align="left">C</th><th align="left">R</th></tr></thead><tbody><tr><td align="left">T</td><td align="left">5,-1</td><td align="left">11,3</td><td align="left">0,0</td></tr><tr><td align="left">B</td><td align="left">6,4</td><td align="left">0,2</td><td align="left">2,0</td></tr></tbody></table><p>S1={T,B} S2={L,C,R}</p><p>U1(T,C)=11 U2(T，C)=3</p><p>定义：参与人i的策略s’i严格劣于另一个策略si，在其他人选择s-i时，选择si的收益UI严格优于此情况下选择s’i的收益UI</p><table><thead><tr><th align="left">De/Attach</th><th align="left">ez</th><th align="left">hard</th></tr></thead><tbody><tr><td align="left">E</td><td align="left">1,1</td><td align="left">1,1</td></tr><tr><td align="left">H</td><td align="left">0,2</td><td align="left">2,0</td></tr></tbody></table><p><strong><em>定义：参与者i的策略s’i，弱劣于策略si当且仅当在对手选择s-i的情况下，参与人i选择si的收益等于对手选s-i下他选s’i的收益，而且在任何情况下均成立。除此之外，对手选s-i参与者的i的策略si，严格优于其他策略s’i，至少在某种情况下成立\</em></strong>（参与者i的策略s’i弱劣于策略si，当且仅当无论对手怎么做，他选择si的收益至少与选择s‘i的相等，有些情况甚至是严格占优的）</p><p>共同知识：我知道一个事情，你也知道这件事，我知道你知道，你知道我知道……</p><p>相互知识不是共同知识，共同知识定义很严格。</p><blockquote><p>2019/8/7</p></blockquote><hr><h2 id="Class-3"><a href="#Class-3" class="headerlink" title="Class 3"></a>Class 3</h2><p>迭代剔除劣势策略：揣测对手意图，揣测对手知道我们的意图</p><p>商业会集中获得附近客源</p><p>==第三竞选者如何影响选举结果?==</p><p>最佳对策：最大化预期收益</p><p><a href="https://i.loli.net/2019/08/10/g9hIt6PSRsxrcul.png" target="_blank" rel="noopener"><img src="/2019/11/19/%E5%8D%9A%E5%BC%88%E8%AE%BA/g9hIt6PSRsxrcul.png" srcset="undefined" alt="Class 3 画图"></a></p><p>画图用数据解释比较好</p><blockquote><p>2019/8/8</p></blockquote><hr><h2 id="Class4"><a href="#Class4" class="headerlink" title="Class4"></a>Class4</h2><table><thead><tr><th align="left">F/D</th><th align="left">L</th><th align="left">R</th></tr></thead><tbody><tr><td align="left">L</td><td align="left">4.-4</td><td align="left">9,-9</td></tr><tr><td align="left">M</td><td align="left">6,-6</td><td align="left">6,-6</td></tr><tr><td align="left">R</td><td align="left">9,-9</td><td align="left">4,-4</td></tr></tbody></table><p><a href="https://i.loli.net/2019/08/10/3XoNK7aLYSU5VTM.png" target="_blank" rel="noopener"><img src="/2019/11/19/%E5%8D%9A%E5%BC%88%E8%AE%BA/3XoNK7aLYSU5VTM.png" srcset="undefined" alt="Class4 另一种画图方法"></a></p><p>不要选择一个任何选择下都非最佳对策的策略。</p><p><strong><em>最佳对策：参与人i的策略Si，是一个最佳对策（BR），是对手的策略S-i的最佳对策。如果参与人i在对手的s-i策略下，选Si的收益弱优于对手的其他策略Si’\</em></strong></p><p><strong><em>最佳对策：Si满足所有情况中，最大化了对手选S-i时我的收益\</em></strong></p><p>合伙人：两个实体共同完成一个协作项目，并且平分利润</p><p>外部性：我的努力不仅对我有利，对你也有利</p><p>纳什均衡：没人想选择其他策略，在这个点，互相都采用的是最佳策略</p><blockquote><p>2019/8/9</p></blockquote><p><strong><em>未完待续\</em></strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World!</title>
    <link href="undefined2019/11/19/hello-world/"/>
    <url>2019/11/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>2019/8/3日 15：22，我的网站算是正式开通了。这里可能是我展现最真实的我的地方，也用来记录我的学习过程和学习资料。在此先感谢一下毛同学的大力鼓吹，让我搞了这个，也感谢我的学校给我报销（笑</p><p>最近在学校的大数据班学习了在centOS搭建hadoop平台（使用java进行程序编写），最开始的是计算和管理都在一个模拟机里的伪分布式，一主一仆的也在回家后在自家电脑上完成了搭建。</p><p>后来为了搞github和gitee备份代码，又去研究了git如何使用，以及在vscode里同步代码，现在也是可以啦~点这可以看 相关代码和操作</p><p>为了在学校更好的敲代码（装逼），也是打算买一个豆子峡谷，装上黑苹果和centOS，平时用黑苹果和我的surface，计算时就用centOS。不得不说i58259U这东西好像挺强的，2/3个8700k，对比i7 8559u差距也不大。</p><p>今天也开始了DVWA的学习，学习使用kali，（虽然今早也没搞多少。。好像就搞了个Brup Force，连Brup Suite的爆破也没完全弄懂咋搞。。</p><p>就先这样吧。还有很多很多没搞懂，但最首先的先享受一下我最后的十来天暑假吧!</p><p>更新：11/19 使用hexo并部署到了github上，打算使用自己的云服务器做加速= =</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>